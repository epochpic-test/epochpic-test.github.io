<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Overview | EPOCH</title><link>/documentation/</link><atom:link href="/documentation/index.xml" rel="self" type="application/rss+xml"/><description>Overview</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 09 Sep 2018 00:00:00 +0000</lastBuildDate><image><url>/images/logo_hub4b4d6a0f57638acebb5550a80c8c030_9243_300x300_fit_lanczos_2.png</url><title>Overview</title><link>/documentation/</link></image><item><title>The EPOCH input deck</title><link>/documentation/input_deck/input_deck/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck/</guid><description>&lt;p>Most of the control of EPOCH is through a text file called &lt;code>input.deck&lt;/code>.
The input deck file must be in the output directory which is passed to
the code at runtime and contains all the basic information which is
needed to set up the code, including the size and subdivision of the
domain, the boundary conditions, the species of particles to simulate
and the output settings for the code. For most users this will be
capable of specifying all the initial conditions and output options they
need. More complicated initial conditions will be handled in later
sections.&lt;/p>
&lt;p>The input deck is a structured file which is split into separate blocks,
with each block containing several &amp;ldquo;parameter&amp;rdquo; = &amp;ldquo;value&amp;rdquo; pairs. The
pairs can be present in any order, and not all possible pairs must be
present in any given input deck. If a required pair is missing the code
will exit with an error message. The blocks themselves can also appear
in any order. The input deck is case sensitive, so true is always &amp;ldquo;T&amp;rdquo;,
false is always &amp;ldquo;F&amp;rdquo; and the names of the parameters are always lower
case. Parameter values are evaluated using a maths parser which is
described in
&lt;a href="/documentation/code_details/maths_parser">EPOCH maths parser&lt;/a>.
If the deck contains a &amp;ldquo;&lt;code>\&lt;/code>&amp;rdquo; character then the rest of the line is
ignored and the next line becomes a continuation of the current one.
Also, the comment character is &amp;ldquo;&lt;code>#&lt;/code>&amp;quot;; if the &amp;ldquo;&lt;code>#&lt;/code>&amp;rdquo; character is used
anywhere on a line then the remainder of that line is ignored.
There are three &lt;em>&lt;code>input deck directive&lt;/code>&lt;/em> commands, which are:&lt;/p>
&lt;ul>
&lt;li>begin:&lt;em>&lt;code>block&lt;/code>&lt;/em> - Begin the block named
&lt;em>&lt;code>block&lt;/code>&lt;/em>.&lt;/li>
&lt;li>end:&lt;em>&lt;code>block&lt;/code>&lt;/em> - Ends the block named
&lt;em>&lt;code>block&lt;/code>&lt;/em>.&lt;/li>
&lt;li>import:&lt;em>&lt;code>filename&lt;/code>&lt;/em> - Includes another file (called
&lt;em>&lt;code>filename&lt;/code>&lt;/em>) into the input deck at the point where the
directive is encountered. The input deck parser reads the included
file exactly as if the contents of the included file were pasted
directly at the position of the import directive.&lt;/li>
&lt;/ul>
&lt;p>Each block must be surrounded by valid &lt;em>&lt;code>begin:&lt;/code>&lt;/em> and
&lt;em>&lt;code>end:&lt;/code>&lt;/em> directives or the input deck will fail. There are
currently fourteen valid blocks hard coded into the input deck reader,
but it is possible for end users to extend the input deck. The fourteen
built in blocks are:&lt;/p>
&lt;ul>
&lt;li>control - Contains information about the general code setup. See
&lt;a href="/documentation/input_deck/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>boundaries - Contains information about the boundary conditions for
this run. See
&lt;a href="/documentation/input_deck/input_deck_boundaries">here&lt;/a>&lt;/li>
&lt;li>species - Contains information about the species of particles which
are used in the code. Also details of how these are initialised. See
&lt;a href="/documentation/input_deck/input_deck_species">here&lt;/a>&lt;/li>
&lt;li>laser - Contains information about laser boundary sources. See
&lt;a href="/documentation/input_deck/input_deck_laser">here&lt;/a>.&lt;/li>
&lt;li>fields - Contains information about the EM fields specified at the
start of the simulation. See
&lt;a href="/documentation/input_deck/input_deck_fields">here&lt;/a>.&lt;/li>
&lt;li>particles_from_file - Contains information about files used to
load particle data. See
&lt;a href="/documentation/input_deck/input_deck_particle_file">here&lt;/a>.&lt;/li>
&lt;li>window - Contains information about the moving window if the code is
used in that fashion. See
&lt;a href="/documentation/input_deck/input_deck_window">here&lt;/a>.&lt;/li>
&lt;li>output - Contains information about when and how to dump output
files. See
&lt;a href="/documentation/input_deck/input_deck_output_block">here&lt;/a>.&lt;/li>
&lt;li>output_global - Contains parameters which should be applied to all
output blocks. See
&lt;a href="/documentation/input_deck/input_deck_output_global">here&lt;/a>.&lt;/li>
&lt;li>dist_fn - Contains information about distribution functions that
should be calculated for output. See
&lt;a href="/documentation/input_deck/input_deck_dist_fn">here&lt;/a>.&lt;/li>
&lt;li>probe - Contains information about particle probes used for output.
See
&lt;a href="/documentation/input_deck/input_deck_probe">here&lt;/a>.&lt;/li>
&lt;li>collisions - Contains information about particle collisions. See
&lt;a href="/documentation/input_deck/input_deck_collisions">here&lt;/a>.&lt;/li>
&lt;li>qed - Contains information about QED pair production. See
&lt;a href="/documentation/input_deck/input_deck_qed">here&lt;/a>.&lt;/li>
&lt;li>subset - Contains configuration for filters which can be used to
modify the data to be output. See
&lt;a href="/documentation/input_deck/input_deck_subset">here&lt;/a>.&lt;/li>
&lt;li>constant - Contains information about user defined constants and
expressions. These are designed to simplify the initial condition
setup. See
&lt;a href="/documentation/input_deck/input_deck_constant">here&lt;/a>.&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>control block</title><link>/documentation/input_deck/input_deck_control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_control/</guid><description>&lt;p>The &lt;em>control&lt;/em> block contains information about the general code setup.
See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more information
on the input deck.&lt;/p>
&lt;h1 id="basics">Basics&lt;/h1>
&lt;p>The block sets up the basic code properties for the domain, the end time
of the code, the load balancer and the types of initial conditions to
use.&lt;/p>
&lt;p>The control block of a valid input deck for EPOCH2D reads as follows:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
# Global number of gridpoints
nx = 512 # in x
ny = 512 # in y
# Global number of particles
npart = 10 * nx * ny
# Final time of simulation
t_end = 1.0e-12
# nsteps = -1
# Size of domain
x_min = -0.1e-6
x_max = 400.0e-6
y_min = -400.0e-6
y_max = 400.0e-6
# dt_multiplier = 0.95
# dlb_threshold = 0.8
# restart_snapshot = 98
# field_order = 2
# maxwell_solver = yee
# stdout_frequency = 10
end:control
&lt;/code>&lt;/pre>
&lt;p>As illustrated in the above code block, the &amp;ldquo;&lt;code>#&lt;/code>&amp;rdquo; symbol is
treated as a comment character and the code ignores everything on a line
following this character.
The allowed entries are as follows:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>nx, ny, nz&lt;/code> - Number of grid points in the x,y,z
direction. This parameter is mandatory.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>npart&lt;/code> - The global number of pseudoparticles in the
simulation. This parameter does not need to be given if a specific
number of particles is supplied for each particle species by using the
&amp;ldquo;npart&amp;rdquo; directive in each
&lt;a href="/documentation/input_deck/input_deck_species">&lt;strong>species&lt;/strong> block&lt;/a>.
If both are given then the
value in the &lt;strong>control&lt;/strong> block will be ignored.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>nsteps&lt;/code> - The number of iterations of the core solver
before the code terminates. Negative numbers instruct the code to only
terminate at &lt;strong>t_end&lt;/strong>. If &lt;strong>nsteps&lt;/strong> is not specified then &lt;strong>t_end&lt;/strong>
must be given.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>t_end&lt;/code> - The final simulation time in simulation seconds
before the code terminates. If &lt;strong>t_end&lt;/strong> is not specified then
&lt;strong>nsteps&lt;/strong> must be given. If they are both specified then the first time
restriction to be satisfied takes precedence. Sometimes it is more
useful to specify the time in picoseconds or femtoseconds. To accomplish
this, just append the appropriate multiplication factor. For example,
&amp;ldquo;t_end = 3 * femto&amp;rdquo; specifies 3 femtoseconds. A list of multiplication
factors is supplied
&lt;a href="/documentation/code_details/maths_parser/#constants">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{x,y,z}_min&lt;/code> - Minimum grid position of the domain in
metres. These are required parameters. Can be negative. &amp;ldquo;{x,y,z}_start&amp;rdquo;
is accepted as a synonym. In a similar manner to that described above,
distances can be specified in microns using a multiplication constant.
eg. &amp;ldquo;x_min = 4 * micron&amp;rdquo; specifies a distance of 4 Î¼m.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{x,y,z}_max&lt;/code> - Maximum grid position of the domain in
metres. These are required parameters. Must be greater than
&lt;em>{x,y,z}_min&lt;/em>. &amp;ldquo;{x,y,z}_end&amp;rdquo; is accepted as a synonym.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dt_multiplier&lt;/code> - Factor by which the timestep is
multiplied before it is applied in the code, i.e. a multiplying factor
applied to the CFL condition on the timestep. Must be less than one. If
no value is given then the default of 0.95 is used. If maxwell_solver
is different from &amp;ldquo;yee&amp;rdquo; (the default) this parameter becomes
increasingly relevant.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dlb_threshold&lt;/code> - The minimum ratio of the load on the
least loaded processor to that on the most loaded processor allowed
before the code load balances. Set to 1 means always balance, set to 0
means never balance. If this parameter is not specified then the code
will only be load balanced at initialisation time.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>restart_snapshot&lt;/code> - The number of a previously written
restart dump to restart the code from. If not specified then the initial
conditions from the input deck are used.
Note that as of version 4.2.5, this parameter can now also accept a
filename in place of a number. If you want to restart from &amp;ldquo;0012.sdf&amp;rdquo;
then it can either be specified using &amp;ldquo;restart_snapshot = 12&amp;rdquo;, or
alternatively it can be specified using &amp;ldquo;restart_snapshot = 0012.sdf&amp;rdquo;.
This syntax is required if output file prefixes have been used (see the
&lt;a href="/documentation/input_deck/input_deck_output_block">output block&lt;/a> page).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>field_order&lt;/code> - Order of the finite difference scheme used
for solving Maxwell&amp;rsquo;s equations. Can be 2, 4 or 6. If not specified, the
default is to use a second order scheme.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Choose a Maxwell solver scheme with an extended stencil. This option
is only active if field_order is set to 2. Possible options are &amp;ldquo;yee&amp;rdquo;,
&amp;ldquo;lehe_{x,y,z}&amp;rdquo;, &amp;ldquo;pukhov&amp;rdquo;, &amp;ldquo;cowan&amp;rdquo; and since v4.12 &amp;ldquo;custom&amp;rdquo;. Note that
not all options are available in 1d and 2d. The default is &amp;ldquo;yee&amp;rdquo; which
is the default second order scheme.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stdout_frequency&lt;/code> - If specified then the code will print
a one line status message to stdout after every given number or
timesteps. The default is to print nothing to screen (i.e.
&lt;strong>stdout_frequency = 0&lt;/strong>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_random_seed&lt;/code> - The initial particle distribution is
generated using a random number generator. By default, EPOCH uses a
fixed value for the random generator seed so that results are
repeatable. If this flag is set to &amp;ldquo;T&amp;rdquo; then the seed will be generated
using the system clock.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>nproc{x,y,z}&lt;/code> - Number of processes in the &lt;em>x,y,z&lt;/em>
directions. By default, EPOCH will try to pick the best method of
splitting the domain amongst the available processors but occasionally
the user may wish to override this choice.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>smooth_currents&lt;/code> - This is a logical flag. If set to &amp;ldquo;T&amp;rdquo;
then a smoothing function is applied to the current generated during the
particle push. This can help to reduce noise and self-heating in a
simulation. The smoothing function used is the same as that outlined in
Buneman &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>field_ionisation&lt;/code> - Logical flag which turns on field
ionisation. See
&lt;a href="/documentation/input_deck/input_deck_species/#ionisation">here&lt;/a>
.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_bsi&lt;/code> - Logical flag which turns on barrier
suppression ionisation correction to the tunnelling ionisation model for
high intensity lasers. See
&lt;a href="/documentation/input_deck/input_deck_species/#ionisation">here&lt;/a> . This flag
should always be enabled when using field ionisation and is only
supplied for testing purposes. The default is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_multiphoton&lt;/code> - Logical flag which turns on modelling
ionisation by multiple photon absorption. This should be set to &amp;ldquo;F&amp;rdquo; if
there is no laser attached to a boundary as it relies on laser
frequency. See
&lt;a href="/documentation/input_deck/input_deck_species/#ionisation">here&lt;/a>.
This flag should always be enabled when using field ionisation and is
only supplied for testing purposes. The default is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>particle_tstart&lt;/code> - Specifies the time at which to start
pushing particles. This allows the field to evolve using the Maxwell
solver for a specified time before beginning to move the particles.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_exact_restart&lt;/code> - Logical flag which makes a
simulation restart as close as is numerically possible to if the
simulation had not been stopped and restarted. Without this flag set to
T then the simulation will still give a correct result after restart, it
is simply not guaranteed to be identical to if the code had not been
restarted. This flag is mainly intended for testing purposes and is not
normally needed for physical simulations. If set to &amp;ldquo;T&amp;rdquo; then the domain
split amongst processors will be identical along with the seeds for the
random number generators. Note that the flag will be ignored if the
number of processors does not match that used in the original run. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_current_correction&lt;/code> - Logical flag to specify
whether EPOCH should correct for residual DC current in the initial
conditions. If set to true, the DC current in the initial conditions is
calculated and is subtracted from all subsequent current depositions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>allow_cpu_reduce&lt;/code> - Logical flag which allows the
number of CPUs used to be reduced from the number specified. In some
situations it may not be possible to divide the simulation amongst
all the processors requested. If this flag is set to &amp;ldquo;T&amp;rdquo; then EPOCH
will continue to run and leave some of the requested CPUs idle. If
set to &amp;ldquo;F&amp;rdquo; then code will exit if all CPUs cannot be utilised. The
default value is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>check_stop_file_frequency&lt;/code> - Integer parameter
controlling automatic halting of the code. The frequency is
specified as number of simulation cycles. Refer to description later
in this section. The default value is 10.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stop_at_walltime&lt;/code> - Floating point parameter
controlling automatic halting of the code. Refer to description
later in this section. The default value is -1.0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stop_at_walltime_file&lt;/code> - String parameter controlling
automatic halting of the code. See
&lt;a href="#automatic_halting_of_a_simulation">below&lt;/a>. The default
value is an empty string.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>simplify_deck&lt;/code> - If this logical flag is set to &amp;ldquo;T&amp;rdquo;
then the deck parser will attempt to simplify the maths expressions
encountered after the first pass. This can significantly improve the
speed of evaluation for some input deck blocks. The default value is
&amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>print_constants&lt;/code> - If this logical flag is set to &amp;ldquo;T&amp;rdquo;,
deck constants are printed to the &amp;ldquo;deck.status&amp;rdquo; (and
&amp;ldquo;const.status&amp;rdquo; after 4.11) file as they are parsed. The default
value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_migration&lt;/code> - Logical flag which determines whether
or not to use
&lt;a href="/documentation/input_deck/input_deck_species/#particle_migration_between_species">particle migration&lt;/a>.
The default is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>migration_interval&lt;/code> - The number of timesteps between
each
&lt;a href="/documentation/input_deck/input_deck_species/#particle_migration_between_species">migration event&lt;/a>.
The default is 1 (migrate at every timestep).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>allow_missing_restart&lt;/code> - Logical flag to allow code to
run when a restart dump is absent. When &amp;ldquo;restart_snapshot&amp;rdquo; is
specified then the simulation first checks that the specified
restart dump is valid. If the restart dump exists and is valid then
it is used to provide initial conditions for the simulation.
However, if the restart dump does not exist or is not usable for
some reason then by default the simulation will abort. If
&amp;ldquo;allow_missing_restart&amp;rdquo; is set to &amp;ldquo;T&amp;rdquo; then the simulation will
not abort but will continue to run and use the initial conditions
contained in the input deck to initialise the simulation. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code> print_eta_string&lt;/code> - If this logical flag is set to
&amp;ldquo;T&amp;rdquo; then the current estimated time to completion will be appended
to the status updates. The default value is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code> n_zeros&lt;/code> - Integer flag which specifies the number of
digits to use for the output file numbers. (eg. &amp;ldquo;0012.sdf&amp;rdquo;). By
default, the code tries to calculate the number of digits required
by dividing t_end by dt_snapshot. Note that the minimum number of
digits is 4.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_accurate_n_zeros&lt;/code> - If this logical flag is set to &amp;ldquo;T&amp;rdquo; then the
code performs a more
rigorous test to determine the number of digits required to accommodate
all outputs that are to be generated by a run. Since this can be time
consuming and is overkill for most cases, it is disabled by default. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_particle_count_update&lt;/code> - If this logical flag is set to &amp;ldquo;T&amp;rdquo; then the code
keeps global particle counts for each species on each processor. This
information isn&amp;rsquo;t needed by the core algorithm, but can be useful for
developing some types of additional physics packages. It does require
one additional MPI_ALL_REDUCE per species per timestep, so it is not
activated by default. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>reset_walltime&lt;/code> - When restarting from a
dump file, the current walltime displayed will include the elapsed
walltime recorded in the restart dump. The user can request that this
time is ignored by setting the &amp;ldquo;reset_walltime&amp;rdquo; flag to &amp;ldquo;T&amp;rdquo;. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dlb_maximum_interval&lt;/code> - This integer parameter determines the maximum
number of timesteps to allow between load balancing checks. Each time
that the load balancing sweep is unable to improve the load balance of
the simulation, it doubles the number of steps before the next check
will occur. It will keep increasing the check interval until it reaches
the value given by &lt;strong>dlb_maximum_interval&lt;/strong>. If the value of
&lt;strong>dlb_maximum_interval&lt;/strong> is negative then the check interval will
increase indefinitely. When the load balancing sweep finds an
improvement to the load balance of the simulation, the check interval is
reset to one. The default value is 500.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dlb_force_interval&lt;/code> - This integer parameter determines the maximum number of timesteps to
allow between forcing a full load balance sweep. If the current load
balance is greater than the value of &lt;strong>dlb_threshold&lt;/strong> then the load
balancer exits before attempting to improve the loading. If
&lt;strong>dlb_force_interval&lt;/strong> is greater than zero, then the full load
balancer will be run at the requested interval of timesteps, regardless
of the value of &lt;strong>dlb_threshold&lt;/strong>. Note that the simulation will only
be redistributed if this would result in an improved load balance. The
default value is 2000.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>balance_first&lt;/code> - This logical flag determines whether a load balance will be attempted
on the first call of the load balancer. The load balancer performs to
functions: first it attempts to find a domain decomposition that
balances the load evenly amongst processors. Next, it redistributes the
domain and particles onto the new layout (if requred). This latter step
is always required when setting up the simulation, so the load balancer
is always called once during set-up. This flag controls whether or not a
load balance is attempted during this call, regardless of the value of
&lt;strong>dlb_threshold&lt;/strong>. The default value is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_pre_balance&lt;/code> - This logical flag determines whether a load balance
will be attempted before the particle load occurs. If this flag is set to
&amp;ldquo;T&amp;rdquo; then the particle auto-loader will be called at setup time, but
instead of creating particles it will just populate a particle-per-cell
field array. This will then be used to calculate the optimal domain
decomposition and all field arrays will be redistributed to use the new
layout. Finally, after all of this has been done, the auto-loader will be
called again and create just the particles that are present on their
optimally load-balanced domains. In contrast, if the flag is set to &amp;ldquo;F&amp;rdquo;
then the domain is just divided evenly amongst processors and the particles
are loaded on this domain decomposition. Balancing is then carried out on
to redistribute the work load. For heavily imbalanced problems, this can
lead to situations in which there is insufficient memory to setup a
simulation, despite there being sufficient resources for the final
load-balanced conditions. The default value is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_optimal_layout&lt;/code> - This logical flag determines whether the load
balancer attempts to find an optimal processor split before loading the
particles. The initial domain split is chosen in such a way as to minimize
the total surface area of the resulting domains in 3D, or edge lengths in
2D. For example, if a 2D square domain is run on 16 CPUs then the domain
will be divided by 4 in the x-direction and 4 in the y-direction. The other
possible splits (1x16, 2x8, 8x2, 16x1) are rejected because they all yield
rectangular subdomains whose total edge length is greater than the 4x4
edge length. For some problems (eg. a density ramp or thin foil) this is a
poor choice and a better load balance would be obtained by a less even
split. It is always possible to specify such a split by using
&lt;strong>nproc{x,y,z}&lt;/strong> flags but enabling the &lt;strong>use_optimal_layout&lt;/strong> flag will
automatically determine the best split for you. Future versions of the
code will also allow the split to be changed dynamically at run time. The
default value is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_more_setup_memory&lt;/code> - This logical flag determines whether the extra
memory will be used during the initial setup of particle species. If set
to false then only one set of arrays will be used for storing temperature,
density and drift during species loading. This can be a significant memory
saving but omes at the expense of recalculating grid quantities multiple
times. Setting the flag to true enables one set of arrays per species. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>deck_warnings_fatal&lt;/code> - This logical flag controls the behaviour of the
deck parser when a warning is encountered. Usually the code will just
print a warning message and continue running. Setting this flag to &amp;ldquo;T&amp;rdquo;
will force the code to abort. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="maxwell_solvers">Maxwell Solvers&lt;/h1>
&lt;p>With the default settings &amp;ldquo;field_order=2&amp;rdquo;, &amp;ldquo;maxwell_solver=yee&amp;rdquo; EPOCH
will use the standard second order Yee scheme for solving Maxwell&amp;rsquo;s
equations. This scheme has a grid dispersion relation with phase
velocities smaller than $c$, especially for large spatial frequencies.
Since EPOCH v4.11 it is possible to introduce extended stencils into the
update step of the Maxwell-Faraday equation which will help improving
the dispersion relation. All of the following extended stencils are only
available when &amp;ldquo;field_order=2&amp;rdquo;. Please note that you will also need to
choose an appropriate dt_multiplier, according to the selected scheme.
A dt_multiplier equal to unity would result in using the largest
time-step allowed by the CFL condition for any of the implemented
schemes. This time-step is said to be marginally stable. While, in
general, the marginally stable time-step has the best dispersion
properties, simulations may suffer from numerical problems such as
exponentially growing noise. Choosing smaller values for the
dt_multiplier tend to improve on this, while adversely affecting the
dispersion relation. The implemented solvers behave differently in this
regard.&lt;/p>
&lt;p>Different options are available as follows:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>maxwell_solver = lehe_{x,y,z}&lt;/code> - This setting will
enable an extended stencil proposed by Lehe et al &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. This stencil
focusses on improving the dispersion relation on the $x$-axis, please
take this into account when defining your laser input. It is available
in EPOCH1D, EPOCH2D and EPOCH3D. While it is not technically required to
use a dt_multiplier smaller than unity, the value proposed by Lehe et
al &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> is &amp;ldquo;dt_multiplier=0.96&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>maxwell_solver = pukhov&lt;/code> - This setting will enable an
extended stencil proposed by Pukhov &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> under the name of NDFX. It
is available in EPOCH2D and EPOCH3D. In EPOCH1D, setting
maxwell_solver = pukhov will make the code fall back silently to
Yee&amp;rsquo;s scheme. Pukhov&amp;rsquo;s NDFX scheme aims at improving the numerical
dispersion relation by allowing to choose &amp;quot; dt_multiplier= 1.0&amp;quot;,
while smaller values are also valid. The resulting dispersion
relation is best along the axis with the smallest grid spacing.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- -->
&lt;ul>
&lt;li>
&lt;p>&lt;code>maxwell_solver = cowan&lt;/code> - This setting will enable en
extended stencil proposed by Cowan et al &lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>. It is available only
in EPOCH3D. In EPOCH1D and EPOCH2D, setting maxwell_solver = cowan
will make the code fall back silently to Yee&amp;rsquo;s scheme. Cowan et al
&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup> proposes to numerically calculate a time step that has the
correct group velocity for the input laser. Typically these time
steps are only slightly below the CFL condition, e.g. &amp;quot; = 0.999&amp;quot;.
When Cowan&amp;rsquo;s scheme is reduced to 2D it is the same as Pukhov&amp;rsquo;s
scheme with dt_multiplier &amp;lt;1.0. The resulting dispersion relation
is best along the axis with the smallest grid spacing.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>maxwell_solver = custom&lt;/code> - This setting will enable full user control
over the extended stencil coefficients. This allows for the specification
of optimised coefficients as outlined in &lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup>. This option must be
accompanied by a &amp;ldquo;stencil&amp;rdquo; block. See
&lt;a href="/documentation/input_deck/input_deck_control/#stencil_block">below.&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="stencil_block">Stencil Block&lt;/h1>
&lt;p>The extended stencil Maxwell solvers described above all operate by
including points in neighbouring cells with a carefully chosen
weighting. These weightings are determined by adjusting the coefficients
shown in the Figure. Full control over these coefficients can be
achieved by specifying &amp;ldquo;custom&amp;rdquo; for the &amp;ldquo;maxwell_solver&amp;rdquo; parameter in
the control block and then supplying a &amp;ldquo;stencil&amp;rdquo; block to provide the
desired coefficient values.&lt;/p>
&lt;p>&lt;img src="../Stencil.png" alt="Coefficient locations for the B_z field computational stencil in2D.">
This option allows the user to specify an extended stencil scheme that
has been specifically optimised for the simulation grid spacing and
timestep. See &lt;sup id="fnref:8">&lt;a href="#fn:8" class="footnote-ref" role="doc-noteref">8&lt;/a>&lt;/sup> for further details.
or see
&lt;a href="https://github.com/Ablinne/optimize-stencil" target="_blank" rel="noopener">7&lt;/a> for stencil
optimization code. Note that there is no option for changing the value
of $\alpha_{x,y,z}$ since these are calculated using the following
equations:
$$
\begin{aligned}
\alpha_x &amp;amp;= 1 - 2\beta_{xy} - 2\beta{xz} - 3\delta_x\,, \\\&lt;br>
\alpha_y &amp;amp;= 1 - 2\beta_{yx} - 2\beta{yz} - 3\delta_y\,, \\\&lt;br>
\alpha_z &amp;amp;= 1 - 2\beta_{zx} - 2\beta{zy} - 3\delta_z\,.
\end{aligned}
$$&lt;/p>
&lt;ul>
&lt;li>&lt;code>delta{x,y,z}, gamma{x,y,z}, beta{xy,xz,yx,yz,zx,zy}&lt;/code> -
The coefficients to use for the extended stencil points as shown in
FigureÂ [stencil]. See for further details. These coefficients are
specified as floating point numbers. The default values are to set
all coefficients to zero which results in $\alpha_{x,y,z}$ having
values of unity. This corresponds to the standard Yee scheme.&lt;/li>
&lt;li>&lt;code>dt&lt;/code> - The timestep restriction to use for the field
solver&lt;/li>
&lt;/ul>
&lt;h1 id="strided_current_filtering">Strided Current Filtering&lt;/h1>
&lt;p>EPOCH 4.15 introduces strided multipass digital current filtering as
described and benchmarked in the review by
&lt;a href="https://www.sciencedirect.com/science/article/abs/pii/S163107211400148X" target="_blank" rel="noopener">Vey and
Godfrey&lt;/a>.
This can be tuned to substantially damp high frequencies in the currents
and can be used to reduce the effect of numerical Cherenkov radiation.
Once you turn on current filtering by specifying &amp;ldquo;smooth_currents=T&amp;rdquo;
you can then set the following keys&lt;/p>
&lt;ul>
&lt;li>&lt;code>smooth_iterations&lt;/code> - Integer number of iterations of
the smoothing function to be performed. If not present defaults to
one iteration. More iterations will produce smoother results but
will be slower.&lt;/li>
&lt;li>&lt;code>smooth_compensation&lt;/code> - Logical flag. If true then
perform a compensation step (see Vey and Godfrey) after the
smoothing steps are performed. Total number of iterations if true is
smooth_iterations + 1. If not specified defaults to false&lt;/li>
&lt;li>&lt;code>smooth_strides&lt;/code> - Either a comma separated list of
integers or &amp;ldquo;auto&amp;rdquo; (without quote marks). This specifies the
strides (in number of grid cells) to use when performing strided
filtering. Specifying &amp;ldquo;1, 3&amp;rdquo; will smooth each point with the
points immediately adjacent and with the points 3 cells away on each
side of the current cell. Setting this key to &amp;ldquo;auto&amp;rdquo; uses a &amp;ldquo;1,
2, 3, 4&amp;rdquo; set of strides as a &amp;ldquo;good&amp;rdquo; starting point for strided
filtering.&lt;/li>
&lt;/ul>
&lt;p>It should be stressed that there is no set of values that is guaranteed
to give any given result from filtering while not affecting the physical
correctness of your simulation. Current filtering should be tuned to
match the problem that you want to work on and should always be
carefully tested to ensure that it doesn&amp;rsquo;t produce unphysical results.&lt;/p>
&lt;h1 id="dynamic_load_balancing">Dynamic Load Balancing&lt;/h1>
&lt;p>&amp;ldquo;dlb&amp;rdquo; in the input deck stands for Dynamic Load Balancing and, when
turned on, it allows the code to rearrange the internal domain
boundaries to try and balance the workload on each processor. This
rearrangement is an expensive operation, so it is only performed when
the maximum load imbalance reaches a given critical point. This critical
point is given by the parameter &amp;ldquo;dlb_threshold&amp;rdquo; which is the ratio of
the workload on the least loaded processor to the most loaded processor.
When the calculated load imbalance is less than &amp;ldquo;dlb_threshold&amp;rdquo; the
code performs a re-balancing sweep, so if &amp;ldquo;dlb_threshold = 1.0&amp;rdquo; is set
then the code will keep trying to re-balance the workload at almost
every timestep. At present the workload on each processor is simply
calculated from the number of particles on each processor, but this will
probably change in future. If the &amp;ldquo;dlb_threshold&amp;rdquo; parameter is not
specified then the code will only be load balanced at initialisation
time.&lt;/p>
&lt;h1 id="automatic_halting_of_a_simulation">Automatic halting of a simulation&lt;/h1>
&lt;p>It is sometimes useful to be able to halt an EPOCH simulation midway
through execution and generate a restart dump. Two methods have been
implemented to enable this.&lt;/p>
&lt;p>The first method is to check for the existence of a &amp;ldquo;STOP&amp;rdquo; file.
Throughout execution, EPOCH will check for the existence of a file named
either &amp;ldquo;STOP&amp;rdquo; or &amp;ldquo;STOP_NODUMP&amp;rdquo; in the simulation output directory. The
check is performed at regular intervals and if such a file is found then
the code exits immediately. If &amp;ldquo;STOP&amp;rdquo; is found then a restart dump is
written before exiting. If &amp;ldquo;STOP_NODUMP&amp;rdquo; is found then no I/O is
performed.&lt;/p>
&lt;p>The interval between checks is controlled by the integer parameter
&amp;ldquo;check_stop_frequency&amp;rdquo; which can be specified in the &amp;ldquo;control&amp;rdquo; block
of the input deck. If it is less than or equal to zero then the check is
never performed.&lt;/p>
&lt;p>The next method for automatically halting the code is to stop execution
after a given elapsed walltime. If a positive value for
&amp;ldquo;stop_at_walltime&amp;rdquo; is specified in the control block of an input deck
then the code will halt once this time is exceeded and write a restart
dump. The parameter takes a real argument which is the time in seconds
since the start of the simulation.&lt;/p>
&lt;p>An alternative method of specifying this time is to write it into a
separate text file. &amp;ldquo;stop_at_walltime_file&amp;rdquo; is the filename from
which to read the value for &amp;ldquo;stop_at_walltime&amp;rdquo;. Since the walltime
will often be found by querying the queueing system in a job script, it
may be more convenient to pipe this value into a text file rather than
modifying the input deck.&lt;/p>
&lt;h1 id="requesting_output_dumps_at_run_time">Requesting output dumps at run time&lt;/h1>
&lt;p>In addition to polling for the existence of a &amp;ldquo;STOP&amp;rdquo; file, EPOCH also
periodically checks the output directory for a file named &amp;ldquo;DUMP&amp;rdquo;. If
such a file is found then EPOCH will immediately create an output dump
and remove the &amp;ldquo;DUMP&amp;rdquo; file. By default, the file written will be a
restart dump but if the &amp;ldquo;DUMP&amp;rdquo; file contains the name of an output
block then this will be used instead.&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>O. Buneman, &amp;ldquo;TRISTAN: The 3-D Electromagnetic Particle Code.&amp;rdquo; in
Computer Space Plasma Physics: Simulations Techniques and Software,
1993.
&lt;a href="https://www.terrapub.co.jp/e-library/cspp/" target="_blank" rel="noopener">1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>R. Lehe, A. Lifschitz, C. Thaury, V. Malka, and X. Davoine,
&amp;ldquo;Numerical growth of emittance in simulations of laser-wakefield
acceleration,&amp;rdquo; Phys. Rev. Accel. Beams, vol. 16, no. 2, p.021301,
2013
&lt;a href="https://www.researchgate.net/publication/258097872_Numerical_growth_of_emittance_in_simulations_of_laser-wakefield_acceleration" target="_blank" rel="noopener">2&lt;/a>.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>Pukhov, A., &amp;ldquo;Three-dimensional electromagnetic relativistic
particle-in-cell code VLPL (Virtual Laser Plasma Lab)&amp;rdquo;, J. Plasma
Phys., vol. 61, no. 3, p. 425, 1999
&lt;a href="https://www.cambridge.org/core/journals/journal-of-plasma-physics/article/three-dimensional-electromagnetic-relativistic-particle-in-cell-code-vlpl-virtual-laser-plasma-lab/7FBA476D599E2F19DFEA3F0F2F84FFAB" target="_blank" rel="noopener">3&lt;/a>.&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>B. Cowan, D. Bruhwiler, J. Cary, E. Cormier-Michel, and C. Geddes,
&amp;ldquo;Generalized algorithm for control of numerical dispersion in
explicit time-domain electromagnetic simulations&amp;rdquo;, Phys. Rev.
Accel. Beams, vol. 16, no. 4, p. 041303, 2013
&lt;a href="https://journals.aps.org/prab/abstract/10.1103/PhysRevSTAB.16.041303" target="_blank" rel="noopener">4&lt;/a>.&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6" role="doc-endnote">
&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/li>
&lt;li id="fn:7" role="doc-endnote">
&lt;p>A. Blinne, D. Schinkel, S. Kuschel, N. Elkina, S. G. Rykovanov,
and M. Zepf, &amp;ldquo;A systematic approach to numerical dispersion in
Maxwell solvers&amp;rdquo;, Computer Physics Communications, 00104655,
2017
&lt;a href="https://arxiv.org/pdf/1710.06829.pdf" target="_blank" rel="noopener">5&lt;/a>&amp;#160;&lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:8" role="doc-endnote">
&lt;p>A. Blinne, D. Schinkel, S. Kuschel, N. Elkina, S. G. Rykovanov,
and M. Zepf, &amp;ldquo;A systematic approach to numerical dispersion in
Maxwell solvers&amp;rdquo;, Computer Physics Communications, 00104655,
2017
&lt;a href="https://arxiv.org/pdf/1710.06829.pdf" target="_blank" rel="noopener">6&lt;/a>&amp;#160;&lt;a href="#fnref:8" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>boundaries block</title><link>/documentation/input_deck/input_deck_boundaries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_boundaries/</guid><description>&lt;p>This block contains information about the boundary conditions for this
run. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more
information on the input deck.&lt;/p>
&lt;h1 id="basics">Basics&lt;/h1>
&lt;p>The &lt;em>&lt;code>boundaries&lt;/code>&lt;/em> block sets the boundary conditions of each
boundary of the domain. Some types of boundaries allow EM wave sources
(lasers) to be attached to a boundary. Lasers are attached at the
initial conditions stage.&lt;/p>
&lt;p>An example boundary block for EPOCH2D is as follows:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:boundaries
bc_x_min = simple_laser
bc_x_max_field = simple_outflow
bc_x_max_particle = simple_outflow
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>boundaries&lt;/code> block accepts the following parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>bc_{x,y,z}_min&lt;/code> - The condition for the lower boundary
for both fields and particles. &amp;ldquo;xbc_left&amp;rdquo;, &amp;ldquo;ybc_down&amp;rdquo; and &amp;ldquo;zbc_back&amp;rdquo;
are accepted as a synonyms.&lt;/li>
&lt;li>&lt;code>bc_{x,y,z}_min_{field,particle}&lt;/code> - The condition for
the lower boundary for {fields,particles}.
&amp;ldquo;xbc_left_{field,particle}&amp;rdquo;, &amp;ldquo;ybc_down_{field,particle}&amp;rdquo; and
&amp;ldquo;zbc_back_{field,particle}&amp;rdquo; are accepted as a synonyms.&lt;/li>
&lt;li>&lt;code>bc_{x,y,z}_max&lt;/code> - The condition for the upper boundary
for both fields and particles. &amp;ldquo;xbc_right&amp;rdquo;, &amp;ldquo;ybc_up&amp;rdquo; and &amp;ldquo;zbc_front&amp;rdquo;
are accepted as a synonyms.&lt;/li>
&lt;li>&lt;code>bc_{x,y,z}_max_{field,particle}&lt;/code> - The condition for
the upper boundary for {fields,particles}.
&amp;ldquo;xbc_right_{field,particle}&amp;rdquo;, &amp;ldquo;ybc_up_{field,particle}&amp;rdquo; and
&amp;ldquo;zbc_front_{field,particle}&amp;rdquo; are accepted as a synonyms.&lt;/li>
&lt;li>&lt;code>cpml_thickness&lt;/code> - The thickness of the
&lt;a href="#cpml_boundary_conditions">CPML&lt;/a> boundary in terms of the
number of grid cells. The default value is 6.&lt;/li>
&lt;li>&lt;code>cpml_kappa_max&lt;/code> - A tunable
&lt;a href="#cpml_boundary_conditions">CPML&lt;/a> parameter.&lt;/li>
&lt;li>&lt;code>cpml_a_max&lt;/code> - A tunable
&lt;a href="#cpml_boundary_conditions">CPML&lt;/a> parameter.&lt;/li>
&lt;li>&lt;code>cpml_sigma_max&lt;/code> - A tunable
&lt;a href="#cpml_boundary_conditions">CPML&lt;/a> parameter.
There are ten boundary types in EPOCH and each boundary of the domain
can have one and only one of these boundaries attached to it. These
boundary types are:&lt;/li>
&lt;li>&lt;code>periodic&lt;/code> - A simple periodic boundary condition. Fields
and/or particles reaching one edge of the domain are wrapped round to
the opposite boundary. If either boundary condition is set to periodic
then the boundary condition on the matching boundary at the other side
of the box is also assumed periodic.&lt;/li>
&lt;li>&lt;code>simple_laser&lt;/code> - A characteristic based boundary condition
to which one or more EM wave sources can be attached. EM waves impinging
on a &lt;em>simple_laser&lt;/em> boundary are transmitted with as little reflection
as possible. Particles are fully transmitted. The field boundary
condition works by allowing outflowing characteristics to propagate
through the boundary while using the attached lasers to specify the
inflowing characteristics. The particles are simply removed from the
simulation when they reach the boundary. See
&lt;a href="/documentation/input_deck/input_deck_laser"> laser
blocks&lt;/a> for details.&lt;/li>
&lt;li>&lt;code>simple_outflow&lt;/code> - A simplified version of &lt;em>simple_laser&lt;/em>
which has the same properties of transmitting incident waves and
particles, but which cannot have EM wave sources attached to it. These
boundaries are about 5% more computationally efficient than
&lt;em>simple_laser boundaries&lt;/em> with no attached sources. This boundary
condition again allows outflowing characteristics to flow unchanged, but
this time the inflowing characteristics are set to zero. The particles
are again simply removed from the simulation when they reach the
boundary.&lt;/li>
&lt;li>&lt;code>reflect&lt;/code> - This applies reflecting boundary conditions to
particles. When specified for fields, all field components are clamped
to zero.&lt;/li>
&lt;li>&lt;code>conduct&lt;/code> - This applies perfectly conducting boundary
conditions to the field. When specified for particles, the particles are
reflected.&lt;/li>
&lt;li>&lt;code>open&lt;/code> - When applied to fields, EM waves outflowing
characteristics propagate through the boundary. Particles are
transmitted through the boundary and removed from the system.&lt;/li>
&lt;li>&lt;code>cpml_laser&lt;/code> - See
&lt;a href="#cpml_boundary_conditions">#CPML boundary
conditions&lt;/a>.&lt;/li>
&lt;li>&lt;code>cpml_outflow&lt;/code> - See
&lt;a href="#cpml_boundary_conditions">#CPML boundary
conditions&lt;/a>.&lt;/li>
&lt;li>&lt;code>thermal&lt;/code> - See
&lt;a href="#thermal_boundaries">#Thermal
boundaries&lt;/a>.&lt;/li>
&lt;li>&lt;code>**NOTE: If simple_laser, simple_outflow, cpml_laser, cpml_outflow or open are specified on one or more boundaries then the code will no longer necessarily conserve mass.**&lt;/code>
&lt;span style="color:#ff0000">Note also that it is possible for the user
to specify contradictory, unphysical boundary conditions. It is the
users responsibility that these flags are set correctly.`&lt;/li>
&lt;/ul>
&lt;h1 id="cpml_boundary_conditions">CPML boundary conditions&lt;/h1>
&lt;p>There are now Convolutional Perfectly Matched Layer boundary conditions
in EPOCH. The implementation closely follows that outlined in the book
&amp;ldquo;Computational Electrodynamics: The Finite-Difference Time-Domain
Method&amp;rdquo; by Taflove and Hagness&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. See also Roden and Gedney&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>.&lt;/p>
&lt;p>CPML boundaries are specified in the input deck by specifying either
&amp;ldquo;cpml_outflow&amp;rdquo; or &amp;ldquo;cpml_laser&amp;rdquo; in the boundaries block.
&amp;ldquo;cpml_outflow&amp;rdquo; specifies an absorbing boundary condition whereas
&amp;ldquo;cpml_laser&amp;rdquo; is used to attach a laser to an otherwise absorbing
boundary condition.&lt;/p>
&lt;p>There are also four configurable parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>cpml_thickness&lt;/code> - The thickness of the CPML boundary in
terms of the number of grid cells. The default value is 6.&lt;/li>
&lt;li>&lt;code>cpml_kappa_max&lt;/code>, &lt;code>cpml_a_max&lt;/code>,
&lt;code>cpml_sigma_max&lt;/code> - These are tunable parameters which
affect the behaviour of the absorbing media. The notation follows that
used in the two references quoted above. Note that the
&amp;ldquo;cpml_sigma_max&amp;rdquo; parameter is normalised by $\sigma_{\rm opt}$ which
is taken to be 3.2/dx (see Taflove and Hagness[^3] for details). These
are real valued parameters which take the following default values:
cpml_kappa_max=20, cpml_a_max=0.15, cpml_sigma_max=0.7
An example usage is as follows:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code> begin:boundaries
cpml_thickness = 16
cpml_kappa_max = 20
cpml_a_max = 0.2
cpml_sigma_max = 0.7
bc_x_min = cpml_laser
bc_x_max = cpml_outflow
bc_y_min = cpml_outflow
bc_y_max = cpml_outflow
end:boundaries
&lt;/code>&lt;/pre>
&lt;h1 id="thermal_boundaries">Thermal boundaries&lt;/h1>
&lt;p>Thermal boundary conditions have been added to the &amp;ldquo;boundaries&amp;rdquo; block.
These simulate the existence of a &amp;ldquo;thermal bath&amp;rdquo; of particles in the
domain adjacent to the boundary. When a particle leaves the simulation
it is replace with an incoming particle sampled from a Maxwellian of a
temperature corresponding to that of the initial conditions. It is
requested using the keyword &amp;ldquo;thermal&amp;rdquo;. For example:&lt;/p>
&lt;pre>&lt;code> begin:boundaries
bc_x_min = laser
bc_x_max = thermal
end:boundaries
&lt;/code>&lt;/pre>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>A. Taflove and S. C. Hagness, Computational Electrodynamics: The
Finite-Difference Time-Domain Method. Artech House,
2000.
&lt;a href="https://www.researchgate.net/publication/202924435_Computational_Electrodynamics_The_Finite-Difference_Time-Domain_Method" target="_blank" rel="noopener">1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>J. Roden and S. Gedney, &amp;ldquo;Convolution pml (cpml): An efficient fdtd
implementation of the cfs-pml for arbitrary media,&amp;rdquo; Microw. Opt.
Technol. Lett.,
2000.
&lt;a href="https://www.researchgate.net/publication/228078114_Convolutional_PML_CPML_an_efficient_FDTD_implementation_of_the_CFS-PML_for_arbitrary_media" target="_blank" rel="noopener">2&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>species block</title><link>/documentation/input_deck/input_deck_species/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_species/</guid><description>&lt;p>This block contains information about the species of particles which are
used in the code. Also details of how these are initialised. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;h1 id="basics">Basics&lt;/h1>
&lt;p>The next section of the input deck describes the particle species used
in the code. An example species block for any EPOCH code is given below.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Electron
charge = -1.0
mass = 1.0
frac = 0.5
# npart = 2000 * 100
number_density = 1.e4
temp = 1e6
temp_x = 0.0
temp_y = temp_x(Electron)
number_density_min = 0.1 * den_max
number_density = if(abs(x) lt thick, den_max, 0.0)
number_density = if((x gt -thick) and (abs(y) gt 2e-6), \
0.0, number_density(Carbon))
end:species
begin:species
name = Carbon
charge = 4.0
mass = 1836.0*12
frac = 0.5
number_density = 0.25*number_density(Electron)
temp_x = temp_x(Electron)
temp_y = temp_x(Electron)
dumpmask = full
end:species
&lt;/code>&lt;/pre>
&lt;p>Each species block accepts the following parameters:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>name&lt;/code> - This specifies the name of the particle species
defined in the current block. This name can include any alphanumeric
characters in the basic ASCII set. The name is used to identify the
species in any consequent input block and is also used for labelling
species data in any output dumps. It is a mandatory parameter.
**&lt;code>NOTE: IT IS IMPOSSIBLE TO SET TWO SPECIES WITH THE SAME NAME!&lt;/code>
**&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>charge&lt;/code> - This sets the charge of the species in
multiples of the electron charge. Negative numbers are used for
negatively charged particles. This is a mandatory parameter.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>mass&lt;/code> - This sets the mass of the species in multiples
of the electron mass. Cannot be negative. This is a mandatory
parameter.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>npart&lt;/code> - This specifies the number of pseudoparticles
which should be loaded into the simulation domain for this species
block. Using this parameter is the most convenient way of loading
particles for simulations which contain multiple species with
different number densities. If &lt;em>npart&lt;/em> is specified in a species
block then any value given for &lt;em>npart&lt;/em> in the
&lt;a href="/documentation/input_deck/input_deck_control">&lt;em>control&lt;/em>&lt;/a> block is ignored.
&lt;em>npart&lt;/em> should not be specified at the same time as &lt;em>frac&lt;/em> within a
&lt;em>species&lt;/em> block.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>frac&lt;/code> - This specifies what fraction of &lt;em>npart&lt;/em> (the
global number of particles specified in the control block) should be
assigned to the species.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>**&lt;code>NOTE: frac should not be specified at the same time as npart for a given species.&lt;/code>
**&lt;/p>
&lt;ul>
&lt;li>&lt;code>npart_per_cell&lt;/code> - Integer parameter which specifies
the number of particles per cell to use for the initial particle
loading. At a later stage this may be extended to allow
&amp;ldquo;npart_per_cell&amp;rdquo; to be a spatially varying function.&lt;/li>
&lt;/ul>
&lt;p>If per-species weighting is used then the value of &amp;ldquo;npart_per_cell&amp;rdquo;
will be the average number of particles per cell. If &amp;ldquo;npart&amp;rdquo; or &amp;ldquo;frac&amp;rdquo;
have also been specified for a species, then they will be ignored.&lt;/p>
&lt;p>To avoid confusion, there is no globally used &amp;ldquo;npart_per_species&amp;rdquo;. If
you want to have a single value to change in the input deck then this
can be achieved using a
&lt;a href="/documentation/input_deck/input_deck_constant">&lt;em>constant&lt;/em>&lt;/a> block.&lt;/p>
&lt;ul>
&lt;li>&lt;code>dumpmask&lt;/code> - Determines which output dumps will include
this particle species. The dumpmask has the same semantics as those used
by variables in the
&lt;a href="/documentation/input_deck/input_deck_output_block">&lt;em>output&lt;/em>&lt;/a>
block. The actual dumpmask from the output block is applied first and
then this one is applied afterwards. For example, if the species block
contains &amp;ldquo;dumpmask = full&amp;rdquo; and the output block contains &amp;ldquo;vx = always&amp;rdquo;
then the particle velocity will be only be dumped at full dumps for this
particle species. The default dumpmask is &amp;ldquo;always&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dump&lt;/code> - This logical flag is provided for backwards
compatibility. If set to &amp;ldquo;F&amp;rdquo; it has the same meaning as &amp;ldquo;dumpmask =
never&amp;rdquo;. If set to &amp;ldquo;T&amp;rdquo; it has the same meaning as &amp;ldquo;dumpmask = always&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>zero_current&lt;/code> - Logical flag switching the particle
species into zero-current particles. Zero-current particles are enabled
if the if the &amp;ldquo;NO_TRACER_PARTICLES&amp;rdquo; precompiler option has not been
used and the &amp;ldquo;zero_current&amp;rdquo; flag is set to true for a given species.
When set, the species will move correctly for its charge and mass, but
contribute no current. This means that these particles are passive
elements in the simulation. In all other respects they are designed to
behave identically to ordinary particles, so they do take part in
collisions by default. This can be prevented using the
&lt;a href="/documentation/input_deck/input_deck_collisions">collision
matrices&lt;/a>.
&lt;span style="color: red; font-weight: bold;">WARNING:&lt;/span> Since the
particles effectively have zero weight in terms of their numerical
heating properties, they do not always behave in the same way that an
ordinary particle with weight would behave and this can sometimes lead
to unexpected behaviour. If the purpose is merely to track a subset of a
particle species to use as output then a better mechanism to use is
&amp;ldquo;persistent subsets&amp;rdquo; (see
&lt;a href="/documentation/input_deck/input_deck_subset">here&lt;/a>).
&amp;ldquo;tracer&amp;rdquo; is currently accepted as an alias but this will be removed in
version 5.0. &amp;ldquo;zero_current = F&amp;rdquo; is the default value.&lt;/li>
&lt;li>&lt;code>identify&lt;/code> - Used to identify the type of particle.
Currently this is used primarily by the QED routines. See
&lt;a href="/documentation/input_deck/input_deck_qed">here&lt;/a> for details.&lt;/li>
&lt;li>&lt;code>immobile&lt;/code> - Logical flag. If this parameter is set to &amp;ldquo;T&amp;rdquo;
then the species will be ignored during the particle push. The default
value is &amp;ldquo;F&amp;rdquo;.
The species blocks are also used for specifying initial conditions for
the particle species. The initial conditions in EPOCH can be specified
in various ways, but the easiest way is to specify the initial
conditions in the input deck file. This allows any initial condition
which can be specified everywhere in space by a number density and a
drifting Maxwellian distribution function. These are built up using the
normal maths expressions, by setting the density and temperature for
each species which is then used by the autoloader to actually position
the particles.&lt;/li>
&lt;/ul>
&lt;p>The elements of the species block used for setting initial conditions
are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>number_density&lt;/code> - Particle number density in $m^{-3}$. As
soon as a number_density= line has been read, the values are calculated
for the whole domain and are available for reuse on the right hand side
of an expression. This is seen in the above example in the first two
lines for the Electron species, where the number density is first set
and then corrected. If you wish to specify the number density in parts
per cubic metre then you can divide by the &amp;ldquo;cc&amp;rdquo; constant (see
&lt;a href="/documentation/code_details/maths_parser/#constants">here&lt;/a>). This parameter is
mandatory. &amp;ldquo;density&amp;rdquo; is accepted as an alias.&lt;/li>
&lt;li>&lt;code>number_density_min&lt;/code> - Minimum particle number density in
$m^{-3}$. When the number density in a cell falls below
number_density_min the autoloader does not load any pseudoparticles
into that cell to minimise the number of low weight, unimportant
particles. If set to 0 then all cells are loaded with particles. This is
the default. &amp;ldquo;density_min&amp;rdquo; is accepted as an alias.&lt;/li>
&lt;li>&lt;code>number_density_max&lt;/code> - Maximum particle number density in
$m^{-3}$. When the number density in a cell rises above
number_density_max the autoloader clips the number_density to
number_density_max allowing easy implementation of exponential rises
to plateaus. If it is a negative value then no clipping is performed.
This is the default. &amp;ldquo;density_max&amp;rdquo; is accepted as an alias.&lt;/li>
&lt;li>&lt;code>mass_density&lt;/code> - Particle mass density in $kg,m^{-3}$.
The same as &amp;ldquo;number_density&amp;rdquo; but multiplied by the particle mass. If
you wish to use units of $g,cm^{-3}$ then append the appropriate
multiplication factor. For example: &amp;ldquo;&lt;code>mass_density = 2 * 1e3 / cc&lt;/code>&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>temp_{x,y,z}&lt;/code> - The temperature in each direction for a
thermal distribution in Kelvin.&lt;/li>
&lt;li>&lt;code>temp&lt;/code> - Sets an isotropic temperature distribution in
Kelvin. If both temp and a specific temp_x, temp_y, temp_z parameter
is specified then the last to appear in the deck has precedence. If
neither are given then the species will have a default temperature of
zero Kelvin.&lt;/li>
&lt;li>&lt;code>temp_{x,y,z}_ev, temp_ev&lt;/code> - These are the same as the
temperature parameters described above except the units are given in
electronvolts rather than Kelvin, i.e. using 1ev = 11604.5K .&lt;/li>
&lt;li>&lt;code>drift_{x,y,z}&lt;/code> - Specifies a momentum space offset in
$kg\ ms^{-1}$ to the distribution function for this species. By default,
the drift is zero.&lt;/li>
&lt;li>&lt;code>offset&lt;/code> - File offset. See below for details.&lt;/li>
&lt;/ul>
&lt;h1 id="loading_data_from_a_file">Loading data from a file&lt;/h1>
&lt;p>It is also possible to set initial conditions for a particle species
using an external file. Instead of specifying the initial conditions
mathematically in the input deck, you specify in quotation marks the
filename of a simple binary file containing the information required.
For more information on what is meant by a &amp;ldquo;simple binary file&amp;rdquo;, see
&lt;a href="/documentation/input_deck/binary_files">here&lt;/a>.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Electron
number_density = 'Data/ic.dat'
offset = 80000
temp_x = 'Data/ic.dat'
end:species
&lt;/code>&lt;/pre>
&lt;p>The sizes of the variables to be filled do not need to be provided: the
code will continue reading until the given variable is filled. Note that
ghost or guard cells should not be included in the file as they cannot
be set this way.&lt;/p>
&lt;p>An additional element is also introduced, the offset element. This is
the offset in bytes from the start of the file to where the data should
be read from. As a given line in the block executes, the file is opened,
the file handle is moved to the point specified by the offset parameter,
the data is read and the file is then closed. Therefore, unless the
offset value is changed between data reading lines the same data will be
read into all the variables. The data is read in as soon as a line is
executed, and so it is perfectly possible to load data from a file and
then modify the data using a mathematical expression.
The example block above is for 10,000 values at double precision, i.e.
8-bytes each. The density data is the first 80,000 bytes of &amp;ldquo;ic.dat&amp;rdquo;.
Bytes 80,000 to 160,000 are the temp_x data.&lt;/p>
&lt;p>The file should be a simple binary file consisting of floating point
numbers of the same precision as &lt;strong>_num&lt;/strong> in the core EPOCH code. For
multidimensional arrays, the data is assumed to be written according to
FORTRAN array ordering rules (i.e. column-major order).
&lt;strong>&lt;code>NOTE: The files that are expected by this block are SIMPLE BINARY files, NOT FORTRAN unformatted files. It is possible to read FORTRAN unformatted files using the offset element, but care must be taken!&lt;/code>&lt;/strong>&lt;/p>
&lt;h1 id="delta_f_parameters">Delta-f parameters&lt;/h1>
&lt;p>The following entries are used for configuring the
&lt;a href="/documentation/code_details/using_delta_f">Delta-f
method&lt;/a>
*number_density_back&lt;/p>
&lt;ul>
&lt;li>drift_{x,y,z}_back&lt;/li>
&lt;li>temp_{x,y,z}_back&lt;/li>
&lt;li>temp_{x,y,z}_back_ev&lt;/li>
&lt;li>temp_back&lt;/li>
&lt;li>temp_back_ev&lt;/li>
&lt;/ul>
&lt;p>These all have the same meanings as the parameters listed above that
don&amp;rsquo;t include the &amp;ldquo;_back&amp;rdquo; text, except that they specify the values to
use for the background distribution function.&lt;/p>
&lt;h1 id="particle_migration_between_species">Particle migration between species&lt;/h1>
&lt;p>It is sometimes useful to separate particle species into separate energy
bands and to migrate particles between species when they become more or
less energetic. A method to achieve this functionality has been
implemented. It is specified using two parameters to the &amp;ldquo;control&amp;rdquo;
block:&lt;/p>
&lt;ul>
&lt;li>&lt;code>use_migration&lt;/code> - Logical flag which determines whether or
not to use particle migration. The default is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>migration_interval&lt;/code> - The number of timesteps between
each migration event. The default is 1 (migrate at every timestep).
The following parameters are added to the &amp;ldquo;species&amp;rdquo; block:&lt;/li>
&lt;li>&lt;code>migrate&lt;/code> - Logical flag which determines whether or not to
consider this species for migration. The default is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>promote_to&lt;/code> - The name of the species to promote
particles to.&lt;/li>
&lt;li>&lt;code>demote_to&lt;/code> - The name of the species to demote particles
to.&lt;/li>
&lt;li>&lt;code>promote_multiplier&lt;/code> - The particle is promoted when its
energy is greater than &amp;ldquo;promote_multiplier&amp;rdquo; times the local average.
The default value is 1.&lt;/li>
&lt;li>&lt;code>demote_multiplier&lt;/code> - The particle is demoted when its
energy is less than &amp;ldquo;demote_multiplier&amp;rdquo; times the local average. The
default value is 1.&lt;/li>
&lt;li>&lt;code>promote_number_density&lt;/code> - The particle is only
considered for promotion when the local number density is less than
&amp;ldquo;promote_number_density&amp;rdquo;. The default value is the largest floating
point number.&lt;/li>
&lt;li>&lt;code>demote_number_density&lt;/code> - The particle is only considered
for demotion when the local number density is greater than
&amp;ldquo;demote_number_density&amp;rdquo;. The default value is 0.&lt;/li>
&lt;/ul>
&lt;h1 id="ionisation">Ionisation&lt;/h1>
&lt;p>EPOCH now includes field ionisation which can be activated by defining
ionisation energies and an electron for the ionising species. This is
done via the species block using the following parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>ionisation_energies&lt;/code> - This is an array of ionisation
energies (in Joules) starting from the outermost shell. It expects to be
given all energies down to the fully ionised ion; if the user wishes to
exclude some inner shell ionisation for some reason they need to give
this a very large number. Note that the ionisation model assumes that
the outermost electron ionises first always, and that the orbitals are
filled assuming ground state. When this parameter is specified it turns
on ionisation modelling. If you wish to specify the values in
Electron-Volts, add the &amp;ldquo;ev&amp;rdquo;
&lt;a href="/documentation/code_details/maths_parser/#constants">multiplication
factor&lt;/a>.&lt;/li>
&lt;li>&lt;code>ionisation_electron_species&lt;/code> - Name of the electron
species. This can be specified as an array in the event that the user
wishes some levels to have a different electron species which can be
handy for monitoring ionisation at specific levels. &amp;ldquo;electron&amp;rdquo; and
&amp;ldquo;electron_species&amp;rdquo; are accepted as synonyms. Either one species for
&lt;em>all&lt;/em> levels, or one species for &lt;em>each&lt;/em> species should be specified.
For example, ionising carbon species might appear in the input deck as:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-perl">begin:species
charge = 0.0
mass = 1837.2
name = carbon
ionisation_energies = (11.26*ev,24.38*ev,47.89*ev,64.49*ev,392.1*ev,490.0*ev)
ionisation_electron_species = \
(electron,electron,electron,fourth,electron,electron)
number_density= den_gas
end:species
begin:species
charge = -1.0
mass = 1.0
name = electron
number_density = 0.0
end:species
begin:species
charge = -1.0
mass = 1.0
name = fourth
number_density = 0.0
end:species
&lt;/code>&lt;/pre>
&lt;p>Ionised states are created automatically and are named according to the
ionising species name with a number appended. For example&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Helium
ionisation_energies = (24.6*ev,54.4*ev)
dump = F
end:species
&lt;/code>&lt;/pre>
&lt;p>With this species block, the species named &amp;ldquo;Helium1&amp;rdquo; and &amp;ldquo;Helium2&amp;rdquo; are
automatically created. These species will also inherit the &amp;ldquo;dump&amp;rdquo;
parameter from their parent species, so in this example they will both
have &amp;ldquo;dump = F&amp;rdquo; set. This behaviour can be overridden by explicitly
adding a species block of the same name with a differing dumpmask. eg.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Helium1
dump = T
end:species
&lt;/code>&lt;/pre>
&lt;p>Field ionisation consists of three distinct regimes; multiphoton in
which ionisation is best described as absorption of multiple photons,
tunnelling in which deformation of the atomic Coulomb potential is the
dominant factor, and barrier suppression ionisation in which the
electric field is strong enough for an electron to escape classically.
It is possible to turn off multiphoton or barrier suppression ionisation
through the input deck using the following control block parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>use_multiphoton&lt;/code> - Logical flag which turns on modelling
ionisation by multiple photon absorption. This should be set to &amp;ldquo;F&amp;rdquo; if
there is no laser attached to a boundary as it relies on laser
frequency. The default is &amp;ldquo;T&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>use_bsi&lt;/code> - Logical flag which turns on barrier
suppression ionisation correction to the tunnelling ionisation model for
high intensity lasers. The default is &amp;ldquo;T&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;h1 id="species_boundary_conditions">Species Boundary Conditions&lt;/h1>
&lt;ul>
&lt;li>&lt;code>bc_x_min&lt;/code> - Boundary condition to be applied to this
species only on the lower x boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_x_max&lt;/code> - Boundary condition to be applied to this
species only on the upper x boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_y_min&lt;/code> - Boundary condition to be applied to this
species only on the lower y boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_y_max&lt;/code> - Boundary condition to be applied to this
species only on the upper y boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_z_min&lt;/code> - Boundary condition to be applied to this
species only on the lower z boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_z_max&lt;/code> - Boundary condition to be applied to this
species only on the upper z boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>meet_injectors&lt;/code> - Logical flag determining whether the
background plasma should be extended to meet the point where
particle injectors operate from. This means that plasma is loaded
one particle shape function length outside the boundary. This means
that it is possible to use an injector to &amp;ldquo;continue&amp;rdquo; an existing
drifting plasma. NOT COMPATIBLE WITH PERIODIC BOUNDARY CONDITIONS!&lt;/li>
&lt;/ul>
&lt;h1 id="maxwell_juttner_distributions">Maxwell Juttner distributions&lt;/h1>
&lt;p>As of version 4.15, EPOCH allows the user to request a Maxwell-JÃ¼ttner
distribution rather than a Maxwellian distribution when sampling the
particle momentum for a species.&lt;/p>
&lt;p>This feature does not at present work with the delta_f loader and is
not available for particle injectors. It does work correctly with the
moving window.&lt;/p>
&lt;ul>
&lt;li>&lt;code>use_maxwell_juttner&lt;/code> - Logical flag determining
whether to sample from the Maxwell-JÃ¼ttner distribution when loading
the particle species. If &amp;ldquo;T&amp;rdquo; then Maxwell-JÃ¼ttner is used and if
&amp;ldquo;F&amp;rdquo; Maxwellian is used. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;!-- -->
&lt;ul>
&lt;li>`fractional_tail_cutoff - The sampling is carried out using a
rejection method with an arbitrary cut-off. This parameter takes a
floating-point argument which specifies the fraction of maximum
value at which the sampling should be cut off. Smaller values lead
to distortion nearer the peak of the distribution but are faster to
sample. Larger values lead to a better approximation of the
distribution function but are slower to sample. The default value is
0.0001.&lt;/li>
&lt;/ul>
&lt;p>If drifts are specified with the Maxwell-JÃ¼ttner distribution then the
distribution is calculated in the rest frame and then Lorentz
transformed to the specified drifting frame.&lt;/p>
&lt;h1 id="arbitrary_distribution_functions">Arbitrary Distribution functions&lt;/h1>
&lt;p>As of version 4.15, EPOCH also allows the user to request an arbitrary
non-Maxwellian distribution function to use when sampling the particle
momentum for a species. If combined with a specified drift then the
distribution function is calculated first and the drift is applied to
the resulting particles by Lorentz transform.&lt;/p>
&lt;p>This feature does not at present work with the delta_f loader and is
not available for particle injectors. It does work correctly with the
moving window.&lt;/p>
&lt;ul>
&lt;li>&lt;code>dist_fn&lt;/code> - Specifies the functional form of the
distribution function, normalised to have a maximum value of 1. The
variables &amp;ldquo;px&amp;rdquo;, &amp;ldquo;py&amp;rdquo; and &amp;ldquo;pz&amp;rdquo; should be used to parameterise
the x, y and z components of momentum. This may freely vary in space
but temporal variation will be ignored since this is only evaluated
at the start of the simulation.&lt;/li>
&lt;/ul>
&lt;!-- -->
&lt;ul>
&lt;li>&lt;code>dist_fn_p{x,y,z}_range&lt;/code> - Comma separated pair of
numbers to specify the range of momentum for p_{x,y,z} in SI units.
Should be of the form &amp;ldquo;&amp;lt;lower_range&amp;gt;, &amp;lt;upper_range&amp;gt;&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>If a range for a momentum direction is not specified then that momentum
is assumed to be zero. It is up to the user to ensure that the range is
large enough to correctly capture their desired distribution function.
Sampling is by a simple rejection sampling and may be much slower than
the existing Maxwellian sampler. EPOCH will print a warning if a large
number of samples are needed to complete the sampling. If this occurs
then you might need to reduce the range of momentum over which sampling
is considered.&lt;/p>
&lt;p>If the &amp;ldquo;dist_fn&amp;rdquo; key is supplied then any supplied temperature keys
are ignored. An example of setting up a truncated power law distribution
in px would be&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
dens = 10
v0 = 0.05 * c
vmax = 0.5 * c
p0 = v0 * me * (1.0 + 4.0 * x/x_max)
pmax = vmax * me
alpha = -2.0
end:constant
begin:species
name = Electron_pl
charge = -1
mass = 1.0
frac = 0.5
number_density = dens
#Truncated power law distribution in px
dist_fn = exp(-p0/px) * (px/p0)^(alpha)
dist_fn_px_range = (0, pmax)
end:species
&lt;/code>&lt;/pre>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>laser block</title><link>/documentation/input_deck/input_deck_laser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_laser/</guid><description>&lt;p>This block contains information about laser boundary sources. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;p>Laser blocks attach an EM wave source to a boundary which is set as
&lt;strong>simple_laser&lt;/strong>.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:laser
boundary = x_min
id = 1
intensity_w_cm2 = 1.0e15
lambda = 1.06 * micron
pol_angle = 0.0
phase = 0.0
t_profile = gauss(time, 40.0e-15, 40.0e-15)
t_start = 0.0
t_end = 80.0e-15
end:laser
&lt;/code>&lt;/pre>
&lt;p>As already mentioned in the discussion of laser boundaries in the
&lt;a href="/documentation/input_deck/input_deck_boundaries">boundaries&lt;/a> block, lasers are
attached to compatible boundaries here in the initial conditions deck.&lt;/p>
&lt;ul>
&lt;li>&lt;code>boundary&lt;/code> - The boundary on which to attach the laser. In
1D, the directions can be either x_min or x_max. &amp;ldquo;left&amp;rdquo; and &amp;ldquo;right&amp;rdquo;
are accepted as a synonyms. In 2D, y_min and y_max may also be
specified. These have synonyms of &amp;ldquo;down&amp;rdquo; and &amp;ldquo;up&amp;rdquo;. Finally, 3D adds
z_min and z_max with synonyms of &amp;ldquo;back&amp;rdquo; and &amp;ldquo;front&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>amp&lt;/code> - The amplitude of the $E$ field of the laser in
$V/m$.&lt;/li>
&lt;li>&lt;code>intensity&lt;/code> - The intensity of the laser in $W/m^2$. There
is no need to specify both intensity and amp and the last specified in
the block is the value used. It is mandatory to specify at least one.
The amplitude of the laser is calculated from intensity using the
formula &lt;code>amp = sqrt(2*intensity/c/epsilon0)&lt;/code>. &amp;ldquo;irradiance&amp;rdquo; is accepted
as a synonym.&lt;/li>
&lt;li>&lt;code>intensity_w_cm2&lt;/code> - This is identical to the
&lt;strong>intensity&lt;/strong> parameter described above, except that the units are
specified in $W/cm^2$.&lt;/li>
&lt;li>&lt;code>id&lt;/code> - An id code for the laser. Used if you specify the
laser time profile in the EPOCH source rather than in the input deck.
Does not have to be unique, but all lasers with the same id will have
the same time profile. This parameter is optional and is not used under
normal conditions.&lt;/li>
&lt;li>&lt;code>omega&lt;/code> - Angular frequency (rad/s not Hz) for the laser.&lt;/li>
&lt;li>&lt;code>frequency&lt;/code> - Ordinary frequency (Hz not rad/s) for the
laser.&lt;/li>
&lt;li>&lt;code>lambda&lt;/code> - Wavelength in a vacuum for the laser specified
in $m$. If you want to specify in $\mu m$ then you can multiply by the
constant &amp;ldquo;micron&amp;rdquo;. One of &lt;strong>lambda&lt;/strong> or &lt;strong>omega&lt;/strong> (or &lt;strong>frequency&lt;/strong>) is
a required parameter.&lt;/li>
&lt;li>&lt;code>pol_angle&lt;/code> - Polarisation angle for the electric field of
the laser in radians. This parameter is optional and has a value of zero
by default. The angle is measured with respect to the right-hand triad
of propagation direction, electric and magnetic fields. Although the 1D
code has no $y$ or $z$ spatial axis, the fields still have $y$ and $z$
components. If the laser is on &lt;strong>x_min&lt;/strong> then the default $E$ field is
in the $y$-direction and the $B$ field is the $z$-direction. The
polarisation angle is measured clockwise about the $x$-axis with zero
along the $E_y$ direction. If the laser is on &lt;strong>x_max&lt;/strong> then the angle
is anti-clockwise.
**Similarly, for propagation directions:
**&lt;em>y_min&lt;/em> - angle about $y$-axis, zero along $z$-axis
**&lt;em>z_min&lt;/em> - angle about $z$-axis, zero along $x$-axis
**&lt;em>y_max&lt;/em> - angle anti-clockwise about $y$-axis, zero along $z$-axis
**&lt;em>z_max&lt;/em> - angle anti-clockwise about $z$-axis, zero along $x$-axis&lt;/li>
&lt;li>&lt;code>pol&lt;/code> - This is identical to &lt;em>pol_angle&lt;/em> with the angle
specified in degrees rather than radians. If both are specified then the
last one is used.&lt;/li>
&lt;li>&lt;code>phase&lt;/code> - The phase profile of the laser wavefront given in
radians. Phase may be a function of both space and time. The laser is
driven using ${\rm{sin}}(\omega t + \phi)$ and &lt;strong>phase&lt;/strong> is the $\phi$
parameter. There is zero phase shift applied by default.&lt;/li>
&lt;li>&lt;code>profile&lt;/code> - The spatial profile of the laser. This should
be a spatial function not including any values in the direction normal
to the boundary on which the laser is attached, and the expression will
be evaluated at the boundary. It may also be time-dependant. The laser
field is multiplied by the profile to give its final amplitude so the
intention is to use a value between zero and one. By default it is a
unit constant and therefore has no affect on the laser amplitude. This
parameter is redundant in 1D and is only included for consistency with
2D and 3D versions of the code.&lt;/li>
&lt;li>&lt;code>t_profile&lt;/code> - Used to specify the time profile for the
laser amplitude. Like &lt;strong>profile&lt;/strong> the laser field is multiplied by this
parameter but it is only a function of time and not space. In a similar
manner to &lt;strong>profile&lt;/strong>, it is best to use a value between zero and one.
Setting values greater than one is possible but will cause the maximum
laser intensity to grow beyond &lt;strong>amp&lt;/strong>. In previous versions of EPOCH,
the &lt;strong>profile&lt;/strong> parameter was only a function of space and this
parameter was used to impose time-dependance. Since &lt;strong>profile&lt;/strong> can now
vary in time, &lt;strong>t_profile&lt;/strong> is no longer needed but it has been kept to
facilitate backwards compatibility. It can also make input decks clearer
if the time dependance is given separately. The default value of
&lt;strong>t_profile&lt;/strong> is just the real constant value of 1.0.&lt;/li>
&lt;li>&lt;code>t_start&lt;/code> - Start time for the laser in seconds. Can be
set to the string &amp;ldquo;start&amp;rdquo; to start at the beginning of the simulation.
This is the default value. When using this parameter, the laser start is
hard. To get a soft start use the &lt;strong>t_profile&lt;/strong> parameter to ramp the
laser up to full strength.&lt;/li>
&lt;li>&lt;code>t_end&lt;/code> - End time for the laser in seconds, can be set to
the string &amp;ldquo;end&amp;rdquo; to end at the end of the simulation. This is the
default value. When using this parameter, the laser end is clipped
straight to zero at $t &amp;gt; t_end$. To get a soft end use the
&lt;strong>t_profile&lt;/strong> parameter to ramp the laser down to zero.
If you add multiple laser blocks to the initial conditions file then the
multiple lasers will be additively combined on the boundary.&lt;/li>
&lt;/ul>
&lt;p>In theory, any laser time profile required is possible, but the core
FDTD solver for the EM fields in EPOCH produces spurious results if
sudden changes in the field intensity occur. This is shown below. The
pulse shown on the left used a constant &lt;em>t_profile&lt;/em> and used &lt;em>t_end&lt;/em>
to stop the laser after 8fs. Since the stopping time was not an exact
multiple of the period, the result was to introduce spurious
oscillations behind the pulse. If the laser had a finite phase shift so
that the amplitude did not start at zero, a similar effect would be
observed on the front of the pulse.&lt;/p>
&lt;p>&lt;img src="../Pulse2.png" alt="A laser pulse with a sharp cutoff shows numerical artefacts behind thepulse.">&lt;/p>
&lt;p>&lt;img src="../Pulse1.png" alt="A laser pulse with a smooth temporal profile shows noartefacts.">&lt;/p>
&lt;p>The second figure instead used a Gaussian window function with a
characteristic width of 8fs as well as using &lt;em>t_end&lt;/em> to introduce a
hard cutoff. It can clearly be seen that there are no spurious
oscillations and the wave packet propagates correctly, showing only some
dispersive features.&lt;/p>
&lt;p>There is no hard and fast rule as to how rapid the rise or fall for a
laser can be, and the best advice is to simply test the problem and see
whether any problems occur. If they do then there are various solutions.
Essentially, the timestep must be reduced to the point where the sharp
change in amplitude can be accommodated. The best solution for this is
to increase the spatial resolution (with a comparable increase in the
number of pseudoparticles), thus causing the timestep to drop via the
CFL condition.&lt;/p>
&lt;p>This is computationally expensive, and so a cheaper option is simply to
decrease the input.deck option &lt;em>dt_multiplier&lt;/em>. This artificially
decreases the timestep below the timestep calculated from the internal
stability criteria and allows the resolution of sharp temporal
gradients. This is an inferior solution since the FDTD scheme has
increased error as the timestep is reduced from that for EM waves. EPOCH
includes a high order field solver to attempt to reduce this.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>fields block</title><link>/documentation/input_deck/input_deck_fields/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_fields/</guid><description>&lt;p>This block contains information about the EM fields specified at the
start of the simulation. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input
deck&lt;/a> for more information on the input
deck.&lt;/p>
&lt;p>This block allows you to specify the electric and magnetic fields at any
point in the domain. An example block is shown below:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:fields
ex = sin(pi * x / length_x)
ey = cos(pi * x / length_x)
ez = 0
bx = 1.0
by = -1.0
bz = 0
end:fields
&lt;/code>&lt;/pre>
&lt;p>Once again, this is a very simple block needing only limited
explanation. All field variables are accessible by name and can be read
back using the appropriate commands from the maths parser (see
&lt;a href="/documentation/code_details/maths_parser/#constants">here&lt;/a>). The possible
parameters are as follows:&lt;/p>
&lt;ul>
&lt;li>&lt;code>ex,ey,ez&lt;/code> - The electric field vectors pointing in all
three directions. The default value is zero.&lt;/li>
&lt;li>&lt;code>bx,by,bz&lt;/code> - The magnetic field vectors pointing in all
three directions. The default value is zero.&lt;/li>
&lt;li>&lt;code>offset&lt;/code> - File offset. The field values may also be
specified using a binary file in a similar way to that used for species
variables. See
&lt;a href="/documentation/input_deck/input_deck_species">the species block&lt;/a>
for more details.
Any valid maths parser expression can be used to set up the fields, and
no check is made to ensure that the $\nabla.B = 0$ is satisfied.&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>window block</title><link>/documentation/input_deck/input_deck_window/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_window/</guid><description>&lt;p>This block contains information about the moving window if the code is
used in that fashion. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input
deck&lt;/a> for more information on the input
deck.&lt;/p>
&lt;p>EPOCH can include an optional block which causes the simulation domain
to operate as a moving window. At present, it is only possible to have
the window moving at a speed parallel to the x direction, although the
window does not have to start moving at t = 0. When the window moves,
the code removes particles from the left hand edge of the domain and
introduces new particles at the right hand edge. The new particles are
placed by re-evaluating the species density, temperature and drift using
the new time and spatial coordinates. The block looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:window
move_window = T
window_v_x = 3.0e8
window_start_time = 7.0e-13
bc_x_min_after_move = simple_outflow
bc_x_max_after_move = simple_outflow
end:window
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>move_window&lt;/code> - Logical flag determining whether or not
to move the window. If the window block is absent then this is the
same as setting move_window to &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>window_v_x&lt;/code> - The speed in m/s of the window.&lt;/li>
&lt;li>&lt;code>window_start_time&lt;/code> - The time in seconds at which the
window should start moving.&lt;/li>
&lt;/ul>
&lt;p>- The time in seconds at which the window should stop moving.&lt;/p>
&lt;ul>
&lt;li>&lt;code>bc_x_min_after_move&lt;/code> - The boundary condition which
should apply to the left boundary after the window has started moving.
This is to allow the swapping of a laser boundary to a simple outflow
boundary. Boundary codes are the same as when just specifying normal
boundaries. If a boundary value isn&amp;rsquo;t specified then it is assumed that
the boundary isn&amp;rsquo;t changed when the window starts moving.
&amp;ldquo;xbc_left_after_move&amp;rdquo; is accepted as a synonym.&lt;/li>
&lt;li>&lt;code>bc_x_max_after_move&lt;/code> - The boundary condition which
should apply to the right boundary after the window has started moving.
&amp;ldquo;xbc_right_after_move&amp;rdquo; is accepted as a synonym. - &amp;ldquo;y&amp;rdquo; and &amp;ldquo;z&amp;rdquo;
versions of the previous two parameters. &lt;strong>ybc_down_after_move&lt;/strong>,
&lt;strong>ybc_up_after_move&lt;/strong>, &lt;strong>zbc_back_after_move&lt;/strong> and
&lt;strong>zbc_front_after_move&lt;/strong> are accepted as synonyms.&lt;/li>
&lt;/ul>
&lt;h1 id="compatibility">Compatibility&lt;/h1>
&lt;p>Because of how the moving window must work, there are some compatibility
issues with certain features. In particular:&lt;/p>
&lt;ul>
&lt;li>lasers attached to an X boundary which remain in place after the
window moves, or attached to Y or Z boundaries:
&lt;ul>
&lt;li>The laser will behave as though it is attached to the window
itself: for Y or Z boundaries with spatial variations this may
not give the expected result&lt;/li>
&lt;li>For X boundaries, the moving emitter will result in a form of
numerical Doppler shifting. In addition to this the boundary
used to drive the field will shift discontinuously, yielding
noisy and erratic changes in the electromagnetic field.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Injectors attached to an X boundary will not work. Those on a Y or Z
boundary may appear to work, but the rates will be incorrect.&lt;/li>
&lt;li>CPML boundary conditions:
&lt;ul>
&lt;li>in X these cannot work as they rely on time-history which is
simply missing.&lt;/li>
&lt;li>On Y or Z boundaries they will approximately work, but the
history will be truncated and so they will generally require
more tuning. We can&amp;rsquo;t help with this in general.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Load of particles from file is not supported since it can&amp;rsquo;t be made
to work in general.&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>output block</title><link>/documentation/input_deck/input_deck_output_block/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_output_block/</guid><description>&lt;p>This block contains information about when and how to dump output files.
See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more information
on the input deck.&lt;/p>
&lt;h1 id="basics">Basics&lt;/h1>
&lt;p>Output in EPOCH is handled using the custom designed SDF file format
(&lt;em>Self Describing Format&lt;/em>). A detailed specification of this format is
available elsewhere, although this is only of interest to developers
wishing to write new libraries. EPOCH comes with readers for ITT IDL,
LLNL VisIt, Mathworks MatLab and Python. The IDL reader is also
compatible with the open source GDL tool.&lt;/p>
&lt;p>There are two styles of output block supported by EPOCH. The first
style, which will be referred to as the &amp;ldquo;traditional&amp;rdquo; style, is the
method that has been supported by EPOCH since its inception. With this
method, a single output block governs all the output dumps which are to
be performed. There are a few levels of output which give some small
amount of flexibility over what gets dumped but these do not allow for a
very fine-grained control.&lt;/p>
&lt;p>In version 4.0 of EPOCH, a new style was introduced in which multiple
named output blocks may be specified allowing for much greater
flexibility. The existence of a &amp;ldquo;name&amp;rdquo; parameter is what determines that
an output block is the new style rather than the traditional style.&lt;/p>
&lt;p>Most of the parameters are shared by both styles. The following sections
document the traditional style of output block and any differences
between the two styles are described
&lt;a href="#multiple_output_blocks">below&lt;/a> .&lt;/p>
&lt;p>What the code should output and when it should output it is specified in
the &amp;ldquo;output&amp;rdquo; block of the input deck. An example output block is shown
below:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
# If use_offset_grid is true then the code dumps a grid which
# displays positions relative to the left hand edge of the window
use_offset_grid = F
# number of timesteps between output dumps
dt_snapshot = 1.0e-14
# Number of dt_snapshot between full dumps
full_dump_every = 10
restart_dump_every = -1
force_final_to_be_restartable = T
# Properties at particle positions
particles = never
px = never
py = never
pz = never
vx = never
vy = never
vz = never
charge = never
mass = never
particle_weight = never
# Properties on grid
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
jx = always
jy = always
ekbar = always + species
mass_density = never + species
charge_density = always
number_density = always + species
temperature = always + species
distribution_functions = always
particle_probes = never
end:output
&lt;/code>&lt;/pre>
&lt;p>There are three types of output dump in EPOCH which are used for
different purposes. These types are:&lt;/p>
&lt;ul>
&lt;li>normal - The most frequent type of output dump in EPOCH is a normal
dump.&lt;/li>
&lt;li>full - A full dump is usually written every 10 or so normal dumps. A
full dump contains all the data that a normal dump contains and
should also contain any information which is needed only
infrequently, whether this is the full particle information or a
large distribution function. It is possible to turn off full dumps
completely.&lt;/li>
&lt;li>restart - A restart dump is a dump where the code guarantees to
write enough data to allow the code to restart from the output.
Output dumps are guaranteed to contain all the information in a
normal dump and, if they coincide with the timing for a full dump,
will also contain the full dump information.&lt;/li>
&lt;/ul>
&lt;p>Information will never be written into a file twice, even if two
conditions for it being written are satisfied (i.e even if px should be
dumped both because it is a full dump and a restart dump, px will only
be written once).&lt;/p>
&lt;p>Note that these dump levels only really make sense for the traditional
style of output block and are not really required when the new style is
used.&lt;/p>
&lt;h1 id="dumpmask">Dumpmask&lt;/h1>
&lt;p>When specifying which type of output dump to write a variable to there
are eight options which can be specified for each variable and can be
combined by addition. Some combinations make no sense but are formally
valid. The first four options specify at which output types the variable
is to be dumped:&lt;/p>
&lt;ul>
&lt;li>&lt;code>never&lt;/code> - If the variable is not a required restart
variable then it will never be written. If it is a required restart
variable then it will be written only at restart dumps.&lt;/li>
&lt;li>&lt;code>full&lt;/code> - This variable will be written at full dumps only.&lt;/li>
&lt;li>&lt;code>always&lt;/code> - This variable will be written at full, normal
and restart dumps.&lt;/li>
&lt;li>&lt;code>restart&lt;/code> - This variable will be written at restart dumps
only. Note that variables required for restarting the code are always
written to restart dumps. This flag is to enable the writing of
additional variables into such dump files.
For grid variables derived from summing over particles (ie. &amp;ldquo;ekbar&amp;rdquo;,
&amp;ldquo;mass_density&amp;rdquo;, &amp;ldquo;charge_density&amp;rdquo;, &amp;ldquo;number_density&amp;rdquo;, &amp;ldquo;temperature&amp;rdquo;)
the following two parameters also apply.&lt;/li>
&lt;li>&lt;code>species&lt;/code> - The derived variable should be output on a
species by species basis. It is combined with a dumpmask code by
addition as in:
&lt;strong>charge_density = always + species&lt;/strong> .&lt;/li>
&lt;li>&lt;code>no_sum&lt;/code> - The output for this derived variable should not
be summed over all species. By default, derived variables are summed
over all species. If you don&amp;rsquo;t want to include this sum, you must use
the &amp;ldquo;no_sum&amp;rdquo; flag. It is combined with a dumpmask code by addition as
in:
&lt;strong>charge_density = always + species + no_sum&lt;/strong> .
Most grid variables may be averaged over time. A more detailed
description of this is given in
&lt;a href="#data_averaging">#Data
Averaging&lt;/a>. Data averaging is specified
using the following dumpmask parameters.&lt;/li>
&lt;li>&lt;code>average&lt;/code> - The output for this variable should be averaged
over time. The time span over which the variable will be averaged is
controlled using flags described
&lt;a href="#directives">below&lt;/a>.&lt;/li>
&lt;li>&lt;code>snapshot&lt;/code> - By default, the &amp;ldquo;average&amp;rdquo; parameter replaces
the variable with an averaged version of the data. Adding this flag
specifies that the non-averaged variable should also be dumped to file.
When applied to a variable, these codes are referred to as a &lt;em>dumpmask&lt;/em>.&lt;/li>
&lt;/ul>
&lt;h1 id="directives">Directives&lt;/h1>
&lt;p>The first set of options control the type and frequency of output dumps.
They are used as follows&lt;/p>
&lt;ul>
&lt;li>&lt;code>disabled&lt;/code> - Logical flag. If this is set to &amp;ldquo;T&amp;rdquo; then the
block is ignored and never generates any output. The default value is
&amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dt_snapshot&lt;/code> - Sets the interval between normal output
dumps in simulation seconds. Setting zero or negative means that the
code will not output based on this condition. The code does NOT
guarantee that outputs will be exactly &lt;em>dt_snapshot&lt;/em> apart, what is
guaranteed is that the next output will be after the first iteration
which takes the simulation to a time $\ge$ &lt;em>dt_snapshot&lt;/em> from the last
output. As with other variables which specify a unit of time, it can be
specified in more convenient unit by using a multiplication factor (see
&lt;a href="/documentation/code_details/maths_parser/#constants">here&lt;/a>). For example,
&amp;ldquo;dt_snapshot = 5 * femto&amp;rdquo; will set it to be 5 femtoseconds. The
default value is a large number which will never trigger an output.&lt;/li>
&lt;li>&lt;code>nstep_snapshot&lt;/code> - Sets the number of timesteps between
normal output dumps. Setting zero or negative means that the code will
not output based on this condition. If &lt;em>dt_snapshot&lt;/em> is also specified
then both conditions are considered and output will be generated when
either condition is met. The default value is a large integer which will
never trigger an output.&lt;/li>
&lt;li>&lt;code>full_dump_every&lt;/code> - The number of normal output dumps
between full output dumps. Setting to zero makes every dump a full dump.
Setting to a negative number stops the code from producing any full
dumps. This is the default.&lt;/li>
&lt;li>&lt;code>restart_dump_every&lt;/code> - The number of normal output dumps
between restart dumps. Setting to zero makes every dump a restart dump.
Setting to a negative number stops the code from producing any restart
dumps. This is the default.&lt;/li>
&lt;li>&lt;code>force_first_to_be_restartable&lt;/code> - Logical flag which
determines whether the file written at time zero is a restart dump. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>force_last_to_be_restartable&lt;/code> - Force the code to
override other output settings and make the last output dump it writes
be a restart dump. Any internal condition which causes the code to
terminate will make the code write a restart dump, but code crashes or
scheduler terminations will not cause the code to write a restart dump.
&amp;ldquo;force_final_to_be_restartable&amp;rdquo; is accepted as a synonym. The
default value is &amp;ldquo;T&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dump_first&lt;/code> - Logical flag which determines whether to
write an output file immediately after initialising the simulation. The
default is &amp;ldquo;T&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dump_last&lt;/code> - Logical flag which determines whether to
write an output file just before ending the simulation. The default is
&amp;ldquo;T&amp;rdquo; if an output block exists in the input deck and &amp;ldquo;F&amp;rdquo; otherwise.
&amp;ldquo;dump_final&amp;rdquo; is accepted as a synonym.&lt;/li>
&lt;li>&lt;code>time_start&lt;/code> - Floating point parameter which specifies
the simulation time at which to start considering output for the block.
Note that if &amp;ldquo;dump_first&amp;rdquo; or &amp;ldquo;dump_last&amp;rdquo; are set to true for this
block then dumps will occur at the first or last timestep regardless of
the value of the &lt;em>time_start&lt;/em> parameter. This also applies to the three
following parameters. The default value is 0.&lt;/li>
&lt;li>&lt;code>time_stop&lt;/code> - Floating point parameter which specifies the
simulation time at which to stop considering output for the block. The
default value is the largest possible float.&lt;/li>
&lt;li>&lt;code>nstep_start&lt;/code> - Integer parameter which specifies the step
number at which to start considering output for the block. The default
value is 0.&lt;/li>
&lt;li>&lt;code>nstep_stop&lt;/code> - Integer parameter which specifies the step
number at which to stop considering output for the block. The default
value is the largest possible integer.&lt;/li>
&lt;li>Floating point parameter which specifies the elapsed walltime in
seconds at which to start considering output for the block. Note that if
&lt;strong>dump_first&lt;/strong> or &lt;strong>dump_last&lt;/strong> are set to true for this block then
dumps will occur at the first or last timestep regardless of the value
of the &lt;strong>walltime_start&lt;/strong> parameter. The default value is 0.&lt;/li>
&lt;li>Floating point parameter which specifies the elapsed walltime in
seconds at which to stop considering output for the block. The default
value is the largest possible float.&lt;/li>
&lt;li>&lt;code>dump_cycle&lt;/code> - If this is set to a positive integer then
the output file number will be reset to zero after the specified cycle
number is reached. eg. if &amp;ldquo;dump_cycle = 2&amp;rdquo; then the sequence of output
dumps will be 0000.sdf, 0001.sdf, 0002.sdf, 0000.sdf, 0001.sdf, etc. The
default is 0, so dump cycling never occurs.&lt;/li>
&lt;li>&lt;code>dump_cycle_first_index&lt;/code> - If this is set to a positive
integer then the value is used as the first index to use when cycling
output dumps due to the &amp;ldquo;dump_cycle&amp;rdquo; parameter. For example, if
&amp;ldquo;dump_cycle = 2&amp;rdquo; and &amp;ldquo;dump_cycle_first_index = 1&amp;rdquo; then the sequence
of output dumps will be 0000.sdf, 0001.sdf, 0002.sdf, 0001.sdf,
0002.sdf, 0001.sdf, etc. The default is 0.&lt;/li>
&lt;li>&lt;code>dump_source_code&lt;/code> - EPOCH has the ability to write its
own source code into restart dumps. This is generated at compile time
and embedded into the binary and so is guaranteed to match that
corresponding to the running code. EPOCH comes with a script called
&lt;em>unpack_source_from_restart&lt;/em> which can be used to unpack the source
code from a restart dump. To use this script, just type
&lt;strong>unpack_source_from_restart &amp;lt;sdf_filename&amp;gt;&lt;/strong> at the command-line. If
this logical flag is set to false then the feature will be disabled. The
default value is &amp;ldquo;T&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dump_input_decks&lt;/code> - If this logical flag is set to true
then a copy of the input decks for the currently running simulation is
written into the restart dumps. The default value is &amp;ldquo;T&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dt_average&lt;/code> - When averaged variables are being output to
file, this parameter specifies the simulation time period over which
averaging is to occur. &amp;ldquo;averaging_period&amp;rdquo; is accepted as a synonym.&lt;/li>
&lt;li>&lt;code>nstep_average&lt;/code> - When averaged variables are being output
to file, this parameter specifies the number of time steps over which
averaging is to occur. &amp;ldquo;min_cycles_per_average&amp;rdquo; is accepted as a
synonym. If both &lt;em>dt_average&lt;/em> and &lt;em>nstep_average&lt;/em> are specified, the
code will use the one which gives the longest simulation time-span.&lt;/li>
&lt;li>&lt;code>use_offset_grid&lt;/code> - When using moving windows some
visualisation programs (notably VisIt) show the motion of the window by
moving the visualisation window rather than by changing the x-axis.
Setting this option to &amp;ldquo;T&amp;rdquo; causes the code to write another grid which
always gives the offset relative to the left hand edge of the window
rather than the true origin. Performs no function when not using the
moving window. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>filesystem&lt;/code> - String parameter. Some filesystems can be
unreliable when performing parallel I/O. Often this is fixable by
prefixing the filename with &amp;lsquo;ufs&amp;rsquo; or &amp;lsquo;nfs&amp;rsquo;. This parameter supplies the
prefix to be used. The default value is an empty string.&lt;/li>
&lt;li>&lt;code>file_prefix&lt;/code> - Although this parameter is supported by
the traditional style of output block, its primary purpose is for use
with multiple output blocks so it is documented in .
A few additional parameters have been added for use with the new style
of output block. These are documented
&lt;a href="#multiple_output_blocks">below&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h1 id="particle_variables">Particle Variables&lt;/h1>
&lt;p>The next set are per particle properties. If you wish to plot these
according to their spatial positions, you must include the
&amp;ldquo;particle_grid&amp;rdquo; in your output variables. All entries have a default
dumpmask of &amp;ldquo;never&amp;rdquo;.&lt;/p>
&lt;ul>
&lt;li>&lt;code>particle_grid&lt;/code> - Requests the output of particle
positions. This is a restart variable. No particle variables can be
plotted in VisIt unless this is dumped. If any particle variables are
written then the &amp;ldquo;particle_grid&amp;rdquo; is automatically written unless
&amp;ldquo;particle_grid = never&amp;rdquo; is specified. The synonym &amp;ldquo;particles&amp;rdquo; may also
be used.&lt;/li>
&lt;li>&lt;code>px,py,pz&lt;/code> - The dumpmasks for the particle momenta.
Restart variable.&lt;/li>
&lt;li>&lt;code>vx,vy,vz&lt;/code> - The dumpmasks for the particle velocities.&lt;/li>
&lt;li>&lt;code>charge&lt;/code> - The dumpmask for the charge of a given particle.
This has no effect if the code is not compiled with the flag
&amp;ldquo;-DPER_PARTICLE_CHARGE_MASS&amp;rdquo; (see
&lt;a href="/documentation/basic_usage/compiler_flags">here&lt;/a> ).&lt;/li>
&lt;li>&lt;code>mass&lt;/code> - The dumpmask for the mass of a given particles.
This has no effect if the code is not compiled with the flag
&amp;ldquo;-DPER_PARTICLE_CHARGE_MASS&amp;rdquo; (see
&lt;a href="/documentation/basic_usage/compiler_flags">here&lt;/a>). The synonym
&amp;ldquo;rest_mass&amp;rdquo; may also be used.&lt;/li>
&lt;li>&lt;code>particle_weight&lt;/code> - The dumpmask for the weighting
function which describes how many real particles each pseudoparticle
represents. Restart variable. The synonym &amp;ldquo;weight&amp;rdquo; may also be used.&lt;/li>
&lt;li>&lt;code>ejected_particles&lt;/code> - If requested then all the particles
which have left the simulation domain since the last output dump of this
type are included in the output. The list of ejected particles is
treated as if it were a separate species and the particle variables
which get written are requested using the other particle variable flags
(ie. &amp;ldquo;particle_grid&amp;rdquo;, etc). Once the data has been written, the ejected
particle lists are reset and will accumulate particles until the next
requested output dump.&lt;/li>
&lt;li>&lt;code>particle_energy&lt;/code> - The dumpmask for per-particle kinetic
energy.&lt;/li>
&lt;li>&lt;code>relativistic_mass&lt;/code> - The dumpmask for per-particle
relativistic mass (ie. not rest mass).&lt;/li>
&lt;li>&lt;code>gamma&lt;/code> - The dumpmask for per-particle relativistic gamma
(ie. $[1-(v/c)^2]^{-1/2}$).&lt;/li>
&lt;li>&lt;code>optical_depth&lt;/code> - The dumpmask for per-particle optical
depth. Restart variable. This option is only supplied for debugging
purposes and should not be required by most users.&lt;/li>
&lt;li>&lt;code>trident_optical_depth&lt;/code> - The dumpmask for per-particle
optical depth used by the Trident model. Restart variable. This option
is only supplied for debugging purposes and should not be required by
most users.&lt;/li>
&lt;li>&lt;code>qed_energy&lt;/code> - The dumpmask for per-particle QED-related
particle energy. Restart variable. This option is only supplied for
debugging purposes and should not be required by most users.&lt;/li>
&lt;li>The dumpmask for the work exerted by the fields on each particle
during the last time step. The work is divided into its three spatial
components. The output is in numbers of $mc^2$ corresponding to the
particle&amp;rsquo;s $\gamma$-factor. Requires compiler flag
&amp;ldquo;WORK_DONE_INTEGRATED&amp;rdquo;.&lt;/li>
&lt;li>Same as above, but the work is integrated over the entire simulation
duration. The sum of all three components equals the particle&amp;rsquo;s
$\gamma$-factor. Requires compiler flag &amp;ldquo;WORK_DONE_INTEGRATED&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>id&lt;/code> - Global particle ID. See below for details.
Particle IDs are useful if you want to track the progress of each
particle throughout the simulation. Since they increase the size of each
particle data structure, they are disabled by default and must be
enabled using a compiler flag. The &amp;ldquo;PARTICLE_ID&amp;rdquo; flag will use an
8-byte integer to represent the ID and &amp;ldquo;PARTICLE_ID4&amp;rdquo; uses a 4-byte
integer. They are written to file using the &amp;ldquo;id&amp;rdquo; flag.&lt;/li>
&lt;/ul>
&lt;p>Note: In the current implementation, the particle IDs are passed between
processors and written to file using REAL numbers. This means that in
double precision the maximum particle ID is $2^{53} \sim 10^{16}$. This
should be ample for the foreseeable future. However, if the code is
compiled for single precision then the maximum ID is
$2^{24} = 16777216$. Probably not big enough.&lt;/p>
&lt;h1 id="grid_variables">Grid Variables&lt;/h1>
&lt;p>The next set of parameters specify properties which are defined on a
regular cartesian mesh. All entries have a default dumpmask of &amp;ldquo;never&amp;rdquo;.&lt;/p>
&lt;ul>
&lt;li>&lt;code>grid&lt;/code> - The dumpmask for the Cartesian grid which defines
the locations of the grid variables. No grid variables can be plotted in
VisIt unless this variable is output. If any grid variables are written
then the &amp;ldquo;grid&amp;rdquo; is automatically written unless &amp;ldquo;grid = never&amp;rdquo; is
specified. The synonym &amp;ldquo;field_grid&amp;rdquo; may also be used.&lt;/li>
&lt;li>&lt;code>ex,ey,ez&lt;/code> - The electric field vectors pointing in all
three directions. Restart variables.&lt;/li>
&lt;li>&lt;code>bx,by,bz&lt;/code> - The magnetic field vectors pointing in all
three directions. Restart variables. In 1D bx is a trivial variable
because of the Solenoidal condition. It is included simply for symmetry
with higher dimension codes.&lt;/li>
&lt;li>&lt;code>jx,jy,jz&lt;/code> - The current densities pointing in all three
directions. Restart variables. Can have species dumpmask.&lt;/li>
&lt;/ul>
&lt;h1 id="derived_variables">Derived Variables&lt;/h1>
&lt;p>The final set of parameters specify properties which are not variables
used in the code but are derived from them. The first six variables are
derived by summing properties of all the particles in each grid cell.
The resulting quantities are defined on the regular cartesian mesh used
for grid variables. All entries have a default dumpmask of &amp;ldquo;never&amp;rdquo;.&lt;/p>
&lt;ul>
&lt;li>&lt;code>ekbar&lt;/code> - Mean kinetic energy on grid in $J$. Can have
species dumpmask.&lt;/li>
&lt;li>&lt;code>ekflux&lt;/code> - Mean kinetic energy flux in each direction on
the grid in $W/m^2$. Can have species dumpmask.&lt;/li>
&lt;li>&lt;code>mass_density&lt;/code> - Mass density on grid in $kg/m^3$. Can
have species dumpmask.&lt;/li>
&lt;li>&lt;code>charge_density&lt;/code> - Charge density on grid in $C/m^3$. Can
have species dumpmask.&lt;/li>
&lt;li>&lt;code>number_density&lt;/code> - Number density on grid in $m^{-3}$. Can
have species dumpmask.&lt;/li>
&lt;li>&lt;code>particles per cell&lt;/code> - Number of particles per cell. Can
have species dumpmask. The synonym &amp;ldquo;ppc&amp;rdquo; may also be used.&lt;/li>
&lt;li>&lt;code>average weight&lt;/code> - Average of weight of the particles in
each cell. Can have species dumpmask.&lt;/li>
&lt;li>&lt;code>temperature&lt;/code> - Isotropic temperature on grid in $K$.
Calculated from standard deviation of particle momenta, so in general
matches mean kinetic energy only for isotropic plasma with no net drift.
The synonym &amp;ldquo;temp&amp;rdquo; may also be used. Can have species dump mask.
-The temperature in each of the {x,y,z} directions, respectively, in
$K$. The synonyms &amp;ldquo;temp_{x,y,z}&amp;rdquo; and &amp;ldquo;t{x,y,z}&amp;rdquo; may also be used.
Can have species dumpmask.&lt;/li>
&lt;li>&lt;code>poynt_flux&lt;/code> - Poynting flux in each direction in
$W/m^2$.&lt;/li>
&lt;/ul>
&lt;h1 id="other_variables">Other Variables&lt;/h1>
&lt;ul>
&lt;li>&lt;code>distribution_functions&lt;/code> - Dumpmask for outputting
distribution functions specified in the input deck. Each individual
distribution function can have its own dumpmask and these will be
applied after the value of &amp;ldquo;distribution_functions&amp;rdquo; has been
considered. For example, if the output block contains
&amp;ldquo;distribution_functions = full&amp;rdquo; and the dist_fn block (see
&lt;a href="/documentation/input_deck/input_deck_dist_fn">here&lt;/a>)
contains &amp;ldquo;dumpmask = always&amp;rdquo; then the distribution function will
only be output at full dumps.&lt;/li>
&lt;li>&lt;code>particle_probes&lt;/code> - Dumpmask for outputting particle
probes specified in the input deck. Each individual particle probe
can have its own dumpmask and these will be applied after the value
of &amp;ldquo;particle_probes&amp;rdquo; has been considered. For example, if the
output block contains &amp;ldquo;particle_probes = always&amp;rdquo; and the dist_fn
block contains &amp;ldquo;dumpmask = full&amp;rdquo; then the particle probe will only
be output at full dumps.&lt;/li>
&lt;li>&lt;code>absorption&lt;/code> - This is a two-valued output variable. It
accepts a dumpmask in the same manner as other output variables.
When selected, two numbers will be calculated and written to file:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>&amp;ldquo;Absorption/Laser_enTotal&amp;rdquo; - The total amount of energy injected
into the simulation by laser boundaries.&lt;/li>
&lt;li>&amp;ldquo;Absorption/Abs_frac&amp;rdquo; - The fraction of the total laser energy
being absorbed by the open boundaries.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>total_energy_sum&lt;/code> - This is also a two-valued output
variable. It accepts a dumpmask in the same manner as other output
variables. When selected, the following two numbers will be
calculated and written to file:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>&amp;ldquo;Total Particle Energy in Simulation (J)&amp;rdquo;&lt;/li>
&lt;li>&amp;ldquo;Total Field Energy in Simulation (J)&amp;rdquo;&lt;/li>
&lt;/ol>
&lt;h1 id="data_averaging">Data Averaging&lt;/h1>
&lt;p>EPOCH can accumulate an average value for field variables to be written
to output dumps. These may be requested by using the &amp;ldquo;average&amp;rdquo; keyword
when specifying a dump variable. The non-averaged variable will still be
written to restart dumps where required for restarting the code but not
full or normal dumps. If you also want the non-averaged variable to be
written then you can add the &amp;ldquo;snapshot&amp;rdquo; option.&lt;/p>
&lt;p>The period of time over which averaging occurs can be specified using
the &amp;ldquo;dt_average&amp;rdquo; keyword. Alternatively, you may specify the number of
cycles over which to perform the averaging using the &amp;ldquo;nstep_average&amp;rdquo;
keyword. If both &amp;ldquo;dt_average&amp;rdquo; and &amp;ldquo;nstep_average&amp;rdquo; are specified then
the averaging will be performed over the longest of the two intervals.&lt;/p>
&lt;p>Note that previous versions of the code would alter the time step to
ensure that there were enough cycles between output dumps to satisfy the
&amp;ldquo;nstep_average&amp;rdquo; parameter. However, since it affects the accuracy of
the result, this is no longer the case and only a warning message is
issued.&lt;/p>
&lt;p>The following shows an example use of averaging in the output block.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
dt_snapshot = 1.0e-15
full_dump_every = 10
dt_average = 1.0e-17
charge_density = always + average + snapshot
mass_density = full + average + snapshot
ekbar = full + average
end:output
&lt;/code>&lt;/pre>
&lt;p>With this configuration, &amp;ldquo;charge_density&amp;rdquo; will be written in both
normal and averaged form at normal, full and restart dumps.
&amp;ldquo;mass_density&amp;rdquo; will be written in both forms at full dumps. Only the
average value of &amp;ldquo;ekbar&amp;rdquo; will be written at full dumps.&lt;/p>
&lt;p>Only field and derived variables can be averaged currently in EPOCH.
Particle properties, distribution functions and particle probes cannot
currently be averaged.&lt;/p>
&lt;h1 id="single_precision_output">Single-precision output&lt;/h1>
&lt;p>By default, EPOCH is compiled and run using double precision arithmetic.
This is the only method which has been fully tested and the method that
we recommend to other users of the code. However, this also means that
data files can get very large.&lt;/p>
&lt;p>To avoid this problem, it is possible to run the code in double
precision but convert the data to single precision when writing to disk.
This is done by adding the &amp;ldquo;single&amp;rdquo; field the the dumpmask of an output
variable. It can be specified on a per-variable basis.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
dt_snapshot = 8 * femto
grid = always
ex = always
ey = always + single
end:output
&lt;/code>&lt;/pre>
&lt;p>In this example, the grid variable &amp;ldquo;ex&amp;rdquo; will be written as a double
precision array and &amp;ldquo;ey&amp;rdquo; will be converted to single precision.&lt;/p>
&lt;p>Dumping variable averages adds an extra field variable for each average
requested. These take up memory during runtime but do not influence the
simulation behaviour in any way. For this reason, if the average is to
be written out in single precision then it may as well be stored in a
single precision variable. This behaviour can be requested using the
&amp;ldquo;average_single&amp;rdquo; dumpmask flag.&lt;/p>
&lt;h1 id="multiple_output_blocks">Multiple output blocks&lt;/h1>
&lt;p>In more recent versions of EPOCH, it is now possible to have multiple
&amp;ldquo;output&amp;rdquo; blocks in the input deck, each with their own &amp;ldquo;dt_snapshot&amp;rdquo; or
&amp;ldquo;nstep_snapshot&amp;rdquo; and their own set of output variables.&lt;/p>
&lt;p>The syntax remains the same as the original &amp;ldquo;output&amp;rdquo; block syntax with
the addition of &amp;ldquo;name&amp;rdquo; and &amp;ldquo;restartable&amp;rdquo; fields.&lt;/p>
&lt;p>The &amp;ldquo;name&amp;rdquo; field specifies the file name to use for the output list.
Each time EPOCH generates an output dump, it writes an entry into the
file &amp;ldquo;&lt;code>&amp;lt;name&amp;gt;.visit&lt;/code>&amp;rdquo;. This can be used to find all the output dumps of
a specific output block. It is named with a &amp;ldquo;.visit&amp;rdquo; suffix to enable
its use as a file grouping list in the VisIt data analysis tool, but it
is just a plain text file so it can equally be used by any other
program.&lt;/p>
&lt;p>If two output blocks are written at the same time, the output will be
combined into a single file.&lt;/p>
&lt;p>The &amp;ldquo;restartable&amp;rdquo; field specifies that the output block should generate
output dumps containing all the information necessary to restart a
simulation.&lt;/p>
&lt;p>The following parameters are supported by the new style of output block
in addition to those for the traditional style:&lt;/p>
&lt;ul>
&lt;li>&lt;code>name&lt;/code> - Identifies the output block with a name which is
required when multiple output blocks are used.&lt;/li>
&lt;li>&lt;code>restartable&lt;/code> - Specifies whether or not the output for
this block is a restartable dump.&lt;/li>
&lt;li>&lt;code>dump_at_times&lt;/code> - Floating point parameter which
specifies a set of simulation times at which to write the current
output block. This can only be used with named output blocks. The
values are given as a comma separated list. eg. &amp;ldquo;dump_at_times =
0, 0.15, 1.1&amp;rdquo;. The name &amp;ldquo;times_dump&amp;rdquo; is accepted as a synonym. By
default the list is empty.&lt;/li>
&lt;li>&lt;code>dump_at_nsteps&lt;/code> - Integer parameter which specifies a
set of step numbers at which to write the current output block. This
can only be used with named output blocks. The values are given as a
comma separated list. eg. &amp;ldquo;dump_at_nsteps = 5, 11, 15&amp;rdquo;. The name
&amp;ldquo;nsteps_dump&amp;rdquo; is accepted as a synonym. By default the list is
empty.&lt;/li>
&lt;/ul>
&lt;p>- Floating point parameter which specifies a set of elapsed walltimes
at which to write the current output block. This can only be used with
named output blocks. The values are given as a comma separated list. eg.
&amp;ldquo;dump_at_walltimes = 10, 100.1, 250.5&amp;rdquo;. These times are the total
elapsed time in seconds since the start of the simulation. Note that if
the simulation has been restarted then the total elapsed time will
include the accumulated walltime of all previous runs that were used to
produce the restart dump. The name &lt;strong>walltimes_dump&lt;/strong> is accepted as a
synonym. By default the list is empty.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Floating point parameter which specifies the interval between output
dumps in elapsed walltime seconds. Setting zero or negative means that
the code will not output based on this condition. The default value is
-1.0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>file_prefix&lt;/code> - String parameter. It is sometimes useful
to distinguish between dumps generated by the different output blocks.
This parameter allows the user to supply a file prefix to be prepended
to all dumps generated by the current output block. See below for
further details. The default value is an empty string.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>rolling_restart&lt;/code> - Logical flag. If set to &amp;ldquo;T&amp;rdquo;, this sets
the parameters required for performing rolling restarts on the current
block. It is a shorthand for setting the following flags: &amp;ldquo;dump_cycle =
1&amp;rdquo;, &amp;ldquo;restartable = T&amp;rdquo; and &amp;ldquo;file_prefix = roll&amp;rdquo;. With rolling restarts
enabled the first file will be named &amp;ldquo;roll0000.sdf&amp;rdquo; and the second will
be &amp;ldquo;roll0001.sdf&amp;rdquo;. The third dump will again be named &amp;ldquo;roll0000.sdf&amp;rdquo;,
overwriting the first one. In this way, restart dumps can be generated
throughout the duration of the simulation whilst limiting the amount of
disk space used.
The following parameters cannot be used in conjunction with the new
style of output block:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>full_dump_every&lt;/p>
&lt;/li>
&lt;li>
&lt;p>restart_dump_every&lt;/p>
&lt;/li>
&lt;li>
&lt;p>force_first_to_be_restartable&lt;/p>
&lt;/li>
&lt;li>
&lt;p>force_last_to_be_restartable&lt;/p>
&lt;/li>
&lt;li>
&lt;p>use_offset_grid&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The &amp;ldquo;file_prefix&amp;rdquo; parameter warrants some further discussion. This
parameter prepends the given prefix to all files generated by the output
block in which it is specified. For example, if &amp;ldquo;file_prefix = aa&amp;rdquo; is
set then files generated by the output block will be named &amp;ldquo;aa0000.sdf&amp;rdquo;,
etc. instead of just &amp;ldquo;0000.sdf&amp;rdquo;.&lt;/p>
&lt;p>This also allows different variables to different files at the same time
step. For example, here are two output blocks which do not use file
prefixes:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
name = o1
nstep_snapshot = 1
charge_density = always
end:output
begin:output
name = o2
dump_at_nsteps = 10
restartable = T
end:output
&lt;/code>&lt;/pre>
&lt;p>With this input deck, we want to have the &amp;ldquo;charge_density&amp;rdquo; derived
variable at every snapshot and then periodically write a restart dump.
The problem is that the dump file &amp;ldquo;0010.sdf&amp;rdquo; contains both the restart
information and the &amp;ldquo;charge_density&amp;rdquo; variable. At the end of the run we
can&amp;rsquo;t just delete the large restart dumps without losing the smaller
variables at that time step.&lt;/p>
&lt;p>With the new version we would add a prefix to one or both blocks:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
name = o1
file_prefix = small
nstep_snapshot = 1
charge_density = always
end:output
begin:output
name = o2
nstep_snapshot = 10
restartable = T
end:output
&lt;/code>&lt;/pre>
&lt;p>Now the &amp;ldquo;charge_density&amp;rdquo; will be written to &amp;ldquo;small0000.sdf&amp;rdquo;, etc. At
step 10, two files will be written: &amp;ldquo;small0010.sdf&amp;rdquo; containing just the
charge_density and &amp;ldquo;0000.sdf&amp;rdquo; containing all the restart variables.&lt;/p>
&lt;p>Note that some care must be taken, since if the same variable is in the
output block for multiple file prefixes then multiple copies will be
written to file. This obviously uses more disk space and is more time
consuming than necessary.&lt;/p>
&lt;p>It should also be noted that if multiple output blocks use the same file
stem then their output will be combined. eg:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
name = o1
file_prefix = a
dump_at_nsteps = 2,4
ex = always
end:output
begin:output
name = o2
file_prefix = a
dump_at_nsteps = 3,4
ey = always
end:output
begin:output
name = o3
file_prefix = b
dump_at_nsteps = 4
ez = always
end:output
&lt;/code>&lt;/pre>
&lt;p>In this example, at step 2 a0000.sdf contains ex, step 3 a0001.sdf
contains ey, step 4 a0002.sdf contains ex, ey and b0000.sdf contains ez.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>output_global block</title><link>/documentation/input_deck/input_deck_output_global/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_output_global/</guid><description>&lt;p>This block contains parameters which should be applied to all output
blocks. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more
information on the input deck.&lt;/p>
&lt;p>With the introduction of multiple output blocks, there are now a few
parameters that only make sense to be applied globally across all output
blocks. To accommodate this, a new block named &amp;ldquo;output_global&amp;rdquo; has been
added. Most of the parameters accepted by this block have the same
meaning as those in the &amp;ldquo;output&amp;rdquo; block except that they are applied to
all &amp;ldquo;output&amp;rdquo; blocks.&lt;/p>
&lt;p>The parameters that can be specified in the &amp;ldquo;output_global&amp;rdquo; block are
as follows:&lt;/p>
&lt;ul>
&lt;li>&lt;code>force_first_to_be_restartable&lt;/code> - Logical flag which
determines whether the file written at time zero is a restart dump. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>force_last_to_be_restartable&lt;/code> - Force the code to
override other output settings and make the last output dump it writes
be a restart dump. Any internal condition which causes the code to
terminate will make the code write a restart dump, but code crashes or
scheduler terminations will not cause the code to write a restart dump.
&amp;ldquo;force_final_to_be_restartable&amp;rdquo; is accepted as a synonym. The
default value is &amp;ldquo;T&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dump_first&lt;/code> - Logical flag which determines whether to
write an output file immediately after initialising the simulation. The
default is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>dump_last&lt;/code> - Logical flag which determines whether to
write an output file just before ending the simulation. The default is
&amp;ldquo;T&amp;rdquo; if an output block exists in the input deck and &amp;ldquo;F&amp;rdquo; otherwise.
&amp;ldquo;dump_final&amp;rdquo; is accepted as a synonym.&lt;/li>
&lt;li>&lt;code>time_start&lt;/code> - Floating point parameter which specifies
the simulation time at which to start considering output for all output
blocks. Note that if &amp;ldquo;dump_first&amp;rdquo; or &amp;ldquo;dump_last&amp;rdquo; are set to true for
any block then dumps will occur at the first or last timestep regardless
of the value of this parameter. This also applies to the three following
parameters. The default value is 0.&lt;/li>
&lt;li>&lt;code>time_stop&lt;/code> - Floating point parameter which specifies the
simulation time at which to stop considering output for all output
blocks. The default value is the largest possible float.&lt;/li>
&lt;li>&lt;code>nstep_start&lt;/code> - Integer parameter which specifies the step
number at which to start considering output for the block. The default
value is 0.&lt;/li>
&lt;li>&lt;code>nstep_stop&lt;/code> - Integer parameter which specifies the step
number at which to stop considering output for the block. The default
value is the largest possible integer.&lt;/li>
&lt;li>Floating point parameter which specifies the elapsed walltime in
seconds at which to start considering output for all output blocks. Note
that if &lt;strong>dump_first&lt;/strong> or &lt;strong>dump_last&lt;/strong> are set to true for any blocks
then dumps will occur at the first or last timestep regardless of the
value of the &lt;strong>walltime_start&lt;/strong> parameter. The default value is 0.&lt;/li>
&lt;li>Floating point parameter which specifies the elapsed walltime in
seconds at which to stop considering output all output blocks. The
default value is the largest possible float.&lt;/li>
&lt;li>&lt;code>sdf_buffer_size&lt;/code> - Integer parameter. When writing
particle data to an SDF file, the data is first transferred into an
output buffer. The size of this buffer can have a big impact on the
overall speed of writing dump files. This parameter allows the size of
the buffer to be specified in bytes. The default value is 67108864 (64
MB).&lt;/li>
&lt;li>&lt;code>filesystem&lt;/code> - String parameter. Some filesystems can be
unreliable when performing parallel I/O. Often this is fixable by
prefixing the filename with &amp;lsquo;ufs&amp;rsquo; or &amp;lsquo;nfs&amp;rsquo;. This parameter supplies the
prefix to be used. The default value is an empty string.&lt;/li>
&lt;li>&lt;code>use_offset_grid&lt;/code> - When using moving windows some
visualisation programs (notably VisIt) show the motion of the window by
moving the visualisation window rather than by changing the x-axis.
Setting this option to &amp;ldquo;T&amp;rdquo; causes the code to write another grid which
always gives the offset relative to the left hand edge of the window
rather than the true origin. Performs no function when not using the
moving window. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code> dump_first_after_restart&lt;/code> - Logical flag to enable a
dump to occur immediately after restart. In the past, a &lt;code>dump_first&lt;/code>
flag in the output block would cause an output dump immediately after
restarting. Since this is rarely the desired behaviour, the flag is now
ignored when restarting. To force a dump to occur immediately after
restart, set &lt;code>dump_first_after_restart = T&lt;/code> in the output block. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>dist_fn block</title><link>/documentation/input_deck/input_deck_dist_fn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_dist_fn/</guid><description>&lt;p>This block contains information about distribution functions that should
be calculated for output. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input
deck&lt;/a> for more information on the input
deck.&lt;/p>
&lt;p>Sometimes it is useful to reconstruct part of the full phase space for
one or more particle species. This functionality is provided through a
&lt;em>dist_fn&lt;/em> block. The distribution function is integrated over all
dimensions which are not axes of the distribution function.&lt;/p>
&lt;p>Calculating distribution functions requires some degree of integration
of data leading to various possible ways of normalising the resulting
distribution function. In EPOCH, distribution functions are normalised
so that the value at every point of the distribution function is the
number of particles within that cell of the distribution function,
ignoring all phase space directions which are not considered as an axis
of the distribution function. Summing the distribution function should
give the total number of real particles (as opposed to computational
pseudoparticles) in the simulation.&lt;/p>
&lt;p>An example &lt;em>dist_fn&lt;/em> block is given below:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:dist_fn
name = x_px
ndims = 2
dumpmask = always
direction1 = dir_x
direction2 = dir_px
# Range is ignored for spatial coordinates
range1 = (1, 1)
range2 = (-50.0e-20, 50.0e-20)
# Resolution is ignored for spatial coordinates
resolution1 = 1
resolution2 = 5000
restrict_py = (-3.0e-20, 3.0e-20)
include_species:Electron
include_species:Carbon
end:dist_fn
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>name&lt;/code> - The name of the distribution function when it is
output. This name is appended with the name of each species for
which the data is output and so, for example, when applied to a
species named carbon the output is called &lt;em>x_px_Carbon&lt;/em>. The
Cartesian grid which describes the axes of the distribution function
would then be called &lt;em>grid_x_px_Carbon&lt;/em>.&lt;/li>
&lt;li>&lt;code>ndims&lt;/code> - The number of dimensions in this phase space
reconstruction. Due to difficulties in visualising data in more than
three dimensions, this is restricted to being 1, 2 or 3.&lt;/li>
&lt;li>&lt;code>dumpmask&lt;/code> - Determines which output dumps will include
this distribution function. The dumpmask has the same semantics as
those used by variables in the &amp;ldquo;output&amp;rdquo; block, described
&lt;a href="/documentation/input_deck/input_deck_output_block">here&lt;/a>. The dumpmask from
&amp;ldquo;distribution_functions&amp;rdquo; in the output block is applied first and
then this one is applied afterwards. For example, if the dist_fn
block contains &amp;ldquo;dumpmask = full&amp;rdquo; and the output block contains
&amp;ldquo;distribution_functions = always&amp;rdquo; then this distribution function
will be only be dumped at full dumps. The default dumpmask is
&amp;ldquo;always&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>direction**n**&lt;/code> - This is the phase space to sample
along axis . This can be any one of: dir_x, dir_y, dir_z,
dir_px, dir_py, dir_pz, dir_en, dir_gamma_m1, dir_xy_angle,
dir_yz_angle, dir_zx_angle with spatial codes only being
available in dimensionalities of the code which have that direction.
Therefore dir_z does not exist in EPOCH1D or EPOCH2D and dir_y
does not exist in EPOCH1D.&lt;/li>
&lt;/ul>
&lt;p>The flags &amp;ldquo;dir_xy_angle&amp;rdquo;, &amp;ldquo;dir_yz_angle&amp;rdquo; and &amp;ldquo;dir_zx_angle&amp;rdquo;
calculate the distribution of particle momentum directions in the X-Y,
Y-Z and Z-X planes.&lt;/p>
&lt;ul>
&lt;li>&lt;code>range**n**&lt;/code> - The range between which this axis should
run. This is in the form of (minimum, maximum). Any particle which
exceeds the range is ignored. For momentum directions this parameter is
specified in $kg\ ms^{-1}$. If the range of a momentum direction is set
so that the maximum and the minimum are equal then the code will
automatically set the range to exactly span the range of particle
momenta at the point of writing the dump.&lt;/li>
&lt;li>&lt;code>resolution**n**&lt;/code> - The number of gridpoints in a given
direction. This is ignored for spatial dimensions where the resolution
is always the same as the resolution of the underlying simulation.&lt;/li>
&lt;li>&lt;code>include_species&lt;/code> - Specifies a species which should be
included in the output. This is useful since it is rare that momentum
limits are appropriate for both electrons and ions, so usually for a
given dist_fn block only electrons or ions are considered. It is
possible to have two dist_fn blocks with the same name but different
ranges and different include_species settings produce the effect of a
single diagnostic for all species in the output file.&lt;/li>
&lt;li>&lt;code>output_deltaf&lt;/code> - If set to &amp;ldquo;T&amp;rdquo;, the particle weights used
in calculating the distribution function is adjusted by subtracting the
Delta-f distribution function for the particle species. The default
value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>restrict_{x,y,z,px,py,pz}&lt;/code> - Restrictions are specified
in the same way as ranges, but have a subtly different behaviour. Ranges
specify the range of a visible axis on the resulting distribution
function, whereas restrictions allow you to specify minimum and maximum
values for each spatial and momentum direction and use only particles
which fall within this range when calculating the distribution function.
Restrictions can be specified even for properties which are not being
used as axes. It is possible to set a restriction that is more
restrictive than the range applied. This is not trapped as an error and
such parts of the distribution function are guaranteed to be empty. The
available spatial restrictions depend on the dimensionality of the code.
Therefore, attempting to set restrict_z in EPOCH1D will produce a
warning.
At present, the code to calculate the distribution functions has one
limitation: it ignores particle shape functions when calculating
properties on the spatial axis, meaning that the result is less smooth
than normal properties from the code.&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>probe block</title><link>/documentation/input_deck/input_deck_probe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_probe/</guid><description>&lt;p>This block contains information about particle probes used for output.
See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more information
on the input deck.&lt;/p>
&lt;p>Sometimes it is useful to consider all the properties of particle which
pass through a point/line/plane (depending on dimension) in the
simulation. To allow this, it is possible to specify one or more
&lt;em>&lt;code>Particle Probe&lt;/code>&lt;/em> blocks in the input deck. These record
copies of all particles which cross a point/line/plane in a given
direction which meet minimum and maximum kinetic energy criteria and
output the particle properties into the normal output files. Particle
probes record the positions, momenta and weight of all particles passing
through the plane. To use particle probes, the code must not have been
compiled with the &lt;strong>&lt;code>-DNO_PARTICLE_PROBES&lt;/code>&lt;/strong> compiler option. This is a
fairly heavyweight diagnostic since each particle position must be
tested from within the particle push. The code will run faster if it is
not compiled in.
The probe is specified in terms of a point in the plane and the normal
vector to the plane which is to be monitored. Particles are only
recorded if they cross the plane in the direction given by the normal
vector. If you want to record particles travelling in both directions
then use two particle probes, one with an opposite signed normal vector
to the other.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:probe
name = electron_back_probe
point = (50.0e-6, -50.0e-6)
normal = (1.0, 0.0)
ek_min = 0.0
ek_max = -1.0
include_species : s1
dumpmask = always
end:probe
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>name&lt;/code> - The name that the probe should have in output
dumps. Output variables are then named this as a prefix. For
example, the block shown above will result in the name
&lt;strong>electron_back_probe_px&lt;/strong> for the x momentum. The particle
positions would just be called &lt;strong>electron_back_probe&lt;/strong>.&lt;/li>
&lt;li>&lt;code>point&lt;/code> - An arbitrary point in the plane of the probe.&lt;/li>
&lt;li>&lt;code>normal&lt;/code> - A vector normal to the plane of the probe, in
the direction of crossings you wish to monitor.&lt;/li>
&lt;li>&lt;code>include_species&lt;/code> - The species to which this probe
should be applied. To probe several species, use several probe
blocks in the input deck. &amp;ldquo;probe_species&amp;rdquo; is accepted as a
synonym.&lt;/li>
&lt;li>&lt;code>ek_min&lt;/code> - The minimum kinetic energy of particles to
store information about. Set to 0 for no minimum kinetic energy.&lt;/li>
&lt;li>&lt;code>ek_max&lt;/code> - The maximum kinetic energy of particles to
store information about. Set to -1 for no maximum kinetic energy.&lt;/li>
&lt;li>&lt;code>dumpmask&lt;/code> - The dump code for this particle probe. This
is the same as that for the main output controls in &lt;strong>input.deck&lt;/strong>.
Note that the code has to store copies of particles which pass
through the probe until a dump occurs. This means that the code&amp;rsquo;s
memory requirements can increase drastically if this code only dumps
probe information infrequently. If this is set to &lt;strong>never&lt;/strong> then the
code effectively never uses the probe.&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>collisions block</title><link>/documentation/input_deck/input_deck_collisions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_collisions/</guid><description>&lt;p>This block contains information about particle collisions. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;p>EPOCH has a particle collision routine with scattering algorithms based
on the model presented by Sentoku and Kemp&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> or the model presented by
PÃ©rez et al &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>, which in turn was based on the work of Nanbu and
Yonemura&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>. This adds a new output block named &amp;ldquo;collisions&amp;rdquo; which
accepts the following four parameters.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>use_collisions&lt;/code> - This is a logical flag which determines
whether or not to call the collision routine. If omitted, the default is
&amp;ldquo;T&amp;rdquo; if any of the frequency factors are non-zero (see below) and &amp;ldquo;F&amp;rdquo;
otherwise.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>This logical flag determines whether the scattering angle of
PÃ©rez/Nanbu will be used. The default is &amp;ldquo;T&amp;rdquo;. If &amp;ldquo;F&amp;rdquo;, the
Sentoku-Kemp algorithm will be used.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>coulomb_log&lt;/code> - This may either be set to a real value,
specifying the Coulomb logarithm to use when scattering the
particles or to the special value &amp;ldquo;auto&amp;rdquo;. If &amp;ldquo;auto&amp;rdquo; is used then the
routine will calculate a value based on the local temperature and
density of the particle species being scattered, along with the two
particle charges. If omitted, the default value is &amp;ldquo;auto&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>collide&lt;/code> - This sets up a symmetric square matrix of
size $nspecies,\times,nspecies$ containing the collision frequency
factors to use between particle species. The element (s1,s2) gives
the frequency factor used when colliding species s1 with species s2.
If the factor is less than zero, no collisions are performed. If it
is equal to one, collisions are performed normally. For any value
between zero and one, the collisions are performed using a frequency
multiplied by the given factor.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>If &amp;ldquo;collide&amp;rdquo; has a value of &amp;ldquo;all&amp;rdquo; then all elements of the matrix are
set to one. If it has a value of &amp;ldquo;none&amp;rdquo; then all elements are set to
minus one.
If the syntax &amp;ldquo;species1 species2 &lt;value>&amp;rdquo; is used, then the
(species1,species2) element of the matrix is set to the factor
&amp;ldquo;&lt;value>&amp;rdquo;. This may either be a real number, or the special value &amp;ldquo;on&amp;rdquo;
or &amp;ldquo;off&amp;rdquo;. The &amp;ldquo;collide&amp;rdquo; parameter may be used multiple times.
The default value is &amp;ldquo;all&amp;rdquo; (ie. all elements of the matrix are set to
one).&lt;/p>
&lt;ul>
&lt;li>&lt;code>collisional_ionisation&lt;/code> - If this logical flag is set to
&amp;ldquo;T&amp;rdquo; then the collisional ionisation model is enabled. This process is
independent of &lt;em>field_ionisation&lt;/em> (see
&lt;a href="/documentation/input_deck/input_deck_species/#ionisation">here&lt;/a>). However, in
order to set up &lt;em>collisional_ionisation&lt;/em> you must also specify
ionisation energies and electrons in a &lt;em>species&lt;/em> block (see
&lt;a href="/documentation/input_deck/input_deck_species/#ionisation">here&lt;/a>). The default
value is &amp;ldquo;F&amp;rdquo;.
For example:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-perl">begin:collisions
use_collisions = T
use_nanbu = T
coulomb_log = auto
collide = all
collide = spec1 spec2 off
collide = spec2 spec3 0.1
end:collisions
&lt;/code>&lt;/pre>
&lt;p>With this block, collisions are turned on, the Nanbu-PÃ©rez scattering
algorithm is used and the Coulomb logarithm is automatically calculated.
All values of the frequency array are set to one except (spec1,spec2) is
set to minus one (and also (spec2,spec1)) and (spec2,spec3) is set to
0.1&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Y. Sentoku and A. J. Kemp, &amp;ldquo;Numerical methods for particle
simulations at extreme densities and temperatures: Weighted
particles, relativistic collisions and reduced currents,&amp;rdquo; J. Comput.
Phys., 2008.
&lt;a href="http://www.sciencedirect.com/science/article/pii/S0021999108001988" target="_blank" rel="noopener">1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>F. PÃ©rez et al, &amp;ldquo;Improved modeling of relativistic collisions and
collisional ionization in particle-in-cell codes ,&amp;rdquo; Physics of
Plasmas, 2012.
&lt;a href="https://doi.org/10.1063/1.4742167" target="_blank" rel="noopener">2&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>K. Nanbu and S. Yonemura, &amp;ldquo;Weighted Particles in Coulomb Collision
Simulations Based on the Theory of a Cumulative Scattering Angle,&amp;rdquo;
J. Comput. Phys., 1998.
&lt;a href="https://doi.org/10.1006/jcph.1998.6049" target="_blank" rel="noopener">3&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>qed block</title><link>/documentation/input_deck/input_deck_qed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_qed/</guid><description>&lt;p>This block contains information about QED pair production. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;p>EPOCH can model QED pair production, synchrotron emission and radiation
reaction as described in Duclous et al&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> and Ridgers et al. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> It is
enabled using the compiler flag &lt;strong>&lt;code>-DPHOTONS&lt;/code>&lt;/strong>. Additionally, the
Trident process is enabled using &lt;strong>&lt;code>-DTRIDENT_PHOTONS&lt;/code>&lt;/strong>.&lt;/p>
&lt;p>A new input deck block named &amp;ldquo;qed&amp;rdquo; has been added which accepts the
following parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>use_qed&lt;/code> - Logical flag which turns QED on or off. The
default is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>qed_start_time&lt;/code> - Floating point value specifying the
time after which QED effects should be turned on. The default is 0.&lt;/li>
&lt;li>&lt;code>produce_photons&lt;/code> - Logical flag which specifies whether
to track the photons generated by synchrotron emission. If this is &amp;ldquo;F&amp;rdquo;
then the radiation reaction force is calculated but the properties of
the emitted photons are not tracked. The default is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>photon_energy_min&lt;/code> - Minimum energy of produced photons.
Radiation reaction is calculated for photons of all energies, but
photons with energy below this cutoff are not tracked. The default is&lt;/li>
&lt;/ul>
&lt;ol start="0">
&lt;li>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>photon_dynamics&lt;/code> - Logical flag which specifies whether
to push photons. If &amp;ldquo;F&amp;rdquo; then photons are generated, but their motion
through the domain is not simulated and they stay where they were
generated. The default is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>produce_pairs&lt;/code> - Logical flag which determines whether or
not to simulate the process of pair generation from gamma ray photons.
Both produce_photons and photon_dynamics must be &amp;ldquo;T&amp;rdquo; for this to work.
The default is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>qed_table_location&lt;/code> - EPOCH&amp;rsquo;s QED routines use lookup
tables to calculate gamma ray emission and pair production. If you want
to use tables in a different location from the default, specify the new
location using this parameter. The default is
&amp;ldquo;src/physics_packages/TABLES&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>use_radiation_reaction&lt;/code> - Logical flag which determines
whether or not to calculate the radiation reaction force. If set to &amp;ldquo;F&amp;rdquo;
then the force is not calculated. This should nearly always be enabled
when using the QED model. It is only provided for testing purposes. The
default value is &amp;ldquo;T&amp;rdquo;.
QED also requires that the code now know which species are electrons,
positrons and photons. The species type is specified using a single
&amp;ldquo;identify&amp;rdquo; tag in a species block. To specify an electron the block in
the deck would look like&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-perl">begin:species
name = electron
frac = 0.5
number_density = 7.7e29
identify:electron
end:species
&lt;/code>&lt;/pre>
&lt;p>Once the identity of a species is set then the code automatically
assigns mass and charge states for the species. Possible identities
are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>electron&lt;/code> - A normal electron species. All species of
electrons in the simulation must be identified in this way or they will
not generate photons.&lt;/li>
&lt;li>&lt;code>positron&lt;/code> - A normal positron species. All species of
positron in the simulation must be identified in this way or they will
not generate photons.&lt;/li>
&lt;li>&lt;code>photon&lt;/code> - A normal photon species. One species of this
type is needed for photon production to work. If multiple species are
present then generated photons will appear in the first species of this
type.&lt;/li>
&lt;li>&lt;code>bw_electron&lt;/code> - The electron species for pair production
by the Breit-Wheeler process. If a species of this type exists then
electrons from the pair production module will be created in this
species. If no species of this type is specified then pair electrons
will be generated in the first electron species.&lt;/li>
&lt;li>&lt;code>bw_positron&lt;/code> - As above but for positrons.&lt;/li>
&lt;li>&lt;code>trident_electron&lt;/code> - The electron species for pair
production by the Trident process. If a species of this type exists then
electrons from the pair production module will be created in this
species. If no species of this type is specified then pair electrons
will be generated in the first electron species.&lt;/li>
&lt;li>&lt;code>trident_positron&lt;/code> - As above but for positrons.&lt;/li>
&lt;li>&lt;code>proton&lt;/code> - A normal proton species. This is for convenience
only and is not required by the pair production routines.
A species should be identified only once, so a &amp;ldquo;bw_electron&amp;rdquo; species
does not need to also be identified as an &amp;ldquo;electron&amp;rdquo; species. If the
code is running with &amp;ldquo;produce_photons=T&amp;rdquo; then a photon species must be
created by the user and identified. If the code is running with
&amp;ldquo;produce_pairs=T&amp;rdquo; then the code must specify at least one electron (or
bw_electron) species and one positron (or bw_positron) species. These
species will usually be defined with zero particles from the start of
the simulation and will accumulate particles as the simulation
progresses. The code will fail to run if the needed species are not
specified.&lt;/li>
&lt;/ul>
&lt;p>The basic input deck has now been considered fully but it is possible
for an end user to add new blocks to the input deck As a result, a
version of the code which you have obtained from a source other than the
GitHub server may include other input deck blocks. These should
be described in additional documentation provided with the version of
the code that you have.&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>R. Duclous, J. G. Kirk, and A. R. Bell, &amp;ldquo;Monte carlo calculations
of pair production in high-intensity laserplasma interactions,&amp;rdquo;
Plasma Phys. Contr. F., vol. 53, no. 1, p. 015009,
2011
&lt;a href="http://iopscience.iop.org/article/10.1088/0741-3335/53/1/015009" target="_blank" rel="noopener">1&lt;/a>.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>C. P. Ridgers, J. G. Kirk, R. Duclous, T. G. Blackburn, C. S.
Brady, K. Bennett, T. D. Arber, A. R. Bell, &amp;ldquo;Modelling gamma-ray
photon emission and pair production in high-intensity laser&amp;ndash;matter
interactions,&amp;rdquo; J. Comp. Phys., vol. 260, p. 273-285,
2014
&lt;a href="https://doi.org/10.1016/j.jcp.2013.12.007" target="_blank" rel="noopener">2&lt;/a>.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>subset block</title><link>/documentation/input_deck/input_deck_subset/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_subset/</guid><description>&lt;p>This block contains configuration for filters which can be used to
modify the data to be output. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input
deck&lt;/a> for more information on the input
deck.&lt;/p>
&lt;p>It is possible to restrict the number of particles written to file
according to various criteria. For example, you can now output the
momentum of all particles which have a gamma lower than 1.8 or the
positions of a randomly chosen subset of a given species.&lt;/p>
&lt;p>A new input deck block named &amp;ldquo;subset&amp;rdquo; is defined which accepts the
following parameters:&lt;/p>
&lt;ul>
&lt;li>&lt;code>name&lt;/code> - The name given to this subset. This is used to
identify the subset in the output block and is also used when labelling
the data in the SDF files.&lt;/li>
&lt;li>&lt;code>include_species&lt;/code> - Add the given particle species to the
set of particles that this subset applies to. By default, no particle
species are included.&lt;/li>
&lt;li>&lt;code>dumpmask&lt;/code> - The dumpmask to use when considering this
subset in an output block. This takes the same form as the output block
dumpmask. The default value is &amp;ldquo;always&amp;rdquo;.&lt;/li>
&lt;li>&lt;code>random_fraction&lt;/code> - Select a random percentage of the
particle species. This is a real value between zero and one. If 0 is
specified, no particles are selected. If 1 is specified, all the
particles are selected. If 0.2 is specified, 20% of the particles are
selected.&lt;/li>
&lt;li>&lt;code>{px,py,pz,weight,charge,mass,gamma}_min&lt;/code> - Select only
the particles with momentum, weight, charge, mass or gamma which is
greater than the given value.&lt;/li>
&lt;li>&lt;code>{px,py,pz,weight,charge,mass,gamma}_max&lt;/code> - Select only
the particles with momentum, weight, charge, mass or gamma which is less
than the given value.&lt;/li>
&lt;li>&lt;code>{x,y,z}_min&lt;/code> - Select only the particles whose position
lies above the given value.&lt;/li>
&lt;li>&lt;code>{x,y,z}_max&lt;/code> - Select only the particles whose position
lies below the given value.&lt;/li>
&lt;li>&lt;code>id_min,max&lt;/code> - Select only the particles whose &amp;ldquo;id&amp;rdquo; is
greater than or less than the given values. The &amp;ldquo;id&amp;rdquo; field is explained
below.&lt;/li>
&lt;li>&lt;code>skip,skip_{x,y,z}&lt;/code> - Integer parameter for subsampling
output. If set to a positive integer then all grid-based variables using
the subset restriction will be reduced when being written to file. This
is achieved by skipping by the specified number of cells in each of the
specified directions. The &amp;ldquo;skip&amp;rdquo; parameter provides a quick method for
setting the same number of cells to skip in all directions. This
currently only applies to grid-based variables and is ignored for data
averages. The default value is &amp;ldquo;0&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;p>Once a subset has been defined, the subset name can then be used in
place of (or in addition to) the dumpmask in an &amp;ldquo;output&amp;rdquo; block (see also
&lt;a href="/documentation/input_deck/input_deck_output_block/#dumpmask">here&lt;/a>). For example:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:subset
name = background
random_fraction = 0.1
include_species:electron
include_species:proton
end:subset
begin:subset
name = high_gamma
gamma_min = 1.3
include_species:electron
end:subset
begin:output
particles = background + high_gamma + always
px = background + high_gamma
py = background
pz = always
end:output
&lt;/code>&lt;/pre>
&lt;p>In this example, three &amp;ldquo;px&amp;rdquo; blocks will be written:
&amp;ldquo;Particles/background/electron/Px&amp;rdquo;, &amp;ldquo;Particles/background/proton/Px&amp;rdquo; and
&amp;ldquo;Particles/high_gamma/electron/Px&amp;rdquo;. The &amp;ldquo;background&amp;rdquo; blocks will
contain 10% of the each species, randomly selected. The &amp;ldquo;high_gamma&amp;rdquo;
block will contain all the electrons with a gamma greater than 1.3.&lt;/p>
&lt;p>There will also be &amp;ldquo;Particles/background/electron/Py&amp;rdquo; and
&amp;ldquo;Particles/background/proton/Py&amp;rdquo; block containing y-momentum for the
same 10% random subset of particles. Finally, the
&amp;ldquo;Particles/All/electron/Pz&amp;rdquo; and &amp;ldquo;Particles/All/proton/Pz&amp;rdquo; will contain
the z-momentum for all particles.&lt;/p>
&lt;p>The final selection criteria given in the list above is &amp;ldquo;id_min&amp;rdquo; and
&amp;ldquo;id_max&amp;rdquo;. As of EPOCH version 4.0, the code can now assign a unique ID
field to every particle in the simulation. This can be useful for
tracking specific particles as they move through a simulation. As this
field adds extra memory requirements to the particles, it is disabled by
default and must be compiled in using the &lt;strong>&lt;code>-DPARTICLE_ID&lt;/code>&lt;/strong> compiler
flag.&lt;/p>
&lt;p>Particle IDs can be written to file using the &amp;ldquo;id&amp;rdquo; variable name in the
&lt;a href="/documentation/input_deck/input_deck_output_block">&amp;ldquo;output&amp;rdquo;&lt;/a> block. Eg.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
particles = always
id = always
end:output
&lt;/code>&lt;/pre>
&lt;h3 id="subsets_of_fields">Subsets of fields&lt;/h3>
&lt;p>Subset blocks can be applied to per-species variables such as current
and temperature. Only particles within the given momentum ranges and of
the selected species are included in the calculations. In addition,
subset blocks can now be applied to field or grid variables. This allows
you to output spatial sections using the &lt;code>{x,y,z}_max,min&lt;/code>
restrictions. The output data will be trimmed to the selected ranges and
a corresponding restricted grid included in the output. Note that
specifying an empty range will lead to output of the entire domain. For
example, the following snippet will output an ex_c_centre variable
restricted to the centre 1/3rd of the domain with a corresponding grid
grid_centre:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:subset
name = centre
x_min = x_min + (x_max - x_min) / 3.0
x_max = x_min + 2.0 * (x_max - x_min) / 3.0
end:subset
begin:output
...
ex = always + centre
end:output
&lt;/code>&lt;/pre>
&lt;h3 id="persistent_subsets">Persistent subsets&lt;/h3>
&lt;p>Persistent subsets are subsets that capture a set of particles once,
given a specified set of parameters, and then track those particles
permanently. Persistent subsets use the same blocks as normal subsets
and take the same parameters as normal subsets (except the skip
parameters which only apply to fields). Subsets are marked as persistent
by setting either&lt;/p>
&lt;ul>
&lt;li>&lt;code>persist_start_time&lt;/code> - Time at which to record the list
of particles to be tracked. Throughout the rest of the simulation
this recorded list will be used whenever requesting output for this
subset. &amp;ldquo;persist_after_time&amp;rdquo; is accepted as an alias. Set to 0
to record from the start of the simulation.&lt;/li>
&lt;li>&lt;code>persist_start_step&lt;/code> - Similar to persist_start_time
except this specifies a simulation step number to use instead of
time. &amp;ldquo;persist_after_step&amp;rdquo; is accepted as an alias.&lt;/li>
&lt;/ul>
&lt;p>If the input deck is edited on restart to add a new persistent subset
then it must be added &lt;strong>after&lt;/strong> existing persistent subsets or problems
may occur on restart.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>constant block</title><link>/documentation/input_deck/input_deck_constant/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_constant/</guid><description>&lt;p>This block contains information about user defined constants and
expressions. These are designed to simplify the initial condition setup.
See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more information
on the input deck.&lt;/p>
&lt;p>The &lt;em>constant&lt;/em> block type helps to make the input deck more flexible and
maintainable. It allows you to define constants and maths parser
expressions (see
&lt;a href="/documentation/code_details/maths_parser">EPOCH maths parser&lt;/a>)
which can be used by name later in the deck.
Constants are simply maths parser expressions which are assigned to a
name as shown above. When the name is used on the right hand side of a
deck expression it is replaced by the expression it was assigned with.
This expression may be a simple numerical constant, a mathematical
expression or a function. Constants may contain spatially varying
information without having to pre-calculate them at every location in
the domain. To those familiar with FORTRAN codes which use statement
functions, parameters appearing in the &amp;ldquo;constant&amp;rdquo; block are fairly
similar.
If a constant name is reused in a constant block then the old constant
is deleted and replaced with the new one. This happens without warning.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
lambda = 1.06 * micron
omega = 2.0 * pi * c / lambda
den_crit = critical(omega)
scale = 3.5 * micron
den_max = 5.0 * den_crit
thick = 300e-9
pplength = 6000e-9
widscale = 5.0e-6
t_wid = (10.0e-6) / c
amax = 1.0
wy = 1e-6
y = 0.0
slope = exp(-2.0 * (y/wy)^2)
blob = gauss(sqrt(x^2 + y^2), 0.0, 1.0e-6)
end:constant
&lt;/code>&lt;/pre>
&lt;p>Using constants can be very helpful when dealing with long, complicated
expressions since they allow the expression to be broken down into much
simpler parts. They can also be used to get around the FORTRAN string
length limitation built into many compilers which prevents deck lines
being longer then 512 characters long. As a general rule, it is a good
idea to break down complicated expressions using constants or by other
means, in order to make the deck look more readable.
Constants are persistent for the entire runtime of the code, allowing
them to be used when specifying time profiles for lasers, and also
allowing developers to use maths parser expressions for other internal
parts of the code where needed.
In the above example, several pre-defined constants have been used (&lt;em>pi&lt;/em>
and &lt;em>c&lt;/em>) and also several functions (&lt;em>critical&lt;/em>, &lt;em>exp&lt;/em>, &lt;em>gauss&lt;/em> and
&lt;em>sqrt&lt;/em>). These are described
&lt;a href="/documentation/code_details/maths_parser/#constants">here&lt;/a> and
&lt;a href="/documentation/code_details/maths_parser/#functions">here&lt;/a>.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>injector block</title><link>/documentation/input_deck/input_deck_injector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_injector/</guid><description>&lt;p>The &lt;em>injector&lt;/em> block specifies a particle source to be introduced
through a simulation boundary. Each injector block specifies a source of
a single species of particle defined by a density, centre of mass drift
momentum, temperature and number of simulation particles per cell. The
current version of the injectors is incompatible with the
PER_SPECIES_WEIGHT compiler flag, and attempting to use an injector
with a version of EPOCH compiled with this flag will fail.&lt;/p>
&lt;h1 id="concepts">Concepts&lt;/h1>
&lt;p>EPOCH can inject particles through any of the simulation boundaries.
This plasma is either a drifting Maxwellian corresponding to a
collisionally thermalized beam or a &amp;ldquo;flux Maxwellian&amp;rdquo; corresponding to
a Maxwellian source accelerated by an electrostatic accelerator. It can
have any temporal or transverse spatial profile of density, temperature
or drift that you wish to specify.&lt;/p>
&lt;p>EPOCH does not automatically make any assumption about the plasma that
you wish to inject and does not correct for currents injected into the
domain. Current due to an injected beam will be smoothly created as the
particles enter the domain. If you wish to inject a neutral beam, you
will have to use multiple injectors to inject electrons and ions so as
to produce a neutral beam. Great care must be taken when introducing
relativistic beams since the current due to a highly relativistic beam
will not be the current due to the centre of mass velocity since EPOCH
does not use the Maxwell-JÃ¼ttner distribution for loading particles.&lt;/p>
&lt;h1 id="boundary_conditions">Boundary conditions&lt;/h1>
&lt;p>The injectors only work properly with certain boundary conditions. For
most purposes the &amp;ldquo;open&amp;rdquo; boundary condition is the only one that makes
sense with injectors since particles are flowing freely through the
boundary. Remember that in any version of EPOCH that supports injectors
you can also use per species boundary conditions to allow you to have
different boundary conditions for injected and bulk particles.&lt;/p>
&lt;h1 id="moving_window">Moving window&lt;/h1>
&lt;p>Injectors and moving windows can be tricky to work with, so the default
behaviour of EPOCH is to stop all injectors when the window starts to
move. If you wish to override this behaviour then simply explicitly set
t_end in the injector block to a value after the window starts to move.
Setting&lt;/p>
&lt;pre>&lt;code class="language-perl"> t_end = t_end
&lt;/code>&lt;/pre>
&lt;p>will cause the injectors to continue running until the end of the
simulation even with the moving window. You must take great care when
specifying injectors for a moving window because you will likely get
gaps or bunches in particles injected through the x boundary and there
will probably be some shearing of particles introduced through y and z
boundaries. It is in general recommended that you specify a velocity
profile for the moving window that stops at times when particles are to
be injected and then starts again once the injection is complete.&lt;/p>
&lt;h1 id="keys">Keys&lt;/h1>
&lt;ul>
&lt;li>boundary - specifies which boundary to attach the particle source
too. Same specification as the
&lt;a href="/documentation/input_deck/input_deck_laser">laser block&lt;/a>, so
permitted values are x_min, x_max, y_min, y_max, z_min and
z_max&lt;/li>
&lt;li>species - specifies which species should be injected through the
boundary. Just specify the name of the species required.&lt;/li>
&lt;li>t_start - Time at which to start the injector&lt;/li>
&lt;li>t_end - Time at which to end the injector&lt;/li>
&lt;li>npart_per_cell - target pseudo-particle density for the injector.
Average number of particles injected will be this value or slightly
higher if very few particles are specified&lt;/li>
&lt;li>number_density - Number density of the particle source in $m^{-3}$.
Can be space varying along the boundary to which the injector is
attached and time varying&lt;/li>
&lt;li>number_density_min - Minimum number density in $m^{-3}$ below
which pseudo particles are not loaded. Use if the density has a
profile to avoid injecting low weight particles in low density
regions&lt;/li>
&lt;li>temp_x - Temperature in x direction (K)&lt;/li>
&lt;li>temp_y - Temperature in y direction (K)&lt;/li>
&lt;li>temp_z - Temperature in z direction (K)&lt;/li>
&lt;li>temp - Temperature in all directions (K)&lt;/li>
&lt;li>drift_x - Momentum drift in x direction in $kgm/s$&lt;/li>
&lt;li>drift_y - Momentum drift in x direction in $kgm/s$&lt;/li>
&lt;li>drift_z - Momentum drift in x direction in $kgm/s$&lt;/li>
&lt;/ul>
&lt;p>- Logical flag to determine whether to use an accelerated flux
Maxwellian rather than a drifting Maxwellian. This calculates the flux
due to passing a Maxwellian source into an electrostatic accelerator
instead of a drifting Maxwellian. If your particle source is a lab
accelerator then you may want to set this to true.&lt;/p>
&lt;h1 id="example_deck">Example Deck&lt;/h1>
&lt;pre>&lt;code class="language-perl">begin:injector
boundary = x_min
species = Electron
number_density = dens
temp_x = temp
drift_x = drift_p
npart_per_cell = 32
end:injector
&lt;/code>&lt;/pre>
&lt;h1 id="warnings">Warnings&lt;/h1>
&lt;p>Currently injectors are a beta feature of EPOCH. We believe them to work
correctly, but unusual results must be considered suspect. If you get
unexpected results, please contact the EPOCH development team.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Input deck antenna</title><link>/documentation/input_deck/input_deck_antenna/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_antenna/</guid><description>&lt;p>Antennae allow you to specify currents in the simulation domain that are
added to the self consistent currents from the core solver. You can
either specify the currents entirely manually or you can specify a
frequency and a profile for each current component. You can have as many
antennae as you want by specifying multiple antenna blocks.&lt;/p>
&lt;h1 id="example_deck">Example Deck&lt;/h1>
&lt;pre>&lt;code class="language-perl">begin:antenna
jx = if (r_xy lt micron, 1.0e-5, 0.0)
jy = if (r_xy lt micron, 1.0e-5, 0.0)
jz = if (r_xy lt micron, 1.0e-5, 0.0)
ranges = ((-micron, micron), (-micron, micron))
omega = 1.0e15
start_time = start
stop_time = end
end:antenna
&lt;/code>&lt;/pre>
&lt;h1 id="keys">Keys&lt;/h1>
&lt;ul>
&lt;li>jx - Profile for current in x direction. If you do not specify the
omega key then you should include any time dependence manually. If
the omega key is specified any time variation in jx will be
multiplicatively combined with the sinusoidal variation from omega.
Can be time and space varying.&lt;/li>
&lt;li>jy - Profile for current in y direction. If you do not specify the
omega key then you should include any time dependence manually. If
the omega key is specified any time variation in jy will be
multiplicatively combined with the sinusoidal variation from omega.
Can be time and space varying.&lt;/li>
&lt;li>jz - Profile for current in z direction. If you do not specify the
omega key then you should include any time dependence manually. If
the omega key is specified any time variation in jz will be
multiplicatively combined with the sinusoidal variation from omega.
Can be time and space varying.&lt;/li>
&lt;li>ranges - Array of (min,max) pairs for each dimension of your
simulation (1 pair for EPOCH1d, 2 pairs for EPOCH2D and 3 pairs for
EPOCH3D) showing the domain over which the antenna should operate.
Describes the region of space over which the current from the
antenna should be applied. The fields generated by that current will
propagate everywhere in the simulation domain. If ranges is not
present then the antenna will be applied to the whole domain.
Performance of the antenna block will be highest if you set the
smallest range possible.&lt;/li>
&lt;li>omega - Optional frequency for the antenna. If this key is set then
the current will vary sinusoidally with the specified frequency.
This is faster to run than specifying a sinusoidal profile in the
jx, jy or jz keys but performs the same (for a frequency that
doesn&amp;rsquo;t change in time, see Time variability section). Can be time
varying, but not space varying&lt;/li>
&lt;li>start_time - Time after which to start applying the antenna
currents. Can be &amp;ldquo;start&amp;rdquo; to apply from the start of the
simulation. If key is not present antenna runs from the start of the
simulation.&lt;/li>
&lt;li>stop_time - Time after which to cease applying the antenna
currents. Can be &amp;ldquo;end&amp;rdquo; to apply until the end of the simulation.
If key is not present antenna runs until the end of the simulation.&lt;/li>
&lt;/ul>
&lt;h1 id="time_variability">Time variability&lt;/h1>
&lt;p>When you specify time variation for the jx, jy or jz keys this specifies
the &lt;strong>instantaneous&lt;/strong> current to be applied at each moment in time.&lt;/p>
&lt;p>When you specify time variation in the omega key this specifies the
frequency at this time, but this is applied to the phase state of the
antenna as an integral. So the sinusoid that is applied to the current
is $\sin\Bigl(\int_0^t\omega(t')dt'\Bigr)$. For constant $\omega$ this
reduces to $\sin(\omega t)$. This gives the correct behaviour for
chirped antennae&lt;/p>
&lt;h1 id="example_deck_1">Example deck&lt;/h1>
&lt;p>An example deck for this block can be found in
example_decks/antenna.deck. The deck should take 5-20 seconds to run.&lt;/p></description></item><item><title>Input deck particle file</title><link>/documentation/input_deck/input_deck_particle_file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/input_deck_particle_file/</guid><description>&lt;p>This block contains information about the block used to load particles
from file. See
&lt;a href="/documentation/input_deck/input_deck">EPOCH input deck&lt;/a> for more
information on the input deck.&lt;/p>
&lt;p>The particles_from_file block is similar in function to the fields
block, it allows the loading of custom particle data from raw binary
data files. An example usage of the block is shown below&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:particles_from_file
species = &amp;quot;electron&amp;quot;
# Load mandatory data for 3D simulation
x_data = &amp;quot;xdata.dat&amp;quot;
y_data = &amp;quot;ydata.dat&amp;quot;
z_data = &amp;quot;ydata.dat&amp;quot;
w_data = &amp;quot;ydata.dat&amp;quot;
# Load particle ids in 4 byte int format,
# ignoring first 8 bytes of file
#offset = 8
#id4_data = &amp;quot;iddata.dat&amp;quot;
end:particles_from_file
&lt;/code>&lt;/pre>
&lt;p>Specifying a particles_from_file block for a species causes EPOCH to
load the per-particle data from the specified files. Data files are
assumed to be in order such that the first variable in each file will be
attributed to one particle, the second variable in each file to a second
electron, and so on. A target species to load to, as well as particle
position and weight data (unless has been set) must be supplied. With
the exception of particle ID, any optional parameters which are left
unspecified will be initialised to zero.
If the code has been compiled with or then particle IDs may be loaded
from a raw binary file of integers of either size 4 or size 8 regardless
of the compile time flag choice. If no particle ID data is supplied, IDs
will be generated sequentially from 1.
All other data should be in the form of floating point numbers of the
same precision as in the core code.
A particles_from_file block accepts the following parameters:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>species&lt;/code> - Name of the species to which the particles will
be loaded. This is a mandatory parameter and the corresponding species
block must be defined.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{x,y,z}_data&lt;/code> - File containing particle position data in
$m$. This data must be supplied, up to the dimensionality of the
simulation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>w_data&lt;/code> - File containing pseudoparticle weight, this is
the number of real particles the pseudoparticle represents. This data
must be supplied.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{px,py,pz}_data&lt;/code> - File containing particle momentum
data in $kg,ms^{-1}$. The default value is zero.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>id{4,8}_data&lt;/code> - File containing particle IDs in either
4 or 8 byte unsigned integer representation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>offset&lt;/code> - File offset. Number of bytes at the head of
the file to be ignored, may be specified multiple times. see for
more details of behaviour.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>Binary files</title><link>/documentation/input_deck/binary_files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/documentation/input_deck/binary_files/</guid><description>&lt;p>There are several input deck blocks which can read conditions directly
from a user-specified file. These include the , and . In all such cases,
the files specified must be in a simple binary format, often referred to
as &amp;ldquo;raw&amp;rdquo; binary files.&lt;/p>
&lt;p>Binary files are machine readable, but not human readable. If you try
opening a binary file in a text editor then you will see
incomprehensible characters and some text editors might even crash. Most
languages can write binary files, see &amp;ldquo;writeu&amp;rdquo; (in IDL/GDL), &amp;ldquo;fwrite&amp;rdquo; in
MatLab, the &amp;ldquo;b&amp;rdquo; parameter to &amp;ldquo;open&amp;rdquo; in Python and &amp;ldquo;form=&amp;lsquo;UNFORMATTED&amp;rsquo; &amp;quot;
in Fortran, so please see the documentation for those languages. Note
that standard unformatted output in Fortran also writes some additional
hidden output to the file that alters the offset of the actual binary
array data within the file. It is therefore recommended that you always
use the &amp;ldquo;access=&amp;lsquo;STREAM&amp;rsquo; &amp;quot; modifier whenever writing such files from
Fortran programs.&lt;/p>
&lt;p>For illustration purposes, here is a simple example of writing a 2D
array to file using Fortran:&lt;/p>
&lt;pre>&lt;code class="language-fortran">PROGRAM output_array
INTEGER :: iu, istat
INTEGER, PARAMETER :: nx = 10, ny = 20
DOUBLE PRECISION :: array(nx,ny)
CHARACTER(LEN=*), PARAMETER :: filename = âarray.datâ
array = 2.0d0
OPEN(newunit=iu, file=filename, status=âNEWâ, form=âUNFORMATTEDâ, &amp;amp;amp; access=âSTREAMâ, iostat=istat)
IF (istat == 0) THEN WRITE(iu) array CLOSE(iu, iostat=istat) ELSE PRINT*, âERROR: failed to open file â, âââ // filename // âââ, &amp;amp;amp; â for writingâ END IF
END PROGRAM output_array
&lt;/code>&lt;/pre>
&lt;p>In this example, there are 200 array elements written to file (10 *
20). Each element is a double-precision number which is 8 bytes.
Therefore, the total file size will be 1600 bytes. Note that for
Fortran, arrays are indexed using &amp;ldquo;column-major order&amp;rdquo;. This means that
in the file, the first array element &amp;ldquo;array(1,1)&amp;rdquo; will be followed by
&amp;ldquo;array(2,1)&amp;rdquo; and so on up to &amp;ldquo;array(10,1)&amp;rdquo;. After this, the second index
will be incremented and the array element &amp;ldquo;array(1,2)&amp;rdquo; will be output,
followed by &amp;ldquo;array(2,2)&amp;rdquo;, etc. In contrast, languages such as C and C++
use row-major order. For these languages the array output is transposed,
so the array elements are output in the order: &amp;ldquo;array[0][0],
array[0][1], .. array[0][19], array[1][0], ..&amp;rdquo;&lt;/p>
&lt;p>Simple binary files merely contain a long sequence of real numbers and
do not contain any information about the shape of the arrays that have
been written. This information must be supplied using the input deck.
These should correspond to the values of &amp;ldquo;nx&amp;rdquo;, &amp;ldquo;ny&amp;rdquo;, etc. For example,
to use the array generated by the Fortran code shown above, the input
deck must specify &amp;ldquo;nx = 10&amp;rdquo; and &amp;ldquo;ny = 20&amp;rdquo;.&lt;/p>
&lt;p>It is possible to write multiple arrays into the same binary file and
use the &amp;ldquo;offset&amp;rdquo; comand in the input deck to specify where the next
array in the file is to be located. This can be tricky to work with and
it is therefore recommended to write each separate array to its own
file.&lt;/p></description></item></channel></rss>