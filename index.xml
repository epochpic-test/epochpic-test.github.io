<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>EPOCH</title><link>/</link><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><description>EPOCH</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 09 Sep 2018 00:00:00 +0000</lastBuildDate><image><url>/images/logo_hub4b4d6a0f57638acebb5550a80c8c030_9243_300x300_fit_lanczos_2.png</url><title>EPOCH</title><link>/</link></image><item><title>Quick start</title><link>/quickstart/</link><pubDate>Mon, 14 Jun 2021 00:00:00 +0000</pubDate><guid>/quickstart/</guid><description>&lt;p>Information about downloading and compiling EPOCH&lt;/p></description></item><item><title/><link>/tutorial/acknowledging_epoch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/acknowledging_epoch/</guid><description>&lt;h2 id="how-do-i-acknowledge-use-of-the-code">How do I acknowledge use of the code?&lt;/h2>
&lt;p>There is a paper&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> which details many aspects of the &lt;strong>EPOCH&lt;/strong>
implementation and also includes useful information on current PIC
codes. This paper is OpenAccess so freely available to all. If using
EPOCH in your research output please use this as the reference for EPOCH
and ideally also acknowledge the UK grant which funded this work. The
BibTeX entry for this paper is as follows.&lt;/p>
&lt;pre>&lt;code class="language-bibtex">@article{Arber:2015hc,
author = {Arber, T D and Bennett, K and Brady, C S and Lawrence-Douglas,
A and Ramsay, M G and Sircombe, N J and Gillies, P and Evans,
R G and Schmitz, H and Bell, A R and Ridgers, C P},
title = {{Contemporary particle-in-cell approach to laser-plasma modelling}},
journal = {Plasma Physics and Controlled Fusion},
year = {2015},
volume = {57},
number = {11},
pages = {1--26},
month = nov
}
&lt;/code>&lt;/pre>
&lt;p>Acknowledgement: &amp;ldquo;This work was in part funded by the UK EPSRC grants
EP/G054950/1, EP/G056803/1, EP/G055165/1 and EP/ M022463/1.&amp;rdquo;&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>T D Arber, K Bennett, C S Brady, A Lawrence-Douglas, M G Ramsay, N
J Sircombe, P Gillies, R G Evans, H Schmitz, A R Bell,
&amp;ldquo;Contemporary particle-in-cell approach to laser-plasma
modelling,&amp;rdquo; Plasma Physics and Controlled Fusion, 2015.
&lt;a href="http://iopscience.iop.org/article/10.1088/0741-3335/57/11/113001/pdf" target="_blank" rel="noopener">link&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title/><link>/tutorial/an_example_problem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/an_example_problem/</guid><description>&lt;p>Brief description of problem&lt;/p>
&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>Describe the problem you are addressing here. What physical situations
does it model? What are the limitations?&lt;/p>
&lt;h1 id="running_notes">Running notes&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>Number of processors&lt;/strong>: n&lt;/li>
&lt;li>&lt;strong>Wall time&lt;/strong>: n minutes&lt;/li>
&lt;li>&lt;strong>Preprocessor directives&lt;/strong>: None&lt;/li>
&lt;li>&lt;strong>Physics packages&lt;/strong>: Collisions&lt;/li>
&lt;li>&lt;strong>Code version&lt;/strong>: 4.8.0&lt;/li>
&lt;/ul>
&lt;h1 id="input_deck">Input deck&lt;/h1>
&lt;pre>&lt;code>my_sample.deck
begin:constants
...
&lt;/code>&lt;/pre>
&lt;h1 id="output">Output&lt;/h1>
&lt;p>&lt;img src="/tutorial/HRBeamRelaxation.png" alt="My caption">&lt;/p>
&lt;ul>
&lt;li>End time : 10ms&lt;/li>
&lt;li>Plot : IDL contour of x_px_electron&lt;/li>
&lt;li>Plot command : contour, data.x_px_electron,
data.grid_x_px_electron.x, data.grid_x_px_electron.y,
nlevels=40, /fill,/xsty,/ysty&lt;/li>
&lt;/ul>
&lt;h1 id="summary">Summary&lt;/h1>
&lt;h1 id="further_reading">Further reading&lt;/h1></description></item><item><title/><link>/tutorial/basic_examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/basic_examples/</guid><description>&lt;p>In this section we outline a few worked examples of setting up problems
using the EPOCH input deck.&lt;/p>
&lt;h1 id="electron_two_stream_instability">Electron two stream instability&lt;/h1>
&lt;p>An obvious simple test problem to do with EPOCH is the electron two
stream instability. An example of a nice dramatic two stream instability
can be obtained using EPOCH1D by setting the code with the following
input deck file:\&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 400
# Size of domain
x_min = 0
x_max = 5.0e5
# Final time of simulation
t_end = 1.5e-1
stdout_frequency = 400
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
end:boundaries
begin:constant
drift_p = 2.5e-24
temp = 273
dens = 10
end:constant
begin:species
# Rightwards travelling electrons
name = Right
charge = -1
mass = 1.0
temp = temp
drift_x = drift_p
number_density = dens
npart = 4 * nx
end:species
begin:species
# Leftwards travelling electrons
name = Left
charge = -1
mass = 1.0
temp = temp
drift_x = -drift_p
number_density = dens
npart = 4 * nx
end:species
begin:output
# Number of timesteps between output dumps
dt_snapshot = 1.5e-3
# Properties at particle positions
particles = always
px = always
# Properties on grid
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
jx = always
ekbar = always
mass_density = never + species
charge_density = always
number_density = always + species
temperature = always + species
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="/tutorial/img/Two_Stream_Late.png" alt="The final state of the electron phase space for the two streaminstabilityexample">
In this example, the constant block sets up constants for the momentum
space drift, the temperature and the electron number density. The two
species blocks set up the two drifting Maxwellian distributions and the
constant density profile. The final output from this simulation is shown
in the figure.&lt;/p>
&lt;h1 id="structured_density_profile_in_epoch2d">Structured density profile in EPOCH2D&lt;/h1>
&lt;p>&lt;img src="/tutorial/img/EPOCH_density_example.png" alt="Complex 2D densitystructure">&lt;/p>
&lt;p>A simple but useful example for EPOCH2D is to have a highly structured
initial condition to show that this is still easy to implement in EPOCH.
A good example initial condition would be:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 500
ny = nx
x_min = -10 * micron
x_max = -x_min
y_min = x_min
y_max = x_max
nsteps = 0
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:constant
den_peak = 1.0e19
end:constant
begin:species
name = Electron
number_density = den_peak * (sin(4.0 * pi * x / length_x + pi / 4)) \
* (sin(8.0 * pi * y / length_y) + 1)
number_density_min = 0.1 * den_peak
charge = -1.0
mass = 1.0
npart = 20 * nx * ny
end:species
begin:species
name = Proton
number_density = number_density(Electron)
charge = 1.0
mass = 1836.2
npart = 20 * nx * ny
end:species
begin:output
number_density = always + species
end:output
&lt;/code>&lt;/pre>
&lt;p>The species block for &lt;strong>Electron&lt;/strong> is specified first, setting up the
electron density to be a structured 2D sinusoidal profile. The species
block for &lt;strong>Proton&lt;/strong> is then set to match the density of &lt;strong>Electron&lt;/strong>,
enforcing charge neutrality. On its own this initial condition does
nothing and so only needs to run for 0 timesteps (&lt;strong>nsteps = 0&lt;/strong> in
input.deck). The resulting electron number density should look like the
figure.&lt;/p>
&lt;h1 id="a_hollow_cone_in_3d">A hollow cone in 3D&lt;/h1>
&lt;p>A more useful example of an initial condition is to create a hollow
cone. This is easy to do in both 2D and 3D, but is presented here in 3D
form.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 250
ny = nx
nz = nx
x_min = -10 * micron
x_max = -x_min
y_min = x_min
y_max = x_max
z_min = x_min
z_max = x_max
nsteps = 0
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = simple_outflow
bc_y_min = periodic
bc_y_max = periodic
bc_z_min = periodic
bc_z_max = periodic
end:boundaries
begin:output
number_density = always + species
end:output
begin:constant
den_cone = 1.0e22
ri = abs(x - 5.0e-6) - 0.5e-6
ro = abs(x - 5.0e-6) + 0.5e-6
xi = 3.0e-6 - 0.5e-6
xo = 3.0e-6 + 0.5e-6
r = sqrt(y^2 + z^2)
end:constant
begin:species
name = proton
charge = 1.0
mass = 1836.2
number_density = if((r gt ri) and (r lt ro), den_cone, 0.0)
number_density = if((x gt xi) and (x lt xo) and (r lt ri), \
den_cone, number_density(proton))
number_density = if(x gt xo, 0.0, number_density(proton))
npart = nx * ny * nz
end:species
begin:species
name = electron
charge = -1.0
mass = 1.0
number_density = number_density(proton)
npart = nx * ny * nz
end:species
&lt;/code>&lt;/pre>
&lt;h4 id="3d_cone">Cone initial conditions in 3D&lt;/h4>
&lt;p>&lt;img src="/tutorial/img/3dcone.png" alt="Cone initial conditions in 3D">&lt;/p>
&lt;h4 id="2d_cone">Cone initial conditions in 2D&lt;/h4>
&lt;p>&lt;img src="/tutorial/img/2dcone.png" alt="Cone initial conditions in 2D">&lt;/p>
&lt;p>To convert this to 2D, simply replace the line &lt;code>r = sqrt(y^2+z^2)&lt;/code> with
the line &lt;code>r = abs(y)&lt;/code>. The actual work in these initial conditions is
done by the three lines inside the block for the &lt;strong>Proton&lt;/strong> species.
Each of these lines performs a very specific function:&lt;/p>
&lt;ol>
&lt;li>Creates the outer cone. Simply tests whether &lt;strong>r&lt;/strong> is within the
range of radii which corresponds to the thickness of the cone and if
so fills it with the given density. Since the inner radius is x
dependent this produces a cone rather than a cylinder. On its own,
this line produces a pair of cones joined at the tip.&lt;/li>
&lt;li>Creates the solid tip of the cone. This line just tests whether the
point in space is within the outer radius of the cone and within a
given range in &lt;strong>x&lt;/strong>, and fills it with the given density if true.&lt;/li>
&lt;li>Cuts off all of the cone beyond the solid tip. Simply tests if &lt;strong>x&lt;/strong>
is greater than the end of the cone tip and sets the density to zero
if so.&lt;/li>
&lt;/ol>
&lt;p>This deck produces an initial condition as in the Figures in
&lt;a href="#3d_cone">3D&lt;/a> and
&lt;a href="#2d_cone">2D&lt;/a>
respectively.&lt;/p>
&lt;h1 id="focussing_a_gaussian_beam">Focussing a Gaussian Beam&lt;/h1>
&lt;p>A laser can be driven on the boundary so that it focusses on a given
spot. Basic details of how to do this are
&lt;a href="https://en.wikipedia.org/wiki/Gaussian_beam" target="_blank" rel="noopener">here&lt;/a>. The following deck
gives an example for a laser attached to x_min. The important
parameters are the waist size (the size of the spot at the focus point)
and the distance from the attached boundary to the focus. In this case
the waist size is 0.9 micron, and the distance is 15 micron, meaning the
focus is at x = + 5 micron.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
nx = 500
ny = nx
# Final time of simulation
t_end = 100 * femto
# Size of domain
x_min = -10 * micron
x_max = -x_min
y_min = x_min
y_max = x_max
stdout_frequency = 10
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:constant
lambda0 = 1.0 * micron
# These two set the beam focus
w_0 = 0.9 * micron # Beam waist size
x_spot = 15 * micron # Distance from x_min to spot
# These are the parameters calculated for driving the laser
# These should not need to be modified
x_R = pi * w_0^2 / lambda0 # Rayleigh range
RC = x_spot * (1.0 + (x_R/x_spot)^2) # Radius of curvature on x_min
w_bnd = w_0 * sqrt( 1.0 + (x_spot/x_R)^2) # Spot size at x_min
gouy = atan(x_spot/x_R) # Gouy phase shift at x_min
end:constant
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e15
lambda = lambda0
phase = 2.0 * pi/ lambda0 * y^2 / (2.0 * RC) - gouy
profile = gauss(y,0,w_bnd)
end:laser
begin:output
name = normal
# Number of timesteps between output dumps
dt_snapshot = 25 * femto
# Properties on grid
grid = always
ey = always
bz = always
end:output
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="/tutorial/img/FocussedBeam.png" alt="The focussed beam">&lt;/p>
&lt;p>The deck is based on the laser test deck supplied with Epoch, with a
modified laser and longer runtime. Other classes of beam (Bessel etc)
can be created similarly.&lt;/p></description></item><item><title/><link>/tutorial/binary_files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/binary_files/</guid><description>&lt;p>There are several input deck blocks which can read conditions directly
from a user-specified file. These include the , and . In all such cases,
the files specified must be in a simple binary format, often referred to
as &amp;ldquo;raw&amp;rdquo; binary files.&lt;/p>
&lt;p>Binary files are machine readable, but not human readable. If you try
opening a binary file in a text editor then you will see
incomprehensible characters and some text editors might even crash. Most
languages can write binary files, see &amp;ldquo;writeu&amp;rdquo; (in IDL/GDL), &amp;ldquo;fwrite&amp;rdquo; in
MatLab, the &amp;ldquo;b&amp;rdquo; parameter to &amp;ldquo;open&amp;rdquo; in Python and &amp;ldquo;form=&amp;lsquo;UNFORMATTED&amp;rsquo; &amp;quot;
in Fortran, so please see the documentation for those languages. Note
that standard unformatted output in Fortran also writes some additional
hidden output to the file that alters the offset of the actual binary
array data within the file. It is therefore recommended that you always
use the &amp;ldquo;access=&amp;lsquo;STREAM&amp;rsquo; &amp;quot; modifier whenever writing such files from
Fortran programs.&lt;/p>
&lt;p>For illustration purposes, here is a simple example of writing a 2D
array to file using Fortran:&lt;/p>
&lt;pre>&lt;code class="language-fortran">PROGRAM output_array
INTEGER :: iu, istat
INTEGER, PARAMETER :: nx = 10, ny = 20
DOUBLE PRECISION :: array(nx,ny)
CHARACTER(LEN=*), PARAMETER :: filename = ’array.dat’
array = 2.0d0
OPEN(newunit=iu, file=filename, status=’NEW’, form=’UNFORMATTED’, &amp;amp;amp; access=’STREAM’, iostat=istat)
IF (istat == 0) THEN WRITE(iu) array CLOSE(iu, iostat=istat) ELSE PRINT*, ’ERROR: failed to open file ’, ’“’ // filename // ’”’, &amp;amp;amp; ’ for writing’ END IF
END PROGRAM output_array
&lt;/code>&lt;/pre>
&lt;p>In this example, there are 200 array elements written to file (10 *
20). Each element is a double-precision number which is 8 bytes.
Therefore, the total file size will be 1600 bytes. Note that for
Fortran, arrays are indexed using &amp;ldquo;column-major order&amp;rdquo;. This means that
in the file, the first array element &amp;ldquo;array(1,1)&amp;rdquo; will be followed by
&amp;ldquo;array(2,1)&amp;rdquo; and so on up to &amp;ldquo;array(10,1)&amp;rdquo;. After this, the second index
will be incremented and the array element &amp;ldquo;array(1,2)&amp;rdquo; will be output,
followed by &amp;ldquo;array(2,2)&amp;rdquo;, etc. In contrast, languages such as C and C++
use row-major order. For these languages the array output is transposed,
so the array elements are output in the order: &amp;ldquo;array[0][0],
array[0][1], .. array[0][19], array[1][0], ..&amp;rdquo;&lt;/p>
&lt;p>Simple binary files merely contain a long sequence of real numbers and
do not contain any information about the shape of the arrays that have
been written. This information must be supplied using the input deck.
These should correspond to the values of &amp;ldquo;nx&amp;rdquo;, &amp;ldquo;ny&amp;rdquo;, etc. For example,
to use the array generated by the Fortran code shown above, the input
deck must specify &amp;ldquo;nx = 10&amp;rdquo; and &amp;ldquo;ny = 20&amp;rdquo;.&lt;/p>
&lt;p>It is possible to write multiple arrays into the same binary file and
use the &amp;ldquo;offset&amp;rdquo; comand in the input deck to specify where the next
array in the file is to be located. This can be tricky to work with and
it is therefore recommended to write each separate array to its own
file.&lt;/p></description></item><item><title/><link>/tutorial/calculable_particle_properties/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/calculable_particle_properties/</guid><description>&lt;p>As of version 5, EPOCH introduces the concept of calculable particle
properties. These are generically implemented particle properties that
can be calculated for all particles in EPOCH and are used by name in
both particle output and specifying advanced distribution functions. The
currently available names are&lt;/p>
&lt;ul>
&lt;li>dir_x - X position of particle&lt;/li>
&lt;li>dir_y - Y position of particle (EPOCH2D and EPOCH3D)&lt;/li>
&lt;li>dir_z - Z position of particle (EPOCH3D)&lt;/li>
&lt;li>dir_px - X momentum of particle&lt;/li>
&lt;li>dir_py - Y momentum of particle&lt;/li>
&lt;li>dir_pz - Z momentum of particle&lt;/li>
&lt;li>dir_energy - Kinetic energy of particle (total energy for photons)&lt;/li>
&lt;li>dir_gamma_m_1 - Gamma - 1 for particle. Calculate as 1 for
photons&lt;/li>
&lt;li>dir_xy_angle - Angle of the particle&amp;rsquo;s momentum in the X/Y plane&lt;/li>
&lt;li>dir_yz_angle - Angle of the particle&amp;rsquo;s momentum in the Y/Z plane&lt;/li>
&lt;li>dir_zx_angle - Angle of the particle&amp;rsquo;s momentum in the Z/X plane&lt;/li>
&lt;li>dir_modp - Particle&amp;rsquo;s total momentum&lt;/li>
&lt;li>dir_mass - Particle&amp;rsquo;s mass&lt;/li>
&lt;li>dir_ekflux_xp - Particle&amp;rsquo;s kinetic energy flux in the positive x
direction&lt;/li>
&lt;li>dir_ekflux_xm - Particle&amp;rsquo;s kinetic energy flux in the negative x
direction&lt;/li>
&lt;li>dir_ekflux_yp - Particle&amp;rsquo;s kinetic energy flux in the positive y
direction&lt;/li>
&lt;li>dir_ekflux_ym - Particle&amp;rsquo;s kinetic energy flux in the negative y
direction&lt;/li>
&lt;li>dir_ekflux_zp - Particle&amp;rsquo;s kinetic energy flux in the positive z
direction&lt;/li>
&lt;li>dir_ekflux_zm - Particle&amp;rsquo;s kinetic energy flux in the negative z
direction&lt;/li>
&lt;li>dir_q - Particle charge&lt;/li>
&lt;li>dir_n - Particle self weight (number density)&lt;/li>
&lt;li>dir_jx - Single particle current in x direction&lt;/li>
&lt;li>dir_jy - Single particle current in y direction&lt;/li>
&lt;li>dir_jz - Single particle current in z direction&lt;/li>
&lt;li>dir_vx - Single particle velocity in x direction&lt;/li>
&lt;li>dir_vy - Single particle velocity in y direction&lt;/li>
&lt;li>dir_vz - Single particle velocity in z direction&lt;/li>
&lt;li>dir_modv - Single particle modulus velocity&lt;/li>
&lt;li>dir_id - Particle ID&lt;/li>
&lt;li>weight - Particle weight&lt;/li>
&lt;li>time - Particle local time&lt;/li>
&lt;li>dir_x_resample - Particle X position uncoupled from primary grid.
Allows you to produce resampled spatial output at the cost of
greater memory requirements on each node&lt;/li>
&lt;li>dir_y_resample - Particle Y position uncoupled from primary grid.
Allows you to produce resampled spatial output at the cost of
greater memory requirements on each node&lt;/li>
&lt;li>dir_z_resample - Particle Z position uncoupled from primary grid.
Allows you to produce resampled spatial output at the cost of
greater memory requirements on each node&lt;/li>
&lt;/ul></description></item><item><title/><link>/tutorial/compiler_flags/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/compiler_flags/</guid><description>&lt;p>As already stated, some features of the code are controlled by compiler
preprocessor directives. The flags for these preprocessor directives are
specified in &amp;ldquo;Makefile&amp;rdquo; and are placed on lines which look like the
following:&lt;/p>
&lt;pre>&lt;code>DEFINES += $(D)PER_SPECIES_WEIGHT
&lt;/code>&lt;/pre>
&lt;p>On most machines &lt;code>$(D)&lt;/code> just means &lt;code>-D&lt;/code> but the variable is required to
accommodate more exotic setups.&lt;/p>
&lt;p>Most of the flags provided in the &amp;ldquo;Makefile&amp;rdquo; are commented out by
prepending them with a &amp;ldquo;&lt;code>#&lt;/code>&amp;rdquo; symbol (the &amp;ldquo;make&amp;rdquo; system&amp;rsquo;s comment
character). To turn on the effect controlled by a given preprocessor
directive, just uncomment the appropriate &amp;ldquo;DEFINES&amp;rdquo; line by deleting
this &amp;ldquo;&lt;code>#&lt;/code>&amp;rdquo; symbol. The options currently controlled by the preprocessor
are:\&lt;/p>
&lt;ul>
&lt;li>
&lt;p>PER_SPECIES_WEIGHT - By default, each pseudoparticle in the code
can represent a different number of real particles. Memory can be
saved by disabling this feature and have all of the pseudoparticles
in a species use the same particle weight. Many of the codes more
advanced features require per-particle weighting so it is enabled by
default. Use this flag to disable per- particle weighting if you
need to save on memory, but it this option is recommended only for
advanced users.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_TRACER_PARTICLES - This flag will disable the option to specify
one or more species as zero-current particles. Zero-current
particles move about as would a normal particle with the same charge
and mass, but they do not generate any current and are therefore
passive elements in the simulation. Zero-current particles should be
included in collisions to ensure they move identically to ordinary
particles. The implementation of zero-current particles requires an
additional &amp;ldquo;IF&amp;rdquo; clause in the particle push, so it has a slight
performance impact. If you do not require the feature then setting
this flag will give a slight performance improvement.
&lt;span style="color: red; font-weight: bold;">WARNING:&lt;/span> Since
the particles effectively have zero weight in terms of their
numerical heating properties, they do not always behave in the same
way that an ordinary particle with weight would behave and this can
sometimes lead to unexpected behaviour. If the purpose is merely to
track a subset of a particle species to use as output then a better
mechanism to use is &amp;ldquo;persistent subsets&amp;rdquo; (see
&lt;a href="/tutorial/input_deck_subset">here&lt;/a>). In version 5.0, this
flag will be and replaced with &amp;ldquo;ZERO_CURRENT_PARTICLES&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_PARTICLE_PROBES - For laser plasma interaction studies it can
sometimes be useful to be able to record information about particles
which cross a plane in the simulation. Since this requires the code
to check whether each particles has crossed the plane in the
particles pusher and also to store copies of particles until the
next output dump, it is a heavyweight diagnostic. If you don&amp;rsquo;t
require the diagnostic you can set this flag to disable it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_SHAPE_TOPHAT - By default, the code uses a first order
b-spline (triangle) shape function to represent particles giving
third order particle weighting. Using this flag changes the particle
representation to that of a top-hat function (0th order b-spline
yielding a second order weighting).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_SHAPE_BSPLINE3 - This flag changes the particle
representation to that of a 3rd order b-spline shape function (5th
order weighting).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_ID - When this option is enabled, all particles are
assigned a unique identification number when writing particle data
to file. This number can then be used to track the progress of a
particle during the simulation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_ID4 - This does the same as the previous option except it
uses a 4-byte integer instead of an 8-byte one. Whilst this saves
storage space, care must be taken that the number does not overflow.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PHOTONS - This enables support for photon particle types in the
code. These are a pre-requisite for modelling synchrotron emission,
radiation reaction and pair production (see
&lt;a href="/tutorial/input_deck_qed">here&lt;/a>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>TRIDENT_PHOTONS - This enables support for virtual photons which
are used by the Trident process for pair production.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PREFETCH - This enables an Intel-specific code optimisation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARSER_DEBUG - The code outputs more detailed information whilst
parsing the input deck. This is a debug mode for code development.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARTICLE_DEBUG - Each particle is additionally tagged with
information about which processor it is currently on, and which
processor it started on. This is a debug mode for code development.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MPI_DEBUG - This option installs an error handler for MPI calls
which should aid tracking down some MPI related errors.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SIMPLIFY_DEBUG - This option enables debugging code related to the
deck parser simplification routine.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_IO - This option disables all file I/O which can be useful when
doing benchmarking.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>COLLISIONS_TEST - This enables some routines for debugging the
collision routines. It completely alters the behaviour of the code.
This flag should never be enabled by the end user.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PER_PARTICLE_CHARGE_MASS - By default, the particle charge and
mass are specified on a per-species basis. With this flag enabled,
charge and mass become a per-particle property. This is a legacy
flag which will be removed soon.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PARSER_CHECKING - Setting this flag adds code which checks for
valid values on evaluated deck expressions. This slows down the code
but may be required if floating point exceptions are enabled.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>WORK_DONE_INTEGRATED - This enables support for tracking the work
done on each particle by the electric field. Note that this
increases the size of each particle by 48 bytes. The information
gathered can be output to file using the &amp;ldquo;work_{x,y,z}&amp;rdquo; and
&amp;ldquo;work_{x,y,z}_total&amp;rdquo; dumpmasks. See
&lt;a href="/tutorial/input_deck_output_block/#particle_variables">here&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DELTAF_METHOD - Compile the code to use the delta-f method to
represent particles rather than standard PIC. Note that this
completely changes the code behaviour and should not be enabled for
normal use. See
&lt;a href="/tutorial/using_delta_f">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DELTAF_DEBUG - Add debug code for the delta-f method.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HC_PUSH - Use the push from
&lt;a href="https://doi.org/10.1063/1.4979989" target="_blank" rel="noopener">Higuera and
Cary&lt;/a> rather than the Boris push.
This is slightly slower than the Boris push but gives the correct
$\mathbf{E} \times \mathbf{B}$ velocity, improving performance for
highly relativistic simulations.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_USE_ISATTY - When printing the initial welcome message, EPOCH
makes use of the C-library&amp;rsquo;s isatty function. This requires
Fortran2003 features that might not be available on all platforms.
The flag allows this functionality to be disabled on platforms that
don&amp;rsquo;t support it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>NO_MPI3 - This compiler flag allows the user to disable MPI-3
features such as the &amp;ldquo;MPI_TYPE_SIZE_X&amp;rdquo; routine. This allows the
code to be compiled against older versions of the MPI library. The
flag should only be enabled if the code fails to compile without it.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="errors_for_unspecified_precompiler_directives">Errors for unspecified precompiler directives&lt;/h1>
&lt;p>If a user requests an option which the code has not been compiled to
support then the code will give an error or warning message as follows:&lt;/p>
&lt;pre>&lt;code> *** ERROR ***
Unable to set &amp;quot;use_qed=T&amp;quot; in the &amp;quot;qed&amp;quot; block.
Please recompile with the -DPHOTONS preprocessor flag.
&lt;/code>&lt;/pre>
&lt;h1 id="other_makefile_flags">Other Makefile flags&lt;/h1>
&lt;p>It is also possible to pass other flags to the compiler. In &amp;ldquo;Makefile&amp;rdquo;
there is a line which reads&lt;/p>
&lt;pre>&lt;code>FFLAGS = -O3 -fast
&lt;/code>&lt;/pre>
&lt;p>The two commands to the right are compiler flags and are passed
unaltered to the FORTRAN compiler. Change this line to add any
additional flags required by your compiler.&lt;/p>
&lt;p>By default, EPOCH will write a copy of the source code and input decks
into each restart dump. This can be very useful since a restart dump
contains an exact copy of the code which was used to generate it,
ensuring that you can always regenerate the data or continue running
from a restart. The output can be prevented by using &amp;ldquo;dump_source_code
= F&amp;rdquo; and &amp;ldquo;dump_input_deck = F&amp;rdquo; in the output block. However, the
functionality is difficult to build on some platforms so the Makefile
contains a line for bypassing this section of the build process. Just
below all the DEFINE flags there is the following line:&lt;/p>
&lt;pre>&lt;code>#ENCODED_SOURCE = epoch_source_info_dummy.o
&lt;/code>&lt;/pre>
&lt;p>Just uncomment this line and source code in restart dumps will be
permanently disabled.&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/running">Running EPOCH&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/compiling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/compiling/</guid><description>&lt;p>To compile EPOCH in the supplied state, you must first change to the
correct working directory. As explained in , the root directory for
EPOCH contains several subdirectories, including separate directories
for each of the 1D, 2D and 3D versions of the code. To compile the 2D
version of the code, you first switch to the &amp;ldquo;epoch2d&amp;rdquo; directory using
the command&lt;br>
&lt;strong>&lt;code>cd $HOME/epoch/epoch2d&lt;/code>&lt;/strong>&lt;br>
and then type&lt;br>
&lt;strong>&lt;code>make&lt;/code>&lt;/strong>&lt;br>
and the code will compile. There are certain options within the code
which are controlled by compiler preprocessors and are described in the
next section. When the code is compiled, it creates a new directory
called &amp;ldquo;bin&amp;rdquo; containing the compiled binary which will be called
&lt;code>epoch1d&lt;/code>, &lt;code>epoch2d&lt;/code> or &lt;code>epoch3d&lt;/code>. To run the code, just execute the
binary file by typing:&lt;br>
&lt;strong>&lt;code>./bin/epoch2d&lt;/code>&lt;/strong>&lt;br>
or whatever the correct binary is for the dimensionality of the code
that you have. You should be given a screen which begins with the EPOCH
logo, and then reads:\&lt;/p>
&lt;pre>&lt;code>The code was compiled with no compile time options
Welcome to EPOCH2D version 4.12.0 (commit v4.12.0-0-gfd74a464-clean)
Code is running on 1 processing elements
Specify output directory
&lt;/code>&lt;/pre>
&lt;p>At this point, the user simply types in the name of the (already
existing) output directory and the code will read the input deck files
inside the specified directory and start running. To run the code in
parallel, just use the normal mpirun or mpiexec scripts supplied by your
MPI implementation. If you want the code to run unattended, then you
will need to pipe in the output directory name to be used. The method
for doing this varies between MPI implementations. For many MPI
implementations (such as recent versions of OpenMPI) this can be
achieved with the following:&lt;br>
&lt;strong>&lt;code>echo Data | mpirun -np 2 ./bin/epoch2d&lt;/code>&lt;/strong>&lt;br>
Some cluster setups accept the following instead:&lt;br>
&lt;strong>&lt;code>mpirun -np 2 ./bin/epoch2d &amp;lt; deck.file&lt;/code>&lt;/strong>&lt;br>
where &amp;ldquo;deck.file&amp;rdquo; is a file containing the name of the output directory.
Some cluster queueing systems do not allow the use of input pipes to
mpirun. In this case, there is usually a &amp;ldquo;-stdin&amp;rdquo; command line option to
specify an input file. See your cluster documentation for more details.&lt;/p>
&lt;p>As of version 4.2.12, EPOCH now checks for the existence of a file named
&amp;ldquo;USE_DATA_DIRECTORY&amp;rdquo; in the current working directory before it
prompts the user for a Data directory. If such a file exists, it reads
it to obtain the name of the data directory to use and does not prompt
the user. If no such file exists, it prompts for a data directory name
as before. This is useful for cluster setups in which it is difficult or
impossible to pipe in the directory name using a job script.&lt;/p>
&lt;p>The &amp;ldquo;Makefile&amp;rdquo; contains configurations for fort, gfortran, pgi, g95,
hector/archer and ibm (the compiler suite used on IBM&amp;rsquo;s BlueGene
machines). In order to compile using one of the listed configurations,
add the &amp;ldquo;&lt;code>COMPILER=&lt;/code>&amp;rdquo; option to the &amp;ldquo;&lt;code>make&lt;/code>&amp;rdquo; command. For example&lt;br>
&lt;strong>&lt;code>make COMPILER=gfortran&lt;/code>&lt;/strong>&lt;br>
will compile the code using the gfortran compiler and appropriate
compiler flags. The options are&lt;/p>
&lt;ul>
&lt;li>COMPILER=gfortran - GNU Fortran&lt;/li>
&lt;li>COMPILER=intel - Intel ifort&lt;/li>
&lt;li>COMPILER=pgi - Portland group compiler&lt;/li>
&lt;li>COMPILER=g95 - G95 compiler&lt;/li>
&lt;li>COMPILER=ibm - IBM AIX Fortran compiler for BlueGene&lt;/li>
&lt;li>COMPILER=hector - Cray compiler as used on hector and archer&lt;/li>
&lt;/ul>
&lt;p>As of version 4.11, it is now possible for the build system to
automatically detect the correct compiler to use. Typing
&lt;code>make COMPILER=auto&lt;/code> will cause the build system to guess which compiler
is in use. Note that this might not always work, so it is better to use
the correct value for &lt;code>COMPILER&lt;/code> if it is already known.&lt;/p>
&lt;p>You can also compile the code with debugging flags by adding
&amp;ldquo;&lt;code>MODE=debug&lt;/code>&amp;rdquo; and can compile using more than one processor by using
&amp;ldquo;&lt;code>-j&amp;lt;n&amp;gt;&lt;/code>&amp;rdquo;, where &amp;ldquo;&lt;code>&amp;lt;n&amp;gt;&lt;/code>&amp;rdquo; is the number of processors to use. Note that
this is just to speed up the compilation process; the resulting binary
can be run on any number of processors.&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/compiler_flags">Compiler flags&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/deck_example/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/deck_example/</guid><description>&lt;pre>&lt;code class="language-perl">begin:control
nx = 200
# Size of domain
x_min = -4 * micron
x_max = -x_min
# Final time of simulation
t_end = 50 * femto
#stdout_frequency = 10
end:control
begin:boundaries
bc_x_min = open
#bc_x_min = simple_laser
bc_x_max = open
end:boundaries
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e15
lambda = 1 * micron
phase = pi / 2
t_profile = gauss(time, 2*micron/c, 1*micron/c)
t_end = 4 * micron / c
end:laser
begin:output
dt_snapshot = 1 * micron / c
# Properties on grid
grid = always
ey = always
end:output
&lt;/code>&lt;/pre></description></item><item><title/><link>/tutorial/decktransclusiontest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/decktransclusiontest/</guid><description>&lt;p>some text here and some handwritten JSON {&amp;ldquo;blocks&amp;rdquo;:{&amp;ldquo;laser&amp;rdquo;:&amp;ldquo;abc&amp;rdquo;,
&amp;ldquo;boundaries&amp;rdquo;:&amp;ldquo;xyz&amp;rdquo;, &amp;ldquo;control&amp;rdquo;:&amp;ldquo;wonderful&amp;rdquo;}}&lt;/p></description></item><item><title/><link>/tutorial/example_creator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/example_creator/</guid><description>&lt;p>User-supplied example problems can be submitted here. These should
contain, at minimum, a brief description and setup information, the
input deck used and an image of the expected output.&lt;/p>
&lt;p>Enter a page title (e.g. two stream instability) below to create a new
example page for EPOCH. You need a user account to proceed. A page will
be created with a skeleton layout for you to fill in. &lt;inputbox>
type=create prefix=EPOCH USER: buttonlabel=Submit example problem
preload=Template:Preload example &lt;/inputbox>&lt;/p></description></item><item><title/><link>/tutorial/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/faq/</guid><description>&lt;h1 id="faqs">FAQs&lt;/h1>
&lt;h2 id="is-this-manual-up-to-date">Is this manual up to date?&lt;/h2>
&lt;p>Whenever a new milestone version of &lt;strong>EPOCH&lt;/strong> is finalised, the version
number is changed and this manual is updated accordingly. The version
number of the manual should match the first two digits for that of the
&lt;strong>EPOCH&lt;/strong> source code. This version number is printed to screen when you
run the code. The line looks something like the following:&lt;/p>
&lt;pre>&lt;code> Welcome to EPOCH2D version 4.16.0 (commit v4.16.0-0-g69eb0fa6-clean)
&lt;/code>&lt;/pre>
&lt;p>Here, only the number &amp;ldquo;4.16&amp;rdquo; is important.&lt;/p>
&lt;p>Since version 3.1 of the manual, new additions and changes are mentioned
in the appendix.&lt;/p>
&lt;h2 id="what-is-epoch">What is &lt;strong>EPOCH&lt;/strong>?&lt;/h2>
&lt;p>&lt;strong>EPOCH&lt;/strong> is a plasma physics simulation code which uses the Particle in
Cell (PIC) method. In this method, collections of physical particles are
represented using a smaller number of pseudoparticles, and the fields
generated by the motion of these pseudoparticles are calculated using a
finite difference time domain technique on an underlying grid of fixed
spatial resolution. The forces on the pseudoparticles due to the
calculated fields are then used to update the pseudoparticle velocities,
and these velocities are then used to update the pseudoparticle
positions. This leads to a scheme which can reproduce the full range of
classical micro-scale behaviour of a collection of charged particles.&lt;/p>
&lt;h3 id="features-of-epoch">Features of &lt;strong>EPOCH&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>MPI parallelised, explicit, second-order, relativistic PIC code.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Dynamic load balancing option for making optimal use of all
processors when run in parallel.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MPI-IO based output, allowing restart on an arbitrary number of
processors.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Data analysis and visualisation options include ITT IDL, LLNL VisIt,
Mathworks MatLab and matplotlib in Python.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Control of setup and runs of &lt;strong>EPOCH&lt;/strong> through a customisable input
deck.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="the-origins-of-the-code">The origins of the code&lt;/h2>
&lt;p>The &lt;strong>EPOCH&lt;/strong> family of PIC codes is based on the older PSC code written
by Hartmut Ruhl and retains almost the same core algorithm for the field
updates and particle push routines. &lt;strong>EPOCH&lt;/strong> was written to add more
modern features and to structure the code in such a way that future
expansion of the code is made as easy as possible.&lt;/p>
&lt;h2 id="what-normalisations-are-used-in-epoch">What normalisations are used in &lt;strong>EPOCH&lt;/strong>?&lt;/h2>
&lt;p>Since the idea from the start was that &lt;strong>EPOCH&lt;/strong> would be used by a
large number of different users and that it should be as easy as
possible to &amp;ldquo;plug in&amp;rdquo; different modules from different people into a
given copy of the code, it was decided to write &lt;strong>EPOCH&lt;/strong> in SI units.
There are a few places in the code where some quantities are given in
other units for convenience (for example charges are specified in
multiples of the electron charge), but the entire core of the code is
written in SI units.&lt;/p>
&lt;h2 id="what-are-those-_num-things-doing-everywhere">What are those &lt;code>_num&lt;/code> things doing everywhere?&lt;/h2>
&lt;p>Historically using the compiler auto-promotion of &lt;code>REAL&lt;/code> to
&lt;code>DOUBLE PRECISION&lt;/code> was unreliable, so &lt;strong>EPOCH&lt;/strong> uses &amp;ldquo;kind&amp;rdquo; tags to
specify the precision of the code. The &lt;code>_num&lt;/code> suffixes and the
associated definition of &lt;code>REAL&lt;/code>s as &lt;code>REAL(num)&lt;/code> are these &amp;ldquo;kind&amp;rdquo; tags in
operation. The &lt;code>_num&lt;/code> tags force numerical constants to match the
precision of the code, preventing errors due to precision conversion.
The important thing is that all numerical constants should be tagged
with an &lt;code>_num&lt;/code> tag and all &lt;code>REAL&lt;/code>s should be defined as &lt;code>REAL(num)&lt;/code>.&lt;/p>
&lt;h2 id="what-is-an-input-deck">What is an input deck?&lt;/h2>
&lt;p>An input deck is text file which can be used to set simulation
parameters for &lt;strong>EPOCH&lt;/strong> without needing to edit or recompile the source
code. It consists of a list of blocks which start as &lt;strong>begin:blockname&lt;/strong>
and end with &lt;strong>end:blockname&lt;/strong>. Within the body of each block is a list
of key/value pairs, one per line, with key and value separated by an
equals sign. Most aspects of a simulation can be controlled using an
input deck, such as the number of grid points in the simulation domain,
the initial distribution of particles and initial electromagnetic field
configuration. It is designed to be relatively easy to read and edit.
For most projects it should be possible to set up a simulation without
editing the source code at all. For more details, read &amp;quot;&amp;quot;
(Section 
&lt;a href="#sec:input">3&lt;/a>{reference-type=&amp;ldquo;ref&amp;rdquo; reference=&amp;ldquo;sec:input&amp;rdquo;}).&lt;/p>
&lt;h2 id="i-just-want-to-use-the-code-as-a-black-box-or-im-just-starting" class="-how-do-i-do-that">I just want to use the code as a black box, or I&amp;rsquo;m just starting. How do I do that?&lt;/h2>
&lt;p>Begin by reading &amp;quot;&amp;quot; (Section 
&lt;a href="#sec:examples">5&lt;/a>{reference-type=&amp;ldquo;ref&amp;rdquo;
reference=&amp;ldquo;sec:examples&amp;rdquo;}). There&amp;rsquo;s quite a lot to learn in order to get
started, so you should plan to read through all of this section. You
will also need to refer to &amp;quot;&amp;quot;
(Section 
&lt;a href="#sec:input">3&lt;/a>{reference-type=&amp;ldquo;ref&amp;rdquo; reference=&amp;ldquo;sec:input&amp;rdquo;}).
Next, look at the code and have a play with some test problems. After
that re-read this section. This should be enough for testing simple
problems.&lt;/p>
&lt;h2 id="what-is-the-auto-loader">What is the auto-loader?&lt;/h2>
&lt;p>Throughout this document we will often refer to the &amp;ldquo;auto-loader&amp;rdquo; when
setting up the initial particle distribution. In the input deck it is
possible to specify a functional form for the density and temperature of
a particle species. &lt;strong>EPOCH&lt;/strong> will then place the particles to match the
density function and set the velocities of the particles so that they
match the Maxwellian thermal distribution for the temperature. The code
which performs this particle set up is called the &amp;ldquo;auto-loader&amp;rdquo;.&lt;/p>
&lt;p>At present, there is no way to specify a non-Maxwellian particle
distribution from within the input deck. In such cases, it is necessary
to edit and recompile the &lt;strong>EPOCH&lt;/strong> source code. The recommended method
for setting the initial particle properties is to use the
&amp;ldquo;&lt;code>manual_load&lt;/code>&amp;rdquo; function as described in
Section 
&lt;a href="#sec:manualload">4.2&lt;/a>{reference-type=&amp;ldquo;ref&amp;rdquo;
reference=&amp;ldquo;sec:manualload&amp;rdquo;}.&lt;/p>
&lt;h2 id="what-is-a-maths-parser">What is a maths parser?&lt;/h2>
&lt;p>As previously mentioned, the behaviour of &lt;strong>EPOCH&lt;/strong> is controlled using
an input deck which contains a list of key/value pairs. The value part
of the pair is not restricted to simple constants but can be a complex
mathematical expression. It is evaluated at run time using a section of
code called the &amp;ldquo;maths parser&amp;rdquo;. There is no need for the end user to
know anything about this code. It is just there to enable the use of
mathematical expressions in the input deck. Further information about
this facility can be found in
Section 
&lt;a href="#sec:maths_parser">3.18&lt;/a>{reference-type=&amp;ldquo;ref&amp;rdquo;
reference=&amp;ldquo;sec:maths_parser&amp;rdquo;}.&lt;/p>
&lt;h2 id="i-am-an-advanced-user-but-i-want-to-set-up-the-code-so-that-less-experienced-users-can-use-it" class="-how-do-i-do-that">I am an advanced user, but I want to set up the code so that less experienced users can use it. How do I do that?&lt;/h2>
&lt;p>See &amp;quot;&amp;quot; (Section 
&lt;a href="#sec:customising">4.6&lt;/a>{reference-type=&amp;ldquo;ref&amp;rdquo;
reference=&amp;ldquo;sec:customising&amp;rdquo;}).&lt;/p>
&lt;h2 id="i-want-to-develop-an-addition-to-epoch" class="-how-do-i-do-that">I want to develop an addition to &lt;strong>EPOCH&lt;/strong>. How do I do that?&lt;/h2>
&lt;p>A slightly outdated developers manual exists which should be sufficient
to cover most aspects of the code functionality. However, the code is
written in a fairly modular and consistent manner, so reading through
that is the best source of information. If you get stuck then you can
post questions on the CCPForge forums.&lt;/p>
&lt;h2 id="i-want-to-have-a-full-understanding-of-how-epoch-works" class="-how-do-i-do-that">I want to have a full understanding of how &lt;strong>EPOCH&lt;/strong> works. How do I do that?&lt;/h2>
&lt;p>If you really want to understand &lt;strong>EPOCH&lt;/strong> in full, the only way is to
read all of this manual and then read through the code. Most of it is
commented.&lt;/p>
&lt;h2 id="how-do-i-acknowledge-use-of-the-code">How do I acknowledge use of the code?&lt;/h2>
&lt;p>See [here][Acknowledging_EPOCH].&lt;/p>
&lt;h2 id="next-section">Next Section&lt;/h2>
&lt;p>[The structure of the EPOCH codes][Structure]&lt;/p></description></item><item><title/><link>/tutorial/formattingexamples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/formattingexamples/</guid><description>&lt;p>Set the page title&lt;/p>
&lt;pre>&lt;code>{{DISPLAYTITLE: EPOCH Page Formatting}}
&lt;/code>&lt;/pre>
&lt;p>Note: Convert from .tex using pandoc -t mediawiki&lt;/p>
&lt;h1 id="versioning_restrictions">Versioning restrictions&lt;/h1>
&lt;p>There are a few versioning templates to easily flag things when they
appear or disappear&lt;/p>
&lt;pre>&lt;code>{{VersionBox| 0.0}}
&lt;/code>&lt;/pre>
&lt;p>A box to head up a page etc&lt;/p>
&lt;pre>&lt;code>{{VersionedBullet|4.11| Bullet text}} - Rest of text here
&lt;/code>&lt;/pre>
&lt;p>- Rest of text here&lt;/p>
&lt;p>Include an &amp;lsquo;=&amp;rsquo; sign inside a template: explicitly number the template
arguments&lt;/p>
&lt;pre>&lt;code>{{VersionedBullet|4.11| 2= Part of text = other text}} - Rest of text here
&lt;/code>&lt;/pre>
&lt;p>- Rest of text here&lt;/p>
&lt;pre>&lt;code>{{DeprecatedBox|4.12|
* Bullet text - Some long description of the bullet goes here and can run to multiple lines as always, and can continue for as long as I want to type eh}}
{{VersionFillBox|4.12|
* Bullet text - Some long description of the bullet goes here and can run to multiple lines as always, and can continue for as long as I want to type eh}}
&lt;/code>&lt;/pre>
&lt;h3 id="subsection_here">Subsection here&lt;/h3>
&lt;pre>&lt;code>{{VersionSectionBox|4.12}}
&lt;/code>&lt;/pre>
&lt;h1 id="syntax_highlighted_code">Syntax highlighted code&lt;/h1>
&lt;p>Deck blocks can be coloured&lt;/p>
&lt;pre>&lt;code>&amp;lt;syntaxhighlight lang=&amp;quot;deck&amp;quot;&amp;gt;
begin:control
# Global number of gridpoints
nx = 512 # in x
ny = 512 # in y
# Global number of particles
npart = 10 * nx * ny
end:control
&amp;lt;/syntaxhighlight&amp;gt;
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-perl">begin:control
# Global number of gridpoints
nx = 512 # in x
ny = 512 # in y
# Global number of particles
npart = 10 * nx * ny
end:control
&lt;/code>&lt;/pre>
&lt;p>So can Fortran Code snippets although fancier stuff doesn&amp;rsquo;t quite work&lt;/p>
&lt;pre>&lt;code>&amp;lt;syntaxhighlight lang=&amp;quot;fortran&amp;quot;&amp;gt;
TYPE particle
REAL(num), DIMENSION(3) :: part_p
REAL(num) :: part_pos
#ifdef PER_PARTICLE_CHARGE_MASS
REAL(num) :: charge
REAL(num) :: mass
#endif
TYPE(particle), POINTER :: next, prev
#ifdef PARTICLE_DEBUG
INTEGER :: processor
INTEGER :: processor_at_t0
#endif
END TYPE particle
&amp;lt;/syntaxhighlight&amp;gt;
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-fortran"> TYPE particle
REAL(num), DIMENSION(3) :: part_p
REAL(num) :: part_pos
#ifdef PER_PARTICLE_CHARGE_MASS
REAL(num) :: charge
REAL(num) :: mass
#endif
TYPE(particle), POINTER :: next, prev
#ifdef PARTICLE_DEBUG
INTEGER :: processor
INTEGER :: processor_at_t0
#endif
END TYPE particle
&lt;/code>&lt;/pre>
&lt;h1 id="references">References&lt;/h1>
&lt;p>Inline references are created as&lt;/p>
&lt;pre>&lt;code> &amp;lt;ref name=&amp;quot;Bloggs&amp;quot;&amp;gt; J. Bloggs, &amp;quot;The Chicken Paper&amp;quot;, The Journal of Chickens, page 10, 2017[http://link]&amp;lt;/ref&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>and get dumped at the bottom of the page. It&amp;rsquo;s better to include them
explicitly using&lt;/p>
&lt;pre>&lt;code>===References===
&amp;lt;references /&amp;gt;
&lt;/code>&lt;/pre>
&lt;h3 id="references_1">References&lt;/h3>
&lt;p>&lt;references />&lt;/p>
&lt;h1 id="figures">Figures&lt;/h1>
&lt;p>Figures are best included as thumbnails such as&lt;/p>
&lt;pre>&lt;code>[[File:Two Stream Late.png|right|200px|thumb|Caption]]
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="/tutorial/img/Two_Stream_Late.png" alt="Caption">&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>J. Bloggs, &amp;ldquo;The Chicken Paper&amp;rdquo;, The Journal of Chickens, page
10, 2017
&lt;a href="http://link" target="_blank" rel="noopener">1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title/><link>/tutorial/hrtest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/hrtest/</guid><description>&lt;div class="mw-collapsible mw-collapsed" style="border-style: solid; border-width: 2px; border-color:#0059A1">
&lt;p>Or click &amp;ldquo;Expand&amp;rdquo; and copy this text into a file &amp;ldquo;input.deck&amp;rdquo; in
your Data directory:&lt;/p>
&lt;div class="mw-collapsible-content">
&lt;p>Hallo&lt;/p>
&lt;/div>
&lt;/div></description></item><item><title/><link>/tutorial/input_deck/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck/</guid><description>&lt;p>Most of the control of EPOCH is through a text file called &lt;code>input.deck&lt;/code>.
The input deck file must be in the output directory which is passed to
the code at runtime and contains all the basic information which is
needed to set up the code, including the size and subdivision of the
domain, the boundary conditions, the species of particles to simulate
and the output settings for the code. For most users this will be
capable of specifying all the initial conditions and output options they
need. More complicated initial conditions will be handled in later
sections.&lt;/p>
&lt;p>The input deck is a structured file which is split into separate blocks,
with each block containing several &amp;ldquo;parameter&amp;rdquo; = &amp;ldquo;value&amp;rdquo; pairs. The
pairs can be present in any order, and not all possible pairs must be
present in any given input deck. If a required pair is missing the code
will exit with an error message. The blocks themselves can also appear
in any order. The input deck is case sensitive, so true is always &amp;ldquo;T&amp;rdquo;,
false is always &amp;ldquo;F&amp;rdquo; and the names of the parameters are always lower
case. Parameter values are evaluated using a maths parser which is
described in [EPOCH maths parser][maths_parser].&lt;br>
If the deck contains a &amp;ldquo;&lt;code>\&lt;/code>&amp;rdquo; character then the rest of the line is
ignored and the next line becomes a continuation of the current one.
Also, the comment character is &amp;ldquo;&lt;code>#&lt;/code>&amp;quot;; if the &amp;ldquo;&lt;code>#&lt;/code>&amp;rdquo; character is used
anywhere on a line then the remainder of that line is ignored.&lt;br>
There are three &lt;em>&lt;code>input deck directive&lt;/code>&lt;/em> commands, which are:&lt;/p>
&lt;ul>
&lt;li>begin:&lt;em>&lt;code>block&lt;/code>&lt;/em> - Begin the block named
&lt;em>&lt;code>block&lt;/code>&lt;/em>.&lt;/li>
&lt;li>end:&lt;em>&lt;code>block&lt;/code>&lt;/em> - Ends the block named
&lt;em>&lt;code>block&lt;/code>&lt;/em>.&lt;/li>
&lt;li>import:&lt;em>&lt;code>filename&lt;/code>&lt;/em> - Includes another file (called
&lt;em>&lt;code>filename&lt;/code>&lt;/em>) into the input deck at the point where the
directive is encountered. The input deck parser reads the included
file exactly as if the contents of the included file were pasted
directly at the position of the import directive.&lt;/li>
&lt;/ul>
&lt;p>Each block must be surrounded by valid &lt;em>&lt;code>begin:&lt;/code>&lt;/em> and
&lt;em>&lt;code>end:&lt;/code>&lt;/em> directives or the input deck will fail. There are
currently fourteen valid blocks hard coded into the input deck reader,
but it is possible for end users to extend the input deck. The fourteen
built in blocks are:&lt;/p>
&lt;ul>
&lt;li>control - Contains information about the general code setup. See
&lt;a href="/tutorial/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>boundaries - Contains information about the boundary conditions for
this run. See
&lt;a href="/tutorial/input_deck_boundaries">here&lt;/a>&lt;/li>
&lt;li>species - Contains information about the species of particles which
are used in the code. Also details of how these are initialised. See
&lt;a href="/tutorial/input_deck_species">here&lt;/a>&lt;/li>
&lt;li>laser - Contains information about laser boundary sources. See
&lt;a href="/tutorial/input_deck_laser">here&lt;/a>.&lt;/li>
&lt;li>fields - Contains information about the EM fields specified at the
start of the simulation. See
&lt;a href="/tutorial/input_deck_fields">here&lt;/a>.&lt;/li>
&lt;li>particles_from_file - Contains information about files used to
load particle data. See
&lt;a href="/tutorial/input_deck_particle_file">here&lt;/a>.&lt;/li>
&lt;li>window - Contains information about the moving window if the code is
used in that fashion. See
&lt;a href="/tutorial/input_deck_window">here&lt;/a>.&lt;/li>
&lt;li>output - Contains information about when and how to dump output
files. See
&lt;a href="/tutorial/input_deck_output_block">here&lt;/a>.&lt;/li>
&lt;li>output_global - Contains parameters which should be applied to all
output blocks. See
&lt;a href="/tutorial/input_deck_output_global">here&lt;/a>.&lt;/li>
&lt;li>dist_fn - Contains information about distribution functions that
should be calculated for output. See
&lt;a href="/tutorial/input_deck_dist_fn">here&lt;/a>.&lt;/li>
&lt;li>probe - Contains information about particle probes used for output.
See
&lt;a href="/tutorial/input_deck_probe">here&lt;/a>.&lt;/li>
&lt;li>collisions - Contains information about particle collisions. See
&lt;a href="/tutorial/input_deck_collisions">here&lt;/a>.&lt;/li>
&lt;li>qed - Contains information about QED pair production. See
&lt;a href="/tutorial/input_deck_qed">here&lt;/a>.&lt;/li>
&lt;li>subset - Contains configuration for filters which can be used to
modify the data to be output. See
&lt;a href="/tutorial/input_deck_subset">here&lt;/a>.&lt;/li>
&lt;li>constant - Contains information about user defined constants and
expressions. These are designed to simplify the initial condition
setup. See
&lt;a href="/tutorial/input_deck_constant">here&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_control">The control block&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_adf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_adf/</guid><description>&lt;p>The ADF is a generalisation of EPOCH&amp;rsquo;s classic distribution functions
but using
&lt;a href="/tutorial/calculable_particle_properties">calculable particle
properties&lt;/a> to specify
the axes of the distribution function and the value accumulated on the
grid for that distribution function.&lt;/p>
&lt;h1 id="example_deck_block">Example deck block&lt;/h1>
&lt;pre>&lt;code class="language-perl">begin:adf
name= x_px_df
height = dir_n
accumulate_mode = sum
direction=(dir_x, dir_px)
resolution = (null, 100)
range = ((0,1), (0,2e-22))
use_weight = T
use_shapes = T
end:adf
&lt;/code>&lt;/pre>
&lt;h1 id="name">Name&lt;/h1>
&lt;p>The ADF must be named so that it can be referred to in pipeline blocks&lt;/p>
&lt;h1 id="height">Height&lt;/h1>
&lt;p>The &amp;ldquo;height&amp;rdquo; key is a calculable particle property that should be
accumulated on the grid&lt;/p>
&lt;h1 id="accumulate_mode">Accumulate mode&lt;/h1>
&lt;p>The &amp;ldquo;accumulate_mode&amp;rdquo; key is how the height should be accumulated on
the grid. Options are&lt;/p>
&lt;ul>
&lt;li>sum - Sum the value on the grid&lt;/li>
&lt;li>average - Calculate the average value of the height in each cell&lt;/li>
&lt;li>temperature - Ignore the height value and calculate the temperature
in each cell&lt;/li>
&lt;/ul>
&lt;p>If this key is absent then sum is assumed&lt;/p>
&lt;h1 id="direction">Direction&lt;/h1>
&lt;p>The &amp;ldquo;direction&amp;rdquo; key specifies the calculable particle property for
each axis of the distribution function. You may specify up to 6 axes,
specifications for resolutions and ranges must be of the same length as
the direction specification&lt;/p>
&lt;h1 id="resolution">Resolution&lt;/h1>
&lt;p>The &amp;ldquo;resolution&amp;rdquo; key specifies the desired resolution for each axis of
the distribution function. The number of keys must match the number of
directions specified. The resolution is ignored for spatial dimensions
(but not resampled spatial dimensions) which must match the base grid
resolution&lt;/p>
&lt;h1 id="range">Range&lt;/h1>
&lt;p>The &amp;ldquo;range&amp;rdquo; key is a list of (lower_bound, upper_bound) pairs for
each axis of the ADF. There must be as many pairs as there are
directions. If this key is missing then the range is calculated at each
output to contain all particles in the source for the ADF&lt;/p>
&lt;h1 id="use_weight">Use weight&lt;/h1>
&lt;p>The &amp;ldquo;use_weight&amp;rdquo; keyword is used to specify whether or not the
particle weight should be used when accumulating the data for the ADF.
For &amp;ldquo;height=dir_n&amp;rdquo; this key being F means that you are calculating
the number of simulation particles in each cell of the ADF. It&amp;rsquo;s
meaning is less clear for other accumulated heights. If this key is not
specified it is assumed to be T&lt;/p>
&lt;h1 id="use_shape_function">Use shape function&lt;/h1>
&lt;p>The &amp;ldquo;use_shape&amp;rdquo; keyword specified whether or not to use the shape
function when calculating spatial axes for distribution functions. If F
then all of a particle&amp;rsquo;s property is deposited in the cell which
contain the particle&amp;rsquo;s centre. This is comparable to the method used by
the EPOCH legacy distribution functions.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_antenna/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_antenna/</guid><description>&lt;p>Antennae allow you to specify currents in the simulation domain that are
added to the self consistent currents from the core solver. You can
either specify the currents entirely manually or you can specify a
frequency and a profile for each current component. You can have as many
antennae as you want by specifying multiple antenna blocks.&lt;/p>
&lt;h1 id="example_deck">Example Deck&lt;/h1>
&lt;pre>&lt;code class="language-perl">begin:antenna
jx = if (r_xy lt micron, 1.0e-5, 0.0)
jy = if (r_xy lt micron, 1.0e-5, 0.0)
jz = if (r_xy lt micron, 1.0e-5, 0.0)
ranges = ((-micron, micron), (-micron, micron))
omega = 1.0e15
start_time = start
stop_time = end
end:antenna
&lt;/code>&lt;/pre>
&lt;h1 id="keys">Keys&lt;/h1>
&lt;ul>
&lt;li>jx - Profile for current in x direction. If you do not specify the
omega key then you should include any time dependence manually. If
the omega key is specified any time variation in jx will be
multiplicatively combined with the sinusoidal variation from omega.
Can be time and space varying.&lt;/li>
&lt;li>jy - Profile for current in y direction. If you do not specify the
omega key then you should include any time dependence manually. If
the omega key is specified any time variation in jy will be
multiplicatively combined with the sinusoidal variation from omega.
Can be time and space varying.&lt;/li>
&lt;li>jz - Profile for current in z direction. If you do not specify the
omega key then you should include any time dependence manually. If
the omega key is specified any time variation in jz will be
multiplicatively combined with the sinusoidal variation from omega.
Can be time and space varying.&lt;/li>
&lt;li>ranges - Array of (min,max) pairs for each dimension of your
simulation (1 pair for EPOCH1d, 2 pairs for EPOCH2D and 3 pairs for
EPOCH3D) showing the domain over which the antenna should operate.
Describes the region of space over which the current from the
antenna should be applied. The fields generated by that current will
propagate everywhere in the simulation domain. If ranges is not
present then the antenna will be applied to the whole domain.
Performance of the antenna block will be highest if you set the
smallest range possible.&lt;/li>
&lt;li>omega - Optional frequency for the antenna. If this key is set then
the current will vary sinusoidally with the specified frequency.
This is faster to run than specifying a sinusoidal profile in the
jx, jy or jz keys but performs the same (for a frequency that
doesn&amp;rsquo;t change in time, see Time variability section). Can be time
varying, but not space varying&lt;/li>
&lt;li>start_time - Time after which to start applying the antenna
currents. Can be &amp;ldquo;start&amp;rdquo; to apply from the start of the
simulation. If key is not present antenna runs from the start of the
simulation.&lt;/li>
&lt;li>stop_time - Time after which to cease applying the antenna
currents. Can be &amp;ldquo;end&amp;rdquo; to apply until the end of the simulation.
If key is not present antenna runs until the end of the simulation.&lt;/li>
&lt;/ul>
&lt;h1 id="time_variability">Time variability&lt;/h1>
&lt;p>When you specify time variation for the jx, jy or jz keys this specifies
the &lt;strong>instantaneous&lt;/strong> current to be applied at each moment in time.&lt;/p>
&lt;p>When you specify time variation in the omega key this specifies the
frequency at this time, but this is applied to the phase state of the
antenna as an integral. So the sinusoid that is applied to the current
is $\sin\Bigl(\int_0^t\omega(t')dt'\Bigr)$. For constant $\omega$ this
reduces to $\sin(\omega t)$. This gives the correct behaviour for
chirped antennae&lt;/p>
&lt;h1 id="example_deck_1">Example deck&lt;/h1>
&lt;p>An example deck for this block can be found in
example_decks/antenna.deck. The deck should take 5-20 seconds to run.&lt;/p></description></item><item><title/><link>/tutorial/input_deck_boundaries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_boundaries/</guid><description>&lt;p>This block contains information about the boundary conditions for this
run. See
&lt;a href="/tutorial/input_deck">EPOCH input deck&lt;/a> for more
information on the input deck.&lt;/p>
&lt;h1 id="basics">Basics&lt;/h1>
&lt;p>The &lt;em>&lt;code>boundaries&lt;/code>&lt;/em> block sets the boundary conditions of each
boundary of the domain. Some types of boundaries allow EM wave sources
(lasers) to be attached to a boundary. Lasers are attached at the
initial conditions stage.&lt;/p>
&lt;p>An example boundary block for EPOCH2D is as follows:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:boundaries
bc_x_min = simple_laser
bc_x_max_field = simple_outflow
bc_x_max_particle = simple_outflow
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>boundaries&lt;/code> block accepts the following parameters:\&lt;/p>
&lt;ul>
&lt;li>&lt;code>bc_{x,y,z}_min&lt;/code> - The condition for the lower boundary
for both fields and particles. &amp;ldquo;xbc_left&amp;rdquo;, &amp;ldquo;ybc_down&amp;rdquo; and &amp;ldquo;zbc_back&amp;rdquo;
are accepted as a synonyms.\&lt;/li>
&lt;li>&lt;code>bc_{x,y,z}_min_{field,particle}&lt;/code> - The condition for
the lower boundary for {fields,particles}.
&amp;ldquo;xbc_left_{field,particle}&amp;rdquo;, &amp;ldquo;ybc_down_{field,particle}&amp;rdquo; and
&amp;ldquo;zbc_back_{field,particle}&amp;rdquo; are accepted as a synonyms.\&lt;/li>
&lt;li>&lt;code>bc_{x,y,z}_max&lt;/code> - The condition for the upper boundary
for both fields and particles. &amp;ldquo;xbc_right&amp;rdquo;, &amp;ldquo;ybc_up&amp;rdquo; and &amp;ldquo;zbc_front&amp;rdquo;
are accepted as a synonyms.\&lt;/li>
&lt;li>&lt;code>bc_{x,y,z}_max_{field,particle}&lt;/code> - The condition for
the upper boundary for {fields,particles}.
&amp;ldquo;xbc_right_{field,particle}&amp;rdquo;, &amp;ldquo;ybc_up_{field,particle}&amp;rdquo; and
&amp;ldquo;zbc_front_{field,particle}&amp;rdquo; are accepted as a synonyms.\&lt;/li>
&lt;li>&lt;code>cpml_thickness&lt;/code> - The thickness of the
&lt;a href="#cpml_boundary_conditions">CPML&lt;/a> boundary in terms of the
number of grid cells. The default value is 6.\&lt;/li>
&lt;li>&lt;code>cpml_kappa_max&lt;/code> - A tunable
&lt;a href="#cpml_boundary_conditions">CPML&lt;/a> parameter.\&lt;/li>
&lt;li>&lt;code>cpml_a_max&lt;/code> - A tunable
&lt;a href="#cpml_boundary_conditions">CPML&lt;/a> parameter.\&lt;/li>
&lt;li>&lt;code>cpml_sigma_max&lt;/code> - A tunable
&lt;a href="#cpml_boundary_conditions">CPML&lt;/a> parameter.&lt;br>
There are ten boundary types in EPOCH and each boundary of the domain
can have one and only one of these boundaries attached to it. These
boundary types are:\&lt;/li>
&lt;li>&lt;code>periodic&lt;/code> - A simple periodic boundary condition. Fields
and/or particles reaching one edge of the domain are wrapped round to
the opposite boundary. If either boundary condition is set to periodic
then the boundary condition on the matching boundary at the other side
of the box is also assumed periodic.\&lt;/li>
&lt;li>&lt;code>simple_laser&lt;/code> - A characteristic based boundary condition
to which one or more EM wave sources can be attached. EM waves impinging
on a &lt;em>simple_laser&lt;/em> boundary are transmitted with as little reflection
as possible. Particles are fully transmitted. The field boundary
condition works by allowing outflowing characteristics to propagate
through the boundary while using the attached lasers to specify the
inflowing characteristics. The particles are simply removed from the
simulation when they reach the boundary. See
&lt;a href="/tutorial/input_deck_laser"> laser
blocks&lt;/a> for details.\&lt;/li>
&lt;li>&lt;code>simple_outflow&lt;/code> - A simplified version of &lt;em>simple_laser&lt;/em>
which has the same properties of transmitting incident waves and
particles, but which cannot have EM wave sources attached to it. These
boundaries are about 5% more computationally efficient than
&lt;em>simple_laser boundaries&lt;/em> with no attached sources. This boundary
condition again allows outflowing characteristics to flow unchanged, but
this time the inflowing characteristics are set to zero. The particles
are again simply removed from the simulation when they reach the
boundary.\&lt;/li>
&lt;li>&lt;code>reflect&lt;/code> - This applies reflecting boundary conditions to
particles. When specified for fields, all field components are clamped
to zero.\&lt;/li>
&lt;li>&lt;code>conduct&lt;/code> - This applies perfectly conducting boundary
conditions to the field. When specified for particles, the particles are
reflected.\&lt;/li>
&lt;li>&lt;code>open&lt;/code> - When applied to fields, EM waves outflowing
characteristics propagate through the boundary. Particles are
transmitted through the boundary and removed from the system.\&lt;/li>
&lt;li>&lt;code>cpml_laser&lt;/code> - See
&lt;a href="#cpml_boundary_conditions">#CPML boundary
conditions&lt;/a>.\&lt;/li>
&lt;li>&lt;code>cpml_outflow&lt;/code> - See
&lt;a href="#cpml_boundary_conditions">#CPML boundary
conditions&lt;/a>.\&lt;/li>
&lt;li>&lt;code>thermal&lt;/code> - See
&lt;a href="#thermal_boundaries">#Thermal
boundaries&lt;/a>.\&lt;/li>
&lt;li>&lt;code>**NOTE: If simple_laser, simple_outflow, cpml_laser, cpml_outflow or open are specified on one or more boundaries then the code will no longer necessarily conserve mass.**&lt;/code>&lt;br>
&lt;span style="color:#ff0000">Note also that it is possible for the user
to specify contradictory, unphysical boundary conditions. It is the
users responsibility that these flags are set correctly.`&lt;/li>
&lt;/ul>
&lt;h1 id="cpml_boundary_conditions">CPML boundary conditions&lt;/h1>
&lt;p>There are now Convolutional Perfectly Matched Layer boundary conditions
in EPOCH. The implementation closely follows that outlined in the book
&amp;ldquo;Computational Electrodynamics: The Finite-Difference Time-Domain
Method&amp;rdquo; by Taflove and Hagness&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. See also Roden and Gedney&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>.&lt;/p>
&lt;p>CPML boundaries are specified in the input deck by specifying either
&amp;ldquo;cpml_outflow&amp;rdquo; or &amp;ldquo;cpml_laser&amp;rdquo; in the boundaries block.
&amp;ldquo;cpml_outflow&amp;rdquo; specifies an absorbing boundary condition whereas
&amp;ldquo;cpml_laser&amp;rdquo; is used to attach a laser to an otherwise absorbing
boundary condition.&lt;/p>
&lt;p>There are also four configurable parameters:\&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>cpml_thickness&lt;/code> - The thickness of the CPML boundary in
terms of the number of grid cells. The default value is 6.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>cpml_kappa_max&lt;/code>, &lt;code>cpml_a_max&lt;/code>,
&lt;code>cpml_sigma_max&lt;/code> - These are tunable parameters which
affect the behaviour of the absorbing media. The notation follows that
used in the two references quoted above. Note that the
&amp;ldquo;cpml_sigma_max&amp;rdquo; parameter is normalised by $\sigma_{\rm opt}$ which
is taken to be 3.2/dx (see Taflove and Hagness&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> for details). These
are real valued parameters which take the following default values:
cpml_kappa_max=20, cpml_a_max=0.15, cpml_sigma_max=0.7&lt;br>
An example usage is as follows:&lt;/p>
&lt;p>begin:boundaries
cpml_thickness = 16
cpml_kappa_max = 20
cpml_a_max = 0.2
cpml_sigma_max = 0.7
bc_x_min = cpml_laser
bc_x_max = cpml_outflow
bc_y_min = cpml_outflow
bc_y_max = cpml_outflow
end:boundaries&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="thermal_boundaries">Thermal boundaries&lt;/h1>
&lt;p>Thermal boundary conditions have been added to the &amp;ldquo;boundaries&amp;rdquo; block.
These simulate the existence of a &amp;ldquo;thermal bath&amp;rdquo; of particles in the
domain adjacent to the boundary. When a particle leaves the simulation
it is replace with an incoming particle sampled from a Maxwellian of a
temperature corresponding to that of the initial conditions. It is
requested using the keyword &amp;ldquo;thermal&amp;rdquo;. For example:&lt;/p>
&lt;pre>&lt;code>begin:boundaries
bc_x_min = laser
bc_x_max = thermal
end:boundaries
&lt;/code>&lt;/pre>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_species">The species block&lt;/a>&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>A. Taflove and S. C. Hagness, Computational Electrodynamics: The
Finite-Difference Time-Domain Method. Artech House,
2000.
&lt;a href="https://www.researchgate.net/publication/202924435_Computational_Electrodynamics_The_Finite-Difference_Time-Domain_Method" target="_blank" rel="noopener">1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>J. Roden and S. Gedney, &amp;ldquo;Convolution pml (cpml): An efficient fdtd
implementation of the cfs-pml for arbitrary media,&amp;rdquo; Microw. Opt.
Technol. Lett.,
2000.
&lt;a href="https://www.researchgate.net/publication/228078114_Convolutional_PML_CPML_an_efficient_FDTD_implementation_of_the_CFS-PML_for_arbitrary_media" target="_blank" rel="noopener">2&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title/><link>/tutorial/input_deck_collisions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_collisions/</guid><description>&lt;p>This block contains information about particle collisions. See
&lt;a href="/tutorial/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;p>EPOCH has a particle collision routine with scattering algorithms based
on the model presented by Sentoku and Kemp&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> or the model presented by
Pérez et al &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>, which in turn was based on the work of Nanbu and
Yonemura&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>. This adds a new output block named &amp;ldquo;collisions&amp;rdquo; which
accepts the following four parameters.\&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>use_collisions&lt;/code> - This is a logical flag which determines
whether or not to call the collision routine. If omitted, the default is
&amp;ldquo;T&amp;rdquo; if any of the frequency factors are non-zero (see below) and &amp;ldquo;F&amp;rdquo;
otherwise.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>This logical flag determines whether the scattering angle of
Pérez/Nanbu will be used. The default is &amp;ldquo;T&amp;rdquo;. If &amp;ldquo;F&amp;rdquo;, the
Sentoku-Kemp algorithm will be used.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>coulomb_log&lt;/code> - This may either be set to a real value,
specifying the Coulomb logarithm to use when scattering the
particles or to the special value &amp;ldquo;auto&amp;rdquo;. If &amp;ldquo;auto&amp;rdquo; is used then the
routine will calculate a value based on the local temperature and
density of the particle species being scattered, along with the two
particle charges. If omitted, the default value is &amp;ldquo;auto&amp;rdquo;.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>collide&lt;/code> - This sets up a symmetric square matrix of
size $nspecies,\times,nspecies$ containing the collision frequency
factors to use between particle species. The element (s1,s2) gives
the frequency factor used when colliding species s1 with species s2.
If the factor is less than zero, no collisions are performed. If it
is equal to one, collisions are performed normally. For any value
between zero and one, the collisions are performed using a frequency
multiplied by the given factor.\&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>If &amp;ldquo;collide&amp;rdquo; has a value of &amp;ldquo;all&amp;rdquo; then all elements of the matrix are
set to one. If it has a value of &amp;ldquo;none&amp;rdquo; then all elements are set to
minus one.&lt;br>
If the syntax &amp;ldquo;species1 species2 &lt;value>&amp;rdquo; is used, then the
(species1,species2) element of the matrix is set to the factor
&amp;ldquo;&lt;value>&amp;rdquo;. This may either be a real number, or the special value &amp;ldquo;on&amp;rdquo;
or &amp;ldquo;off&amp;rdquo;. The &amp;ldquo;collide&amp;rdquo; parameter may be used multiple times.&lt;br>
The default value is &amp;ldquo;all&amp;rdquo; (ie. all elements of the matrix are set to
one).\&lt;/p>
&lt;ul>
&lt;li>&lt;code>collisional_ionisation&lt;/code> - If this logical flag is set to
&amp;ldquo;T&amp;rdquo; then the collisional ionisation model is enabled. This process is
independent of &lt;em>field_ionisation&lt;/em> (see
&lt;a href="/tutorial/input_deck_species/#ionisation">here&lt;/a>). However, in
order to set up &lt;em>collisional_ionisation&lt;/em> you must also specify
ionisation energies and electrons in a &lt;em>species&lt;/em> block (see
&lt;a href="/tutorial/input_deck_species/#ionisation">here&lt;/a>). The default
value is &amp;ldquo;F&amp;rdquo;.&lt;br>
For example:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-perl">begin:collisions
use_collisions = T
use_nanbu = T
coulomb_log = auto
collide = all
collide = spec1 spec2 off
collide = spec2 spec3 0.1
end:collisions
&lt;/code>&lt;/pre>
&lt;p>With this block, collisions are turned on, the Nanbu-Pérez scattering
algorithm is used and the Coulomb logarithm is automatically calculated.
All values of the frequency array are set to one except (spec1,spec2) is
set to minus one (and also (spec2,spec1)) and (spec2,spec3) is set to
0.1&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_qed">The qed block&lt;/a>&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Y. Sentoku and A. J. Kemp, &amp;ldquo;Numerical methods for particle
simulations at extreme densities and temperatures: Weighted
particles, relativistic collisions and reduced currents,&amp;rdquo; J. Comput.
Phys., 2008.
&lt;a href="http://www.sciencedirect.com/science/article/pii/S0021999108001988" target="_blank" rel="noopener">1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>F. Pérez et al, &amp;ldquo;Improved modeling of relativistic collisions and
collisional ionization in particle-in-cell codes ,&amp;rdquo; Physics of
Plasmas, 2012.
&lt;a href="https://doi.org/10.1063/1.4742167" target="_blank" rel="noopener">2&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>K. Nanbu and S. Yonemura, &amp;ldquo;Weighted Particles in Coulomb Collision
Simulations Based on the Theory of a Cumulative Scattering Angle,&amp;rdquo;
J. Comput. Phys., 1998.
&lt;a href="https://doi.org/10.1006/jcph.1998.6049" target="_blank" rel="noopener">3&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title/><link>/tutorial/input_deck_constant/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_constant/</guid><description>&lt;p>This block contains information about user defined constants and
expressions. These are designed to simplify the initial condition setup.
See
&lt;a href="/tutorial/input_deck">EPOCH input deck&lt;/a> for more information
on the input deck.&lt;/p>
&lt;p>The &lt;em>constant&lt;/em> block type helps to make the input deck more flexible and
maintainable. It allows you to define constants and maths parser
expressions (see [EPOCH maths parser][maths_parser])
which can be used by name later in the deck.&lt;br>
Constants are simply maths parser expressions which are assigned to a
name as shown above. When the name is used on the right hand side of a
deck expression it is replaced by the expression it was assigned with.
This expression may be a simple numerical constant, a mathematical
expression or a function. Constants may contain spatially varying
information without having to pre-calculate them at every location in
the domain. To those familiar with FORTRAN codes which use statement
functions, parameters appearing in the &amp;ldquo;constant&amp;rdquo; block are fairly
similar.&lt;br>
If a constant name is reused in a constant block then the old constant
is deleted and replaced with the new one. This happens without warning.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
lambda = 1.06 * micron
omega = 2.0 * pi * c / lambda
den_crit = critical(omega)
scale = 3.5 * micron
den_max = 5.0 * den_crit
thick = 300e-9
pplength = 6000e-9
widscale = 5.0e-6
t_wid = (10.0e-6) / c
amax = 1.0
wy = 1e-6
y = 0.0
slope = exp(-2.0 * (y/wy)^2)
blob = gauss(sqrt(x^2 + y^2), 0.0, 1.0e-6)
end:constant
&lt;/code>&lt;/pre>
&lt;p>Using constants can be very helpful when dealing with long, complicated
expressions since they allow the expression to be broken down into much
simpler parts. They can also be used to get around the FORTRAN string
length limitation built into many compilers which prevents deck lines
being longer then 512 characters long. As a general rule, it is a good
idea to break down complicated expressions using constants or by other
means, in order to make the deck look more readable.&lt;br>
Constants are persistent for the entire runtime of the code, allowing
them to be used when specifying time profiles for lasers, and also
allowing developers to use maths parser expressions for other internal
parts of the code where needed.&lt;br>
In the above example, several pre-defined constants have been used (&lt;em>pi&lt;/em>
and &lt;em>c&lt;/em>) and also several functions (&lt;em>critical&lt;/em>, &lt;em>exp&lt;/em>, &lt;em>gauss&lt;/em> and
&lt;em>sqrt&lt;/em>). These are described
[here][maths_parser__constants] and
&lt;a href="/tutorial/maths_parser/#functions">here&lt;/a>.&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>[The maths parser][maths_parser]&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_control/</guid><description>&lt;p>The &lt;em>control&lt;/em> block contains information about the general code setup.
See
&lt;a href="/tutorial/input_deck">EPOCH input deck&lt;/a> for more information
on the input deck.&lt;/p>
&lt;h1 id="basics">Basics&lt;/h1>
&lt;p>The block sets up the basic code properties for the domain, the end time
of the code, the load balancer and the types of initial conditions to
use.&lt;/p>
&lt;p>The control block of a valid input deck for EPOCH2D reads as follows:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:control
# Global number of gridpoints
nx = 512 # in x
ny = 512 # in y
# Global number of particles
npart = 10 * nx * ny
# Final time of simulation
t_end = 1.0e-12
# nsteps = -1
# Size of domain
x_min = -0.1e-6
x_max = 400.0e-6
y_min = -400.0e-6
y_max = 400.0e-6
# dt_multiplier = 0.95
# dlb_threshold = 0.8
# restart_snapshot = 98
# field_order = 2
# maxwell_solver = yee
# stdout_frequency = 10
end:control
&lt;/code>&lt;/pre>
&lt;p>As illustrated in the above code block, the &amp;ldquo;&lt;code>#&lt;/code>&amp;rdquo; symbol is
treated as a comment character and the code ignores everything on a line
following this character.&lt;br>
The allowed entries are as follows:\&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>nx, ny, nz&lt;/code> - Number of grid points in the x,y,z
direction. This parameter is mandatory.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>npart&lt;/code> - The global number of pseudoparticles in the
simulation. This parameter does not need to be given if a specific
number of particles is supplied for each particle species by using the
&amp;ldquo;npart&amp;rdquo; directive in each [&lt;strong>species&lt;/strong> block
][_input_deck_species]. If both are given then the
value in the &lt;strong>control&lt;/strong> block will be ignored.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>nsteps&lt;/code> - The number of iterations of the core solver
before the code terminates. Negative numbers instruct the code to only
terminate at &lt;strong>t_end&lt;/strong>. If &lt;strong>nsteps&lt;/strong> is not specified then &lt;strong>t_end&lt;/strong>
must be given.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>t_end&lt;/code> - The final simulation time in simulation seconds
before the code terminates. If &lt;strong>t_end&lt;/strong> is not specified then
&lt;strong>nsteps&lt;/strong> must be given. If they are both specified then the first time
restriction to be satisfied takes precedence. Sometimes it is more
useful to specify the time in picoseconds or femtoseconds. To accomplish
this, just append the appropriate multiplication factor. For example,
&amp;ldquo;t_end = 3 * femto&amp;rdquo; specifies 3 femtoseconds. A list of multiplication
factors is supplied
&lt;a href="/tutorial/maths_parser/#constants">here&lt;/a>.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{x,y,z}_min&lt;/code> - Minimum grid position of the domain in
metres. These are required parameters. Can be negative. &amp;ldquo;{x,y,z}_start&amp;rdquo;
is accepted as a synonym. In a similar manner to that described above,
distances can be specified in microns using a multiplication constant.
eg. &amp;ldquo;x_min = 4 * micron&amp;rdquo; specifies a distance of 4 μm.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{x,y,z}_max&lt;/code> - Maximum grid position of the domain in
metres. These are required parameters. Must be greater than
&lt;em>{x,y,z}_min&lt;/em>. &amp;ldquo;{x,y,z}_end&amp;rdquo; is accepted as a synonym.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dt_multiplier&lt;/code> - Factor by which the timestep is
multiplied before it is applied in the code, i.e. a multiplying factor
applied to the CFL condition on the timestep. Must be less than one. If
no value is given then the default of 0.95 is used. If maxwell_solver
is different from &amp;ldquo;yee&amp;rdquo; (the default) this parameter becomes
increasingly relevant.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dlb_threshold&lt;/code> - The minimum ratio of the load on the
least loaded processor to that on the most loaded processor allowed
before the code load balances. Set to 1 means always balance, set to 0
means never balance. If this parameter is not specified then the code
will only be load balanced at initialisation time.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>restart_snapshot&lt;/code> - The number of a previously written
restart dump to restart the code from. If not specified then the initial
conditions from the input deck are used.&lt;br>
Note that as of version 4.2.5, this parameter can now also accept a
filename in place of a number. If you want to restart from &amp;ldquo;0012.sdf&amp;rdquo;
then it can either be specified using &amp;ldquo;restart_snapshot = 12&amp;rdquo;, or
alternatively it can be specified using &amp;ldquo;restart_snapshot = 0012.sdf&amp;rdquo;.
This syntax is required if output file prefixes have been used (see the
&lt;a href="/tutorial/input_deck_output_block">output block&lt;/a> page).\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>field_order&lt;/code> - Order of the finite difference scheme used
for solving Maxwell&amp;rsquo;s equations. Can be 2, 4 or 6. If not specified, the
default is to use a second order scheme.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Choose a Maxwell solver scheme with an extended stencil. This option
is only active if field_order is set to 2. Possible options are &amp;ldquo;yee&amp;rdquo;,
&amp;ldquo;lehe_{x,y,z}&amp;rdquo;, &amp;ldquo;pukhov&amp;rdquo;, &amp;ldquo;cowan&amp;rdquo; and since v4.12 &amp;ldquo;custom&amp;rdquo;. Note that
not all options are available in 1d and 2d. The default is &amp;ldquo;yee&amp;rdquo; which
is the default second order scheme.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stdout_frequency&lt;/code> - If specified then the code will print
a one line status message to stdout after every given number or
timesteps. The default is to print nothing to screen (i.e.
&lt;strong>stdout_frequency = 0&lt;/strong>).\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_random_seed&lt;/code> - The initial particle distribution is
generated using a random number generator. By default, EPOCH uses a
fixed value for the random generator seed so that results are
repeatable. If this flag is set to &amp;ldquo;T&amp;rdquo; then the seed will be generated
using the system clock.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>nproc{x,y,z}&lt;/code> - Number of processes in the &lt;em>x,y,z&lt;/em>
directions. By default, EPOCH will try to pick the best method of
splitting the domain amongst the available processors but occasionally
the user may wish to override this choice.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>smooth_currents&lt;/code> - This is a logical flag. If set to &amp;ldquo;T&amp;rdquo;
then a smoothing function is applied to the current generated during the
particle push. This can help to reduce noise and self-heating in a
simulation. The smoothing function used is the same as that outlined in
Buneman &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. The default value is &amp;ldquo;F&amp;rdquo;.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>field_ionisation&lt;/code> - Logical flag which turns on field
ionisation. See [here][_input_deck_species__ionisation]
.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_bsi&lt;/code> - Logical flag which turns on barrier
suppression ionisation correction to the tunnelling ionisation model for
high intensity lasers. See
[here][_input_deck_species__ionisation] . This flag
should always be enabled when using field ionisation and is only
supplied for testing purposes. The default is &amp;ldquo;T&amp;rdquo;.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_multiphoton&lt;/code> - Logical flag which turns on modelling
ionisation by multiple photon absorption. This should be set to &amp;ldquo;F&amp;rdquo; if
there is no laser attached to a boundary as it relies on laser
frequency. See [here][_input_deck_species__ionisation].
This flag should always be enabled when using field ionisation and is
only supplied for testing purposes. The default is &amp;ldquo;T&amp;rdquo;.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>particle_tstart&lt;/code> - Specifies the time at which to start
pushing particles. This allows the field to evolve using the Maxwell
solver for a specified time before beginning to move the particles.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_exact_restart&lt;/code> - Logical flag which makes a
simulation restart as close as is numerically possible to if the
simulation had not been stopped and restarted. Without this flag set to
T then the simulation will still give a correct result after restart, it
is simply not guaranteed to be identical to if the code had not been
restarted. This flag is mainly intended for testing purposes and is not
normally needed for physical simulations. If set to &amp;ldquo;T&amp;rdquo; then the domain
split amongst processors will be identical along with the seeds for the
random number generators. Note that the flag will be ignored if the
number of processors does not match that used in the original run. The
default value is &amp;ldquo;F&amp;rdquo;.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_current_correction&lt;/code> - Logical flag to specify
whether EPOCH should correct for residual DC current in the initial
conditions. If set to true, the DC current in the initial conditions is
calculated and is subtracted from all subsequent current depositions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>allow_cpu_reduce&lt;/code> - Logical flag which allows the
number of CPUs used to be reduced from the number specified. In some
situations it may not be possible to divide the simulation amongst
all the processors requested. If this flag is set to &amp;ldquo;T&amp;rdquo; then EPOCH
will continue to run and leave some of the requested CPUs idle. If
set to &amp;ldquo;F&amp;rdquo; then code will exit if all CPUs cannot be utilised. The
default value is &amp;ldquo;T&amp;rdquo;.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>check_stop_file_frequency&lt;/code> - Integer parameter
controlling automatic halting of the code. The frequency is
specified as number of simulation cycles. Refer to description later
in this section. The default value is 10.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stop_at_walltime&lt;/code> - Floating point parameter
controlling automatic halting of the code. Refer to description
later in this section. The default value is -1.0.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stop_at_walltime_file&lt;/code> - String parameter controlling
automatic halting of the code. See
&lt;a href="#automatic_halting_of_a_simulation">below&lt;/a>. The default
value is an empty string.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>simplify_deck&lt;/code> - If this logical flag is set to &amp;ldquo;T&amp;rdquo;
then the deck parser will attempt to simplify the maths expressions
encountered after the first pass. This can significantly improve the
speed of evaluation for some input deck blocks. The default value is
&amp;ldquo;F&amp;rdquo;.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>print_constants&lt;/code> - If this logical flag is set to &amp;ldquo;T&amp;rdquo;,
deck constants are printed to the &amp;ldquo;deck.status&amp;rdquo; (and
&amp;ldquo;const.status&amp;rdquo; after 4.11) file as they are parsed. The default
value is &amp;ldquo;F&amp;rdquo;.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>use_migration&lt;/code> - Logical flag which determines whether
or not to use [particle
migration][_input_deck_species__particle_migration_between_species].
The default is &amp;ldquo;F&amp;rdquo;.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>migration_interval&lt;/code> - The number of timesteps between
each [migration
event][_input_deck_species__particle_migration_between_species].
The default is 1 (migrate at every timestep).\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>allow_missing_restart&lt;/code> - Logical flag to allow code to
run when a restart dump is absent. When &amp;ldquo;restart_snapshot&amp;rdquo; is
specified then the simulation first checks that the specified
restart dump is valid. If the restart dump exists and is valid then
it is used to provide initial conditions for the simulation.
However, if the restart dump does not exist or is not usable for
some reason then by default the simulation will abort. If
&amp;ldquo;allow_missing_restart&amp;rdquo; is set to &amp;ldquo;T&amp;rdquo; then the simulation will
not abort but will continue to run and use the initial conditions
contained in the input deck to initialise the simulation. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code> print_eta_string&lt;/code> - If this logical flag is set to
&amp;ldquo;T&amp;rdquo; then the current estimated time to completion will be appended
to the status updates. The default value is &amp;ldquo;T&amp;rdquo;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code> n_zeros&lt;/code> - Integer flag which specifies the number of
digits to use for the output file numbers. (eg. &amp;ldquo;0012.sdf&amp;rdquo;). By
default, the code tries to calculate the number of digits required
by dividing t_end by dt_snapshot. Note that the minimum number of
digits is 4.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>- If this logical flag is set to &amp;ldquo;T&amp;rdquo; then the code performs a more
rigorous test to determine the number of digits required to accommodate
all outputs that are to be generated by a run. Since this can be time
consuming and is overkill for most cases, it is disabled by default. The
default value is &amp;ldquo;F&amp;rdquo;. - If this logical flag is set to &amp;ldquo;T&amp;rdquo; then the code
keeps global particle counts for each species on each processor. This
information isn&amp;rsquo;t needed by the core algorithm, but can be useful for
developing some types of additional physics packages. It does require
one additional MPI_ALL_REDUCE per species per timestep, so it is not
activated by default. The default value is &amp;ldquo;F&amp;rdquo;. - When restarting from a
dump file, the current walltime displayed will include the elapsed
walltime recorded in the restart dump. The user can request that this
time is ignored by setting the &amp;ldquo;reset_walltime&amp;rdquo; flag to &amp;ldquo;T&amp;rdquo;. The
default value is &amp;ldquo;F&amp;rdquo;. - This integer parameter determines the maximum
number of timesteps to allow between load balancing checks. Each time
that the load balancing sweep is unable to improve the load balance of
the simulation, it doubles the number of steps before the next check
will occur. It will keep increasing the check interval until it reaches
the value given by &lt;strong>dlb_maximum_interval&lt;/strong>. If the value of
&lt;strong>dlb_maximum_interval&lt;/strong> is negative then the check interval will
increase indefinitely. When the load balancing sweep finds an
improvement to the load balance of the simulation, the check interval is
reset to one. The default value is 500.\&lt;/p>
&lt;ul>
&lt;li>This integer parameter determines the maximum number of timesteps to
allow between forcing a full load balance sweep. If the current load
balance is greater than the value of &lt;strong>dlb_threshold&lt;/strong> then the load
balancer exits before attempting to improve the loading. If
&lt;strong>dlb_force_interval&lt;/strong> is greater than zero, then the full load
balancer will be run at the requested interval of timesteps, regardless
of the value of &lt;strong>dlb_threshold&lt;/strong>. Note that the simulation will only
be redistributed if this would result in an improved load balance. The
default value is 2000.\&lt;/li>
&lt;li>This logical flag determines whether a load balance will be attempted
on the first call of the load balancer. The load balancer performs to
functions: first it attempts to find a domain decomposition that
balances the load evenly amongst processors. Next, it redistributes the
domain and particles onto the new layout (if requred). This latter step
is always required when setting up the simulation, so the load balancer
is always called once during set-up. This flag controls whether or not a
load balance is attempted during this call, regardless of the value of
&lt;strong>dlb_threshold&lt;/strong>. The default value is &amp;ldquo;T&amp;rdquo;.\&lt;/li>
&lt;/ul>
&lt;h1 id="maxwell_solvers">Maxwell Solvers&lt;/h1>
&lt;p>With the default settings &amp;ldquo;field_order=2&amp;rdquo;, &amp;ldquo;maxwell_solver=yee&amp;rdquo; EPOCH
will use the standard second order Yee scheme for solving Maxwell&amp;rsquo;s
equations. This scheme has a grid dispersion relation with phase
velocities smaller than $c$, especially for large spatial frequencies.
Since EPOCH v4.11 it is possible to introduce extended stencils into the
update step of the Maxwell-Faraday equation which will help improving
the dispersion relation. All of the following extended stencils are only
available when &amp;ldquo;field_order=2&amp;rdquo;. Please note that you will also need to
choose an appropriate dt_multiplier, according to the selected scheme.
A dt_multiplier equal to unity would result in using the largest
time-step allowed by the CFL condition for any of the implemented
schemes. This time-step is said to be marginally stable. While, in
general, the marginally stable time-step has the best dispersion
properties, simulations may suffer from numerical problems such as
exponentially growing noise. Choosing smaller values for the
dt_multiplier tend to improve on this, while adversely affecting the
dispersion relation. The implemented solvers behave differently in this
regard.&lt;/p>
&lt;p>Different options are available as follows:\&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>maxwell_solver = lehe_{x,y,z}&lt;/code> - This setting will
enable an extended stencil proposed by Lehe et al &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. This stencil
focusses on improving the dispersion relation on the $x$-axis, please
take this into account when defining your laser input. It is available
in EPOCH1D, EPOCH2D and EPOCH3D. While it is not technically required to
use a dt_multiplier smaller than unity, the value proposed by Lehe et
al &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> is &amp;ldquo;dt_multiplier=0.96&amp;rdquo;.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>maxwell_solver = pukhov&lt;/code> - This setting will enable an
extended stencil proposed by Pukhov &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> under the name of NDFX. It
is available in EPOCH2D and EPOCH3D. In EPOCH1D, setting
maxwell_solver = pukhov will make the code fall back silently to
Yee&amp;rsquo;s scheme. Pukhov&amp;rsquo;s NDFX scheme aims at improving the numerical
dispersion relation by allowing to choose &amp;quot; dt_multiplier= 1.0&amp;quot;,
while smaller values are also valid. The resulting dispersion
relation is best along the axis with the smallest grid spacing.\&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- -->
&lt;ul>
&lt;li>&lt;code>maxwell_solver = cowan&lt;/code> - This setting will enable en
extended stencil proposed by Cowan et al &lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>. It is available only
in EPOCH3D. In EPOCH1D and EPOCH2D, setting maxwell_solver = cowan
will make the code fall back silently to Yee&amp;rsquo;s scheme. Cowan et al
&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup> proposes to numerically calculate a time step that has the
correct group velocity for the input laser. Typically these time
steps are only slightly below the CFL condition, e.g. &amp;quot; = 0.999&amp;quot;.
When Cowan&amp;rsquo;s scheme is reduced to 2D it is the same as Pukhov&amp;rsquo;s
scheme with dt_multiplier &amp;lt;1.0. The resulting dispersion relation
is best along the axis with the smallest grid spacing.\&lt;/li>
&lt;/ul>
&lt;p>- This setting will enable full user control over the extended stencil
coefficients. This allows for the specification of optimised
coefficients as outlined in &lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup>. This option must be accompanied by a
&amp;ldquo;stencil&amp;rdquo; block. See
&lt;a href="/tutorial/input_deck_control/#stencil_block">below.&lt;/a>&lt;/p>
&lt;h1 id="stencil_block">Stencil Block&lt;/h1>
&lt;p>The extended stencil Maxwell solvers described above all operate by
including points in neighbouring cells with a carefully chosen
weighting. These weightings are determined by adjusting the coefficients
shown in the Figure. Full control over these coefficients can be
achieved by specifying &amp;ldquo;custom&amp;rdquo; for the &amp;ldquo;maxwell_solver&amp;rdquo; parameter in
the control block and then supplying a &amp;ldquo;stencil&amp;rdquo; block to provide the
desired coefficient values.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Stencil.png" alt="Coefficient locations for the B_z field computational stencil in2D.">
This option allows the user to specify an extended stencil scheme that
has been specifically optimised for the simulation grid spacing and
timestep. See &lt;sup id="fnref:8">&lt;a href="#fn:8" class="footnote-ref" role="doc-noteref">8&lt;/a>&lt;/sup> for further details.&lt;br>
or see
&lt;a href="https://github.com/Ablinne/optimize-stencil" target="_blank" rel="noopener">7&lt;/a> for stencil
optimization code. Note that there is no option for changing the value
of $\alpha_{x,y,z}$ since these are calculated using the following
equations: $\begin{aligned}
\alpha_x &amp;amp;= 1 - 2\beta_{xy} - 2\beta{xz} - 3\delta_x,, \&lt;br>
\alpha_y &amp;amp;= 1 - 2\beta_{yx} - 2\beta{yz} - 3\delta_y,, \&lt;br>
\alpha_z &amp;amp;= 1 - 2\beta_{zx} - 2\beta{zy} - 3\delta_z,.\end{aligned}$&lt;/p>
&lt;ul>
&lt;li>&lt;code>delta{x,y,z}, gamma{x,y,z}, beta{xy,xz,yx,yz,zx,zy}&lt;/code> -
The coefficients to use for the extended stencil points as shown in
Figure [stencil]. See for further details. These coefficients are
specified as floating point numbers. The default values are to set
all coefficients to zero which results in $\alpha_{x,y,z}$ having
values of unity. This corresponds to the standard Yee scheme.\&lt;/li>
&lt;li>&lt;code>dt&lt;/code> - The timestep restriction to use for the field
solver\&lt;/li>
&lt;/ul>
&lt;h1 id="strided_current_filtering">Strided Current Filtering&lt;/h1>
&lt;p>EPOCH 4.15 introduces strided multipass digital current filtering as
described and benchmarked in the review by
&lt;a href="https://www.sciencedirect.com/science/article/abs/pii/S163107211400148X" target="_blank" rel="noopener">Vey and
Godfrey&lt;/a>.
This can be tuned to substantially damp high frequencies in the currents
and can be used to reduce the effect of numerical Cherenkov radiation.
Once you turn on current filtering by specifying &amp;ldquo;smooth_currents=T&amp;rdquo;
you can then set the following keys&lt;/p>
&lt;ul>
&lt;li>&lt;code>smooth_iterations&lt;/code> - Integer number of iterations of
the smoothing function to be performed. If not present defaults to
one iteration. More iterations will produce smoother results but
will be slower.&lt;/li>
&lt;li>&lt;code>smooth_compensation&lt;/code> - Logical flag. If true then
perform a compensation step (see Vey and Godfrey) after the
smoothing steps are performed. Total number of iterations if true is
smooth_iterations + 1. If not specified defaults to false&lt;/li>
&lt;li>&lt;code>smooth_strides&lt;/code> - Either a comma separated list of
integers or &amp;ldquo;auto&amp;rdquo; (without quote marks). This specifies the
strides (in number of grid cells) to use when performing strided
filtering. Specifying &amp;ldquo;1, 3&amp;rdquo; will smooth each point with the
points immediately adjacent and with the points 3 cells away on each
side of the current cell. Setting this key to &amp;ldquo;auto&amp;rdquo; uses a &amp;ldquo;1,
2, 3, 4&amp;rdquo; set of strides as a &amp;ldquo;good&amp;rdquo; starting point for strided
filtering.&lt;/li>
&lt;/ul>
&lt;p>It should be stressed that there is no set of values that is guaranteed
to give any given result from filtering while not affecting the physical
correctness of your simulation. Current filtering should be tuned to
match the problem that you want to work on and should always be
carefully tested to ensure that it doesn&amp;rsquo;t produce unphysical results.&lt;/p>
&lt;h1 id="dynamic_load_balancing">Dynamic Load Balancing&lt;/h1>
&lt;p>&amp;ldquo;dlb&amp;rdquo; in the input deck stands for Dynamic Load Balancing and, when
turned on, it allows the code to rearrange the internal domain
boundaries to try and balance the workload on each processor. This
rearrangement is an expensive operation, so it is only performed when
the maximum load imbalance reaches a given critical point. This critical
point is given by the parameter &amp;ldquo;dlb_threshold&amp;rdquo; which is the ratio of
the workload on the least loaded processor to the most loaded processor.
When the calculated load imbalance is less than &amp;ldquo;dlb_threshold&amp;rdquo; the
code performs a re-balancing sweep, so if &amp;ldquo;dlb_threshold = 1.0&amp;rdquo; is set
then the code will keep trying to re-balance the workload at almost
every timestep. At present the workload on each processor is simply
calculated from the number of particles on each processor, but this will
probably change in future. If the &amp;ldquo;dlb_threshold&amp;rdquo; parameter is not
specified then the code will only be load balanced at initialisation
time.&lt;/p>
&lt;h1 id="automatic_halting_of_a_simulation">Automatic halting of a simulation&lt;/h1>
&lt;p>It is sometimes useful to be able to halt an EPOCH simulation midway
through execution and generate a restart dump. Two methods have been
implemented to enable this.&lt;/p>
&lt;p>The first method is to check for the existence of a &amp;ldquo;STOP&amp;rdquo; file.
Throughout execution, EPOCH will check for the existence of a file named
either &amp;ldquo;STOP&amp;rdquo; or &amp;ldquo;STOP_NODUMP&amp;rdquo; in the simulation output directory. The
check is performed at regular intervals and if such a file is found then
the code exits immediately. If &amp;ldquo;STOP&amp;rdquo; is found then a restart dump is
written before exiting. If &amp;ldquo;STOP_NODUMP&amp;rdquo; is found then no I/O is
performed.&lt;/p>
&lt;p>The interval between checks is controlled by the integer parameter
&amp;ldquo;check_stop_frequency&amp;rdquo; which can be specified in the &amp;ldquo;control&amp;rdquo; block
of the input deck. If it is less than or equal to zero then the check is
never performed.&lt;/p>
&lt;p>The next method for automatically halting the code is to stop execution
after a given elapsed walltime. If a positive value for
&amp;ldquo;stop_at_walltime&amp;rdquo; is specified in the control block of an input deck
then the code will halt once this time is exceeded and write a restart
dump. The parameter takes a real argument which is the time in seconds
since the start of the simulation.&lt;/p>
&lt;p>An alternative method of specifying this time is to write it into a
separate text file. &amp;ldquo;stop_at_walltime_file&amp;rdquo; is the filename from
which to read the value for &amp;ldquo;stop_at_walltime&amp;rdquo;. Since the walltime
will often be found by querying the queueing system in a job script, it
may be more convenient to pipe this value into a text file rather than
modifying the input deck.&lt;/p>
&lt;h1 id="requesting_output_dumps_at_run_time">Requesting output dumps at run time&lt;/h1>
&lt;p>In addition to polling for the existence of a &amp;ldquo;STOP&amp;rdquo; file, EPOCH also
periodically checks the output directory for a file named &amp;ldquo;DUMP&amp;rdquo;. If
such a file is found then EPOCH will immediately create an output dump
and remove the &amp;ldquo;DUMP&amp;rdquo; file. By default, the file written will be a
restart dump but if the &amp;ldquo;DUMP&amp;rdquo; file contains the name of an output
block then this will be used instead.&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_boundaries">The boundaries block&lt;/a>&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>O. Buneman, &amp;ldquo;TRISTAN: The 3-D Electromagnetic Particle Code.&amp;rdquo; in
Computer Space Plasma Physics: Simulations Techniques and Software,
1993.
&lt;a href="https://www.terrapub.co.jp/e-library/cspp/" target="_blank" rel="noopener">1&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>R. Lehe, A. Lifschitz, C. Thaury, V. Malka, and X. Davoine,
&amp;ldquo;Numerical growth of emittance in simulations of laser-wakefield
acceleration,&amp;rdquo; Phys. Rev. Accel. Beams, vol. 16, no. 2, p.021301,
2013
&lt;a href="https://www.researchgate.net/publication/258097872_Numerical_growth_of_emittance_in_simulations_of_laser-wakefield_acceleration" target="_blank" rel="noopener">2&lt;/a>.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>Pukhov, A., &amp;ldquo;Three-dimensional electromagnetic relativistic
particle-in-cell code VLPL (Virtual Laser Plasma Lab)&amp;rdquo;, J. Plasma
Phys., vol. 61, no. 3, p. 425, 1999
&lt;a href="https://www.cambridge.org/core/journals/journal-of-plasma-physics/article/three-dimensional-electromagnetic-relativistic-particle-in-cell-code-vlpl-virtual-laser-plasma-lab/7FBA476D599E2F19DFEA3F0F2F84FFAB" target="_blank" rel="noopener">3&lt;/a>.&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>B. Cowan, D. Bruhwiler, J. Cary, E. Cormier-Michel, and C. Geddes,
&amp;ldquo;Generalized algorithm for control of numerical dispersion in
explicit time-domain electromagnetic simulations&amp;rdquo;, Phys. Rev.
Accel. Beams, vol. 16, no. 4, p. 041303, 2013
&lt;a href="https://journals.aps.org/prab/abstract/10.1103/PhysRevSTAB.16.041303" target="_blank" rel="noopener">4&lt;/a>.&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6" role="doc-endnote">
&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/li>
&lt;li id="fn:7" role="doc-endnote">
&lt;p>A. Blinne, D. Schinkel, S. Kuschel, N. Elkina, S. G. Rykovanov,
and M. Zepf, &amp;ldquo;A systematic approach to numerical dispersion in
Maxwell solvers&amp;rdquo;, Computer Physics Communications, 00104655,
2017
&lt;a href="https://arxiv.org/pdf/1710.06829.pdf" target="_blank" rel="noopener">5&lt;/a>&amp;#160;&lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:8" role="doc-endnote">
&lt;p>A. Blinne, D. Schinkel, S. Kuschel, N. Elkina, S. G. Rykovanov,
and M. Zepf, &amp;ldquo;A systematic approach to numerical dispersion in
Maxwell solvers&amp;rdquo;, Computer Physics Communications, 00104655,
2017
&lt;a href="https://arxiv.org/pdf/1710.06829.pdf" target="_blank" rel="noopener">6&lt;/a>&amp;#160;&lt;a href="#fnref:8" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title/><link>/tutorial/input_deck_dist_fn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_dist_fn/</guid><description>&lt;p>This block contains information about distribution functions that should
be calculated for output. See
&lt;a href="/tutorial/input_deck">EPOCH input
deck&lt;/a> for more information on the input
deck.&lt;/p>
&lt;p>Sometimes it is useful to reconstruct part of the full phase space for
one or more particle species. This functionality is provided through a
&lt;em>dist_fn&lt;/em> block. The distribution function is integrated over all
dimensions which are not axes of the distribution function.&lt;/p>
&lt;p>Calculating distribution functions requires some degree of integration
of data leading to various possible ways of normalising the resulting
distribution function. In EPOCH, distribution functions are normalised
so that the value at every point of the distribution function is the
number of particles within that cell of the distribution function,
ignoring all phase space directions which are not considered as an axis
of the distribution function. Summing the distribution function should
give the total number of real particles (as opposed to computational
pseudoparticles) in the simulation.&lt;/p>
&lt;p>An example &lt;em>dist_fn&lt;/em> block is given below:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:dist_fn
name = x_px
ndims = 2
dumpmask = always
direction1 = dir_x
direction2 = dir_px
# Range is ignored for spatial coordinates
range1 = (1, 1)
range2 = (-50.0e-20, 50.0e-20)
# Resolution is ignored for spatial coordinates
resolution1 = 1
resolution2 = 5000
restrict_py = (-3.0e-20, 3.0e-20)
include_species:Electron
include_species:Carbon
end:dist_fn
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>name&lt;/code> - The name of the distribution function when it is
output. This name is appended with the name of each species for
which the data is output and so, for example, when applied to a
species named carbon the output is called &lt;em>x_px_Carbon&lt;/em>. The
Cartesian grid which describes the axes of the distribution function
would then be called &lt;em>grid_x_px_Carbon&lt;/em>.\&lt;/li>
&lt;li>&lt;code>ndims&lt;/code> - The number of dimensions in this phase space
reconstruction. Due to difficulties in visualising data in more than
three dimensions, this is restricted to being 1, 2 or 3.\&lt;/li>
&lt;li>&lt;code>dumpmask&lt;/code> - Determines which output dumps will include
this distribution function. The dumpmask has the same semantics as
those used by variables in the &amp;ldquo;output&amp;rdquo; block, described
&lt;a href="/tutorial/input_deck_output_block">here&lt;/a>. The dumpmask from
&amp;ldquo;distribution_functions&amp;rdquo; in the output block is applied first and
then this one is applied afterwards. For example, if the dist_fn
block contains &amp;ldquo;dumpmask = full&amp;rdquo; and the output block contains
&amp;ldquo;distribution_functions = always&amp;rdquo; then this distribution function
will be only be dumped at full dumps. The default dumpmask is
&amp;ldquo;always&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>direction**n**&lt;/code> - This is the phase space to sample
along axis . This can be any one of: dir_x, dir_y, dir_z,
dir_px, dir_py, dir_pz, dir_en, dir_gamma_m1, dir_xy_angle,
dir_yz_angle, dir_zx_angle with spatial codes only being
available in dimensionalities of the code which have that direction.
Therefore dir_z does not exist in EPOCH1D or EPOCH2D and dir_y
does not exist in EPOCH1D.&lt;/li>
&lt;/ul>
&lt;p>The flags &amp;ldquo;dir_xy_angle&amp;rdquo;, &amp;ldquo;dir_yz_angle&amp;rdquo; and &amp;ldquo;dir_zx_angle&amp;rdquo;
calculate the distribution of particle momentum directions in the X-Y,
Y-Z and Z-X planes.\&lt;/p>
&lt;ul>
&lt;li>&lt;code>range**n**&lt;/code> - The range between which this axis should
run. This is in the form of (minimum, maximum). Any particle which
exceeds the range is ignored. For momentum directions this parameter is
specified in $kg\ ms^{-1}$. If the range of a momentum direction is set
so that the maximum and the minimum are equal then the code will
automatically set the range to exactly span the range of particle
momenta at the point of writing the dump.\&lt;/li>
&lt;li>&lt;code>resolution**n**&lt;/code> - The number of gridpoints in a given
direction. This is ignored for spatial dimensions where the resolution
is always the same as the resolution of the underlying simulation.\&lt;/li>
&lt;li>&lt;code>include_species&lt;/code> - Specifies a species which should be
included in the output. This is useful since it is rare that momentum
limits are appropriate for both electrons and ions, so usually for a
given dist_fn block only electrons or ions are considered. It is
possible to have two dist_fn blocks with the same name but different
ranges and different include_species settings produce the effect of a
single diagnostic for all species in the output file.\&lt;/li>
&lt;li>&lt;code>output_deltaf&lt;/code> - If set to &amp;ldquo;T&amp;rdquo;, the particle weights used
in calculating the distribution function is adjusted by subtracting the
Delta-f distribution function for the particle species. The default
value is &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>restrict_{x,y,z,px,py,pz}&lt;/code> - Restrictions are specified
in the same way as ranges, but have a subtly different behaviour. Ranges
specify the range of a visible axis on the resulting distribution
function, whereas restrictions allow you to specify minimum and maximum
values for each spatial and momentum direction and use only particles
which fall within this range when calculating the distribution function.
Restrictions can be specified even for properties which are not being
used as axes. It is possible to set a restriction that is more
restrictive than the range applied. This is not trapped as an error and
such parts of the distribution function are guaranteed to be empty. The
available spatial restrictions depend on the dimensionality of the code.
Therefore, attempting to set restrict_z in EPOCH1D will produce a
warning.&lt;br>
At present, the code to calculate the distribution functions has one
limitation: it ignores particle shape functions when calculating
properties on the spatial axis, meaning that the result is less smooth
than normal properties from the code.&lt;/li>
&lt;/ul>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_probe">The probe block&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_field_operator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_field_operator/</guid><description>&lt;h1 id="example_deck_block">Example deck block&lt;/h1>
&lt;pre>&lt;code class="language-perl">begin:field_operator
name = field_op
restrict:(dir_x, (x_max+x_min)/2, null)
restrict:(dir_y, y_min + (y_max-y_min)/4, y_min + 3*(y_max-y_min)/4)
restrict:(dir_modp, 1.0261218e-22, null)
end:field_operator
&lt;/code>&lt;/pre>
&lt;h1 id="name">Name&lt;/h1>
&lt;p>All field operator blocks must be named using the name key so that they
can be referred to later&lt;/p>
&lt;h1 id="restrict_keys">Restrict Keys&lt;/h1>
&lt;p>Restrictions are specified using the restrict keyword and must have a
specific form&lt;/p>
&lt;pre>&lt;code class="language-perl"> restrict:(particle_property, min_val, max_val)
&lt;/code>&lt;/pre>
&lt;p>The first parameter is the
&lt;a href="/tutorial/calculable_particle_properties">calculable particle
property&lt;/a> that you wish
to restrict the particle selection on The second parameter is the
minimum value for that property. It may be the special value &amp;ldquo;null&amp;rdquo; if
you do not wish to specify a lower bound for this restriction The third
parameter is the maximum value for that property. It may be the special
value &amp;ldquo;null&amp;rdquo; if you do not wish to specify an upper bound for this
restriction&lt;/p>
&lt;p>Any field block that has the restricted axis restricts that axis to run
between the specified ranges.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_fields/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_fields/</guid><description>&lt;p>This block contains information about the EM fields specified at the
start of the simulation. See
&lt;a href="/tutorial/input_deck">EPOCH input
deck&lt;/a> for more information on the input
deck.&lt;/p>
&lt;p>This block allows you to specify the electric and magnetic fields at any
point in the domain. An example block is shown below:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:fields
ex = sin(pi * x / length_x)
ey = cos(pi * x / length_x)
ez = 0
bx = 1.0
by = -1.0
bz = 0
end:fields
&lt;/code>&lt;/pre>
&lt;p>Once again, this is a very simple block needing only limited
explanation. All field variables are accessible by name and can be read
back using the appropriate commands from the maths parser (see
[here][maths_parser__constants]). The possible
parameters are as follows:\&lt;/p>
&lt;ul>
&lt;li>&lt;code>ex,ey,ez&lt;/code> - The electric field vectors pointing in all
three directions. The default value is zero.\&lt;/li>
&lt;li>&lt;code>bx,by,bz&lt;/code> - The magnetic field vectors pointing in all
three directions. The default value is zero.\&lt;/li>
&lt;li>&lt;code>offset&lt;/code> - File offset. The field values may also be
specified using a binary file in a similar way to that used for species
variables. See
&lt;a href="/tutorial/input_deck_species">the species block&lt;/a>
for more details.&lt;br>
Any valid maths parser expression can be used to set up the fields, and
no check is made to ensure that the $\nabla.B = 0$ is satisfied.&lt;/li>
&lt;/ul>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_particle_file">The particles from file
block&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_injector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_injector/</guid><description>&lt;p>The &lt;em>injector&lt;/em> block specifies a particle source to be introduced
through a simulation boundary. Each injector block specifies a source of
a single species of particle defined by a density, centre of mass drift
momentum, temperature and number of simulation particles per cell. The
current version of the injectors is incompatible with the
PER_SPECIES_WEIGHT compiler flag, and attempting to use an injector
with a version of EPOCH compiled with this flag will fail.&lt;/p>
&lt;h1 id="concepts">Concepts&lt;/h1>
&lt;p>EPOCH can inject particles through any of the simulation boundaries.
This plasma is either a drifting Maxwellian corresponding to a
collisionally thermalized beam or a &amp;ldquo;flux Maxwellian&amp;rdquo; corresponding to
a Maxwellian source accelerated by an electrostatic accelerator. It can
have any temporal or transverse spatial profile of density, temperature
or drift that you wish to specify.&lt;/p>
&lt;p>EPOCH does not automatically make any assumption about the plasma that
you wish to inject and does not correct for currents injected into the
domain. Current due to an injected beam will be smoothly created as the
particles enter the domain. If you wish to inject a neutral beam, you
will have to use multiple injectors to inject electrons and ions so as
to produce a neutral beam. Great care must be taken when introducing
relativistic beams since the current due to a highly relativistic beam
will not be the current due to the centre of mass velocity since EPOCH
does not use the Maxwell-Jüttner distribution for loading particles.&lt;/p>
&lt;h1 id="boundary_conditions">Boundary conditions&lt;/h1>
&lt;p>The injectors only work properly with certain boundary conditions. For
most purposes the &amp;ldquo;open&amp;rdquo; boundary condition is the only one that makes
sense with injectors since particles are flowing freely through the
boundary. Remember that in any version of EPOCH that supports injectors
you can also use per species boundary conditions to allow you to have
different boundary conditions for injected and bulk particles.&lt;/p>
&lt;h1 id="moving_window">Moving window&lt;/h1>
&lt;p>Injectors and moving windows can be tricky to work with, so the default
behaviour of EPOCH is to stop all injectors when the window starts to
move. If you wish to override this behaviour then simply explicitly set
t_end in the injector block to a value after the window starts to move.
Setting&lt;/p>
&lt;pre>&lt;code class="language-perl"> t_end = t_end
&lt;/code>&lt;/pre>
&lt;p>will cause the injectors to continue running until the end of the
simulation even with the moving window. You must take great care when
specifying injectors for a moving window because you will likely get
gaps or bunches in particles injected through the x boundary and there
will probably be some shearing of particles introduced through y and z
boundaries. It is in general recommended that you specify a velocity
profile for the moving window that stops at times when particles are to
be injected and then starts again once the injection is complete.&lt;/p>
&lt;h1 id="keys">Keys&lt;/h1>
&lt;ul>
&lt;li>boundary - specifies which boundary to attach the particle source
too. Same specification as the
&lt;a href="/tutorial/input_deck_laser">laser block&lt;/a>, so
permitted values are x_min, x_max, y_min, y_max, z_min and
z_max&lt;/li>
&lt;li>species - specifies which species should be injected through the
boundary. Just specify the name of the species required.&lt;/li>
&lt;li>t_start - Time at which to start the injector&lt;/li>
&lt;li>t_end - Time at which to end the injector&lt;/li>
&lt;li>npart_per_cell - target pseudo-particle density for the injector.
Average number of particles injected will be this value or slightly
higher if very few particles are specified&lt;/li>
&lt;li>number_density - Number density of the particle source in $m^{-3}$.
Can be space varying along the boundary to which the injector is
attached and time varying&lt;/li>
&lt;li>number_density_min - Minimum number density in $m^{-3}$ below
which pseudo particles are not loaded. Use if the density has a
profile to avoid injecting low weight particles in low density
regions&lt;/li>
&lt;li>temp_x - Temperature in x direction (K)&lt;/li>
&lt;li>temp_y - Temperature in y direction (K)&lt;/li>
&lt;li>temp_z - Temperature in z direction (K)&lt;/li>
&lt;li>temp - Temperature in all directions (K)&lt;/li>
&lt;li>drift_x - Momentum drift in x direction in $kgm/s$&lt;/li>
&lt;li>drift_y - Momentum drift in x direction in $kgm/s$&lt;/li>
&lt;li>drift_z - Momentum drift in x direction in $kgm/s$&lt;/li>
&lt;/ul>
&lt;p>- Logical flag to determine whether to use an accelerated flux
Maxwellian rather than a drifting Maxwellian. This calculates the flux
due to passing a Maxwellian source into an electrostatic accelerator
instead of a drifting Maxwellian. If your particle source is a lab
accelerator then you may want to set this to true.&lt;/p>
&lt;h1 id="example_deck">Example Deck&lt;/h1>
&lt;pre>&lt;code class="language-perl">begin:injector
boundary = x_min
species = Electron
number_density = dens
temp_x = temp
drift_x = drift_p
npart_per_cell = 32
end:injector
&lt;/code>&lt;/pre>
&lt;h1 id="warnings">Warnings&lt;/h1>
&lt;p>Currently injectors are a beta feature of EPOCH. We believe them to work
correctly, but unusual results must be considered suspect. If you get
unexpected results, please contact the EPOCH development team.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_laser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_laser/</guid><description>&lt;p>This block contains information about laser boundary sources. See
&lt;a href="/tutorial/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;p>Laser blocks attach an EM wave source to a boundary which is set as
&lt;strong>simple_laser&lt;/strong>.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:laser
boundary = x_min
id = 1
intensity_w_cm2 = 1.0e15
lambda = 1.06 * micron
pol_angle = 0.0
phase = 0.0
t_profile = gauss(time, 40.0e-15, 40.0e-15)
t_start = 0.0
t_end = 80.0e-15
end:laser
&lt;/code>&lt;/pre>
&lt;p>As already mentioned in the discussion of laser boundaries in the
&lt;a href="/tutorial/input_deck_boundaries">boundaries&lt;/a> block, lasers are
attached to compatible boundaries here in the initial conditions deck.\&lt;/p>
&lt;ul>
&lt;li>&lt;code>boundary&lt;/code> - The boundary on which to attach the laser. In
1D, the directions can be either x_min or x_max. &amp;ldquo;left&amp;rdquo; and &amp;ldquo;right&amp;rdquo;
are accepted as a synonyms. In 2D, y_min and y_max may also be
specified. These have synonyms of &amp;ldquo;down&amp;rdquo; and &amp;ldquo;up&amp;rdquo;. Finally, 3D adds
z_min and z_max with synonyms of &amp;ldquo;back&amp;rdquo; and &amp;ldquo;front&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>amp&lt;/code> - The amplitude of the $E$ field of the laser in
$V/m$.\&lt;/li>
&lt;li>&lt;code>intensity&lt;/code> - The intensity of the laser in $W/m^2$. There
is no need to specify both intensity and amp and the last specified in
the block is the value used. It is mandatory to specify at least one.
The amplitude of the laser is calculated from intensity using the
formula &lt;code>amp = sqrt(2*intensity/c/epsilon0)&lt;/code>. &amp;ldquo;irradiance&amp;rdquo; is accepted
as a synonym.\&lt;/li>
&lt;li>&lt;code>intensity_w_cm2&lt;/code> - This is identical to the
&lt;strong>intensity&lt;/strong> parameter described above, except that the units are
specified in $W/cm^2$.\&lt;/li>
&lt;li>&lt;code>id&lt;/code> - An id code for the laser. Used if you specify the
laser time profile in the EPOCH source rather than in the input deck.
Does not have to be unique, but all lasers with the same id will have
the same time profile. This parameter is optional and is not used under
normal conditions.\&lt;/li>
&lt;li>&lt;code>omega&lt;/code> - Angular frequency (rad/s not Hz) for the laser.\&lt;/li>
&lt;li>&lt;code>frequency&lt;/code> - Ordinary frequency (Hz not rad/s) for the
laser.\&lt;/li>
&lt;li>&lt;code>lambda&lt;/code> - Wavelength in a vacuum for the laser specified
in $m$. If you want to specify in $\mu m$ then you can multiply by the
constant &amp;ldquo;micron&amp;rdquo;. One of &lt;strong>lambda&lt;/strong> or &lt;strong>omega&lt;/strong> (or &lt;strong>frequency&lt;/strong>) is
a required parameter.\&lt;/li>
&lt;li>&lt;code>pol_angle&lt;/code> - Polarisation angle for the electric field of
the laser in radians. This parameter is optional and has a value of zero
by default. The angle is measured with respect to the right-hand triad
of propagation direction, electric and magnetic fields. Although the 1D
code has no $y$ or $z$ spatial axis, the fields still have $y$ and $z$
components. If the laser is on &lt;strong>x_min&lt;/strong> then the default $E$ field is
in the $y$-direction and the $B$ field is the $z$-direction. The
polarisation angle is measured clockwise about the $x$-axis with zero
along the $E_y$ direction. If the laser is on &lt;strong>x_max&lt;/strong> then the angle
is anti-clockwise.&lt;br>
**Similarly, for propagation directions:&lt;br>
**&lt;em>y_min&lt;/em> - angle about $y$-axis, zero along $z$-axis&lt;br>
**&lt;em>z_min&lt;/em> - angle about $z$-axis, zero along $x$-axis&lt;br>
**&lt;em>y_max&lt;/em> - angle anti-clockwise about $y$-axis, zero along $z$-axis&lt;br>
**&lt;em>z_max&lt;/em> - angle anti-clockwise about $z$-axis, zero along $x$-axis\&lt;/li>
&lt;li>&lt;code>pol&lt;/code> - This is identical to &lt;em>pol_angle&lt;/em> with the angle
specified in degrees rather than radians. If both are specified then the
last one is used.\&lt;/li>
&lt;li>&lt;code>phase&lt;/code> - The phase profile of the laser wavefront given in
radians. Phase may be a function of both space and time. The laser is
driven using ${\rm{sin}}(\omega t + \phi)$ and &lt;strong>phase&lt;/strong> is the $\phi$
parameter. There is zero phase shift applied by default.\&lt;/li>
&lt;li>&lt;code>profile&lt;/code> - The spatial profile of the laser. This should
be a spatial function not including any values in the direction normal
to the boundary on which the laser is attached, and the expression will
be evaluated at the boundary. It may also be time-dependant. The laser
field is multiplied by the profile to give its final amplitude so the
intention is to use a value between zero and one. By default it is a
unit constant and therefore has no affect on the laser amplitude. This
parameter is redundant in 1D and is only included for consistency with
2D and 3D versions of the code.\&lt;/li>
&lt;li>&lt;code>t_profile&lt;/code> - Used to specify the time profile for the
laser amplitude. Like &lt;strong>profile&lt;/strong> the laser field is multiplied by this
parameter but it is only a function of time and not space. In a similar
manner to &lt;strong>profile&lt;/strong>, it is best to use a value between zero and one.
Setting values greater than one is possible but will cause the maximum
laser intensity to grow beyond &lt;strong>amp&lt;/strong>. In previous versions of EPOCH,
the &lt;strong>profile&lt;/strong> parameter was only a function of space and this
parameter was used to impose time-dependance. Since &lt;strong>profile&lt;/strong> can now
vary in time, &lt;strong>t_profile&lt;/strong> is no longer needed but it has been kept to
facilitate backwards compatibility. It can also make input decks clearer
if the time dependance is given separately. The default value of
&lt;strong>t_profile&lt;/strong> is just the real constant value of 1.0.\&lt;/li>
&lt;li>&lt;code>t_start&lt;/code> - Start time for the laser in seconds. Can be
set to the string &amp;ldquo;start&amp;rdquo; to start at the beginning of the simulation.
This is the default value. When using this parameter, the laser start is
hard. To get a soft start use the &lt;strong>t_profile&lt;/strong> parameter to ramp the
laser up to full strength.\&lt;/li>
&lt;li>&lt;code>t_end&lt;/code> - End time for the laser in seconds, can be set to
the string &amp;ldquo;end&amp;rdquo; to end at the end of the simulation. This is the
default value. When using this parameter, the laser end is clipped
straight to zero at $t &amp;gt; t_end$. To get a soft end use the
&lt;strong>t_profile&lt;/strong> parameter to ramp the laser down to zero.&lt;br>
If you add multiple laser blocks to the initial conditions file then the
multiple lasers will be additively combined on the boundary.&lt;/li>
&lt;/ul>
&lt;p>In theory, any laser time profile required is possible, but the core
FDTD solver for the EM fields in EPOCH produces spurious results if
sudden changes in the field intensity occur. This is shown below. The
pulse shown on the left used a constant &lt;em>t_profile&lt;/em> and used &lt;em>t_end&lt;/em>
to stop the laser after 8fs. Since the stopping time was not an exact
multiple of the period, the result was to introduce spurious
oscillations behind the pulse. If the laser had a finite phase shift so
that the amplitude did not start at zero, a similar effect would be
observed on the front of the pulse.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Pulse2.png" alt="A laser pulse with a sharp cutoff shows numerical artefacts behind thepulse.">&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Pulse1.png" alt="A laser pulse with a smooth temporal profile shows noartefacts.">&lt;/p>
&lt;p>The second figure instead used a Gaussian window function with a
characteristic width of 8fs as well as using &lt;em>t_end&lt;/em> to introduce a
hard cutoff. It can clearly be seen that there are no spurious
oscillations and the wave packet propagates correctly, showing only some
dispersive features.&lt;/p>
&lt;p>There is no hard and fast rule as to how rapid the rise or fall for a
laser can be, and the best advice is to simply test the problem and see
whether any problems occur. If they do then there are various solutions.
Essentially, the timestep must be reduced to the point where the sharp
change in amplitude can be accommodated. The best solution for this is
to increase the spatial resolution (with a comparable increase in the
number of pseudoparticles), thus causing the timestep to drop via the
CFL condition.&lt;/p>
&lt;p>This is computationally expensive, and so a cheaper option is simply to
decrease the input.deck option &lt;em>dt_multiplier&lt;/em>. This artificially
decreases the timestep below the timestep calculated from the internal
stability criteria and allows the resolution of sharp temporal
gradients. This is an inferior solution since the FDTD scheme has
increased error as the timestep is reduced from that for EM waves. EPOCH
includes a high order field solver to attempt to reduce this.&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_fields">The fields block&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_operator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_operator/</guid><description>&lt;h1 id="example_deck_block">Example deck block&lt;/h1>
&lt;pre>&lt;code class="language-perl">begin:operator
name = restriction_op
or = F # Should restrictions be combined with OR or AND?
restrict:(dir_x, (x_max+x_min)/2, null)
restrict:(dir_y, y_min + (y_max-y_min)/4, y_min + 3*(y_max-y_min)/4)
restrict:(dir_modp, 1.0261218e-22, null)
include : random_fraction(0.01)
end:operator
&lt;/code>&lt;/pre>
&lt;h1 id="name">Name&lt;/h1>
&lt;p>All operator blocks must be named using the name key so that they can be
referred to later&lt;/p>
&lt;h1 id="restrict_keys">Restrict Keys&lt;/h1>
&lt;p>Restrictions are specified using the restrict keyword and must have a
specific form&lt;/p>
&lt;pre>&lt;code class="language-perl"> restrict:(particle_property, min_val, max_val)
&lt;/code>&lt;/pre>
&lt;p>The first parameter is the
&lt;a href="/tutorial/calculable_particle_properties">calculable particle
property&lt;/a> that you wish
to restrict the particle selection on The second parameter is the
minimum value for that property. It may be the special value &amp;ldquo;null&amp;rdquo; if
you do not wish to specify a lower bound for this restriction The third
parameter is the maximum value for that property. It may be the special
value &amp;ldquo;null&amp;rdquo; if you do not wish to specify an upper bound for this
restriction&lt;/p>
&lt;p>All particles that have the specified property between the minimum and
maximum value (except where such values are null) are accepted.
Specifying both the upper and lower bounds as null is acceptable but is
a null operation that merely slows down the output routines&lt;/p>
&lt;h1 id="include_keys">Include Keys&lt;/h1>
&lt;p>Include keys include more sophisticated particle selection routines,
such as ID selections, random fractions etc. They are specified either
by name or by using a particle operator constructor function such as
random_fraction&lt;/p>
&lt;h2 id="or">OR&lt;/h2>
&lt;p>The &amp;ldquo;or&amp;rdquo; deck key specifies whether restrictions should be combined
using AND or OR. If &amp;ldquo;or&amp;rdquo; is T then combination is by ORing the
conditions, if &amp;ldquo;or&amp;rdquo; is false or absent then the combination is by
ANDing the conditions&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_output_block/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_output_block/</guid><description>&lt;p>This block contains information about when and how to dump output files.
See
&lt;a href="/tutorial/input_deck">EPOCH input deck&lt;/a> for more information
on the input deck.&lt;/p>
&lt;h1 id="basics">Basics&lt;/h1>
&lt;p>Output in EPOCH is handled using the custom designed SDF file format
(&lt;em>Self Describing Format&lt;/em>). A detailed specification of this format is
available elsewhere, although this is only of interest to developers
wishing to write new libraries. EPOCH comes with readers for ITT IDL,
LLNL VisIt, Mathworks MatLab and Python. The IDL reader is also
compatible with the open source GDL tool.&lt;/p>
&lt;p>There are two styles of output block supported by EPOCH. The first
style, which will be referred to as the &amp;ldquo;traditional&amp;rdquo; style, is the
method that has been supported by EPOCH since its inception. With this
method, a single output block governs all the output dumps which are to
be performed. There are a few levels of output which give some small
amount of flexibility over what gets dumped but these do not allow for a
very fine-grained control.&lt;/p>
&lt;p>In version 4.0 of EPOCH, a new style was introduced in which multiple
named output blocks may be specified allowing for much greater
flexibility. The existence of a &amp;ldquo;name&amp;rdquo; parameter is what determines that
an output block is the new style rather than the traditional style.&lt;/p>
&lt;p>Most of the parameters are shared by both styles. The following sections
document the traditional style of output block and any differences
between the two styles are described
&lt;a href="#multiple_output_blocks">below&lt;/a> .&lt;/p>
&lt;p>What the code should output and when it should output it is specified in
the &amp;ldquo;output&amp;rdquo; block of the input deck. An example output block is shown
below:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
# If use_offset_grid is true then the code dumps a grid which
# displays positions relative to the left hand edge of the window
use_offset_grid = F
# number of timesteps between output dumps
dt_snapshot = 1.0e-14
# Number of dt_snapshot between full dumps
full_dump_every = 10
restart_dump_every = -1
force_final_to_be_restartable = T
# Properties at particle positions
particles = never
px = never
py = never
pz = never
vx = never
vy = never
vz = never
charge = never
mass = never
particle_weight = never
# Properties on grid
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
jx = always
jy = always
ekbar = always + species
mass_density = never + species
charge_density = always
number_density = always + species
temperature = always + species
distribution_functions = always
particle_probes = never
end:output
&lt;/code>&lt;/pre>
&lt;p>There are three types of output dump in EPOCH which are used for
different purposes. These types are:&lt;/p>
&lt;ul>
&lt;li>normal - The most frequent type of output dump in EPOCH is a normal
dump.&lt;/li>
&lt;li>full - A full dump is usually written every 10 or so normal dumps. A
full dump contains all the data that a normal dump contains and
should also contain any information which is needed only
infrequently, whether this is the full particle information or a
large distribution function. It is possible to turn off full dumps
completely.&lt;/li>
&lt;li>restart - A restart dump is a dump where the code guarantees to
write enough data to allow the code to restart from the output.
Output dumps are guaranteed to contain all the information in a
normal dump and, if they coincide with the timing for a full dump,
will also contain the full dump information.&lt;/li>
&lt;/ul>
&lt;p>Information will never be written into a file twice, even if two
conditions for it being written are satisfied (i.e even if px should be
dumped both because it is a full dump and a restart dump, px will only
be written once).&lt;/p>
&lt;p>Note that these dump levels only really make sense for the traditional
style of output block and are not really required when the new style is
used.&lt;/p>
&lt;h1 id="dumpmask">Dumpmask&lt;/h1>
&lt;p>When specifying which type of output dump to write a variable to there
are eight options which can be specified for each variable and can be
combined by addition. Some combinations make no sense but are formally
valid. The first four options specify at which output types the variable
is to be dumped:\&lt;/p>
&lt;ul>
&lt;li>&lt;code>never&lt;/code> - If the variable is not a required restart
variable then it will never be written. If it is a required restart
variable then it will be written only at restart dumps.\&lt;/li>
&lt;li>&lt;code>full&lt;/code> - This variable will be written at full dumps only.\&lt;/li>
&lt;li>&lt;code>always&lt;/code> - This variable will be written at full, normal
and restart dumps.\&lt;/li>
&lt;li>&lt;code>restart&lt;/code> - This variable will be written at restart dumps
only. Note that variables required for restarting the code are always
written to restart dumps. This flag is to enable the writing of
additional variables into such dump files.&lt;br>
For grid variables derived from summing over particles (ie. &amp;ldquo;ekbar&amp;rdquo;,
&amp;ldquo;mass_density&amp;rdquo;, &amp;ldquo;charge_density&amp;rdquo;, &amp;ldquo;number_density&amp;rdquo;, &amp;ldquo;temperature&amp;rdquo;)
the following two parameters also apply.\&lt;/li>
&lt;li>&lt;code>species&lt;/code> - The derived variable should be output on a
species by species basis. It is combined with a dumpmask code by
addition as in:&lt;br>
&lt;strong>charge_density = always + species&lt;/strong> .\&lt;/li>
&lt;li>&lt;code>no_sum&lt;/code> - The output for this derived variable should not
be summed over all species. By default, derived variables are summed
over all species. If you don&amp;rsquo;t want to include this sum, you must use
the &amp;ldquo;no_sum&amp;rdquo; flag. It is combined with a dumpmask code by addition as
in:&lt;br>
&lt;strong>charge_density = always + species + no_sum&lt;/strong> .&lt;br>
Most grid variables may be averaged over time. A more detailed
description of this is given in
&lt;a href="#data_averaging">#Data
Averaging&lt;/a>. Data averaging is specified
using the following dumpmask parameters.\&lt;/li>
&lt;li>&lt;code>average&lt;/code> - The output for this variable should be averaged
over time. The time span over which the variable will be averaged is
controlled using flags described
&lt;a href="#directives">below&lt;/a>.\&lt;/li>
&lt;li>&lt;code>snapshot&lt;/code> - By default, the &amp;ldquo;average&amp;rdquo; parameter replaces
the variable with an averaged version of the data. Adding this flag
specifies that the non-averaged variable should also be dumped to file.&lt;br>
When applied to a variable, these codes are referred to as a &lt;em>dumpmask&lt;/em>.&lt;/li>
&lt;/ul>
&lt;h1 id="directives">Directives&lt;/h1>
&lt;p>The first set of options control the type and frequency of output dumps.
They are used as follows\&lt;/p>
&lt;ul>
&lt;li>&lt;code>disabled&lt;/code> - Logical flag. If this is set to &amp;ldquo;T&amp;rdquo; then the
block is ignored and never generates any output. The default value is
&amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>dt_snapshot&lt;/code> - Sets the interval between normal output
dumps in simulation seconds. Setting zero or negative means that the
code will not output based on this condition. The code does NOT
guarantee that outputs will be exactly &lt;em>dt_snapshot&lt;/em> apart, what is
guaranteed is that the next output will be after the first iteration
which takes the simulation to a time $\ge$ &lt;em>dt_snapshot&lt;/em> from the last
output. As with other variables which specify a unit of time, it can be
specified in more convenient unit by using a multiplication factor (see
[here][maths_parser__constants]). For example,
&amp;ldquo;dt_snapshot = 5 * femto&amp;rdquo; will set it to be 5 femtoseconds. The
default value is a large number which will never trigger an output.\&lt;/li>
&lt;li>&lt;code>nstep_snapshot&lt;/code> - Sets the number of timesteps between
normal output dumps. Setting zero or negative means that the code will
not output based on this condition. If &lt;em>dt_snapshot&lt;/em> is also specified
then both conditions are considered and output will be generated when
either condition is met. The default value is a large integer which will
never trigger an output.\&lt;/li>
&lt;li>&lt;code>full_dump_every&lt;/code> - The number of normal output dumps
between full output dumps. Setting to zero makes every dump a full dump.
Setting to a negative number stops the code from producing any full
dumps. This is the default.\&lt;/li>
&lt;li>&lt;code>restart_dump_every&lt;/code> - The number of normal output dumps
between restart dumps. Setting to zero makes every dump a restart dump.
Setting to a negative number stops the code from producing any restart
dumps. This is the default.\&lt;/li>
&lt;li>&lt;code>force_first_to_be_restartable&lt;/code> - Logical flag which
determines whether the file written at time zero is a restart dump. The
default value is &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>force_last_to_be_restartable&lt;/code> - Force the code to
override other output settings and make the last output dump it writes
be a restart dump. Any internal condition which causes the code to
terminate will make the code write a restart dump, but code crashes or
scheduler terminations will not cause the code to write a restart dump.
&amp;ldquo;force_final_to_be_restartable&amp;rdquo; is accepted as a synonym. The
default value is &amp;ldquo;T&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>dump_first&lt;/code> - Logical flag which determines whether to
write an output file immediately after initialising the simulation. The
default is &amp;ldquo;T&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>dump_last&lt;/code> - Logical flag which determines whether to
write an output file just before ending the simulation. The default is
&amp;ldquo;T&amp;rdquo; if an output block exists in the input deck and &amp;ldquo;F&amp;rdquo; otherwise.
&amp;ldquo;dump_final&amp;rdquo; is accepted as a synonym.\&lt;/li>
&lt;li>&lt;code>time_start&lt;/code> - Floating point parameter which specifies
the simulation time at which to start considering output for the block.
Note that if &amp;ldquo;dump_first&amp;rdquo; or &amp;ldquo;dump_last&amp;rdquo; are set to true for this
block then dumps will occur at the first or last timestep regardless of
the value of the &lt;em>time_start&lt;/em> parameter. This also applies to the three
following parameters. The default value is 0.\&lt;/li>
&lt;li>&lt;code>time_stop&lt;/code> - Floating point parameter which specifies the
simulation time at which to stop considering output for the block. The
default value is the largest possible float.\&lt;/li>
&lt;li>&lt;code>nstep_start&lt;/code> - Integer parameter which specifies the step
number at which to start considering output for the block. The default
value is 0.\&lt;/li>
&lt;li>&lt;code>nstep_stop&lt;/code> - Integer parameter which specifies the step
number at which to stop considering output for the block. The default
value is the largest possible integer.\&lt;/li>
&lt;li>Floating point parameter which specifies the elapsed walltime in
seconds at which to start considering output for the block. Note that if
&lt;strong>dump_first&lt;/strong> or &lt;strong>dump_last&lt;/strong> are set to true for this block then
dumps will occur at the first or last timestep regardless of the value
of the &lt;strong>walltime_start&lt;/strong> parameter. The default value is 0.\&lt;/li>
&lt;li>Floating point parameter which specifies the elapsed walltime in
seconds at which to stop considering output for the block. The default
value is the largest possible float.\&lt;/li>
&lt;li>&lt;code>dump_cycle&lt;/code> - If this is set to a positive integer then
the output file number will be reset to zero after the specified cycle
number is reached. eg. if &amp;ldquo;dump_cycle = 2&amp;rdquo; then the sequence of output
dumps will be 0000.sdf, 0001.sdf, 0002.sdf, 0000.sdf, 0001.sdf, etc. The
default is 0, so dump cycling never occurs.\&lt;/li>
&lt;li>&lt;code>dump_cycle_first_index&lt;/code> - If this is set to a positive
integer then the value is used as the first index to use when cycling
output dumps due to the &amp;ldquo;dump_cycle&amp;rdquo; parameter. For example, if
&amp;ldquo;dump_cycle = 2&amp;rdquo; and &amp;ldquo;dump_cycle_first_index = 1&amp;rdquo; then the sequence
of output dumps will be 0000.sdf, 0001.sdf, 0002.sdf, 0001.sdf,
0002.sdf, 0001.sdf, etc. The default is 0.\&lt;/li>
&lt;li>&lt;code>dump_source_code&lt;/code> - EPOCH has the ability to write its
own source code into restart dumps. This is generated at compile time
and embedded into the binary and so is guaranteed to match that
corresponding to the running code. EPOCH comes with a script called
&lt;em>unpack_source_from_restart&lt;/em> which can be used to unpack the source
code from a restart dump. To use this script, just type&lt;br>
&lt;strong>unpack_source_from_restart &amp;lt;sdf_filename&amp;gt;&lt;/strong> at the command-line. If
this logical flag is set to false then the feature will be disabled. The
default value is &amp;ldquo;T&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>dump_input_decks&lt;/code> - If this logical flag is set to true
then a copy of the input decks for the currently running simulation is
written into the restart dumps. The default value is &amp;ldquo;T&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>dt_average&lt;/code> - When averaged variables are being output to
file, this parameter specifies the simulation time period over which
averaging is to occur. &amp;ldquo;averaging_period&amp;rdquo; is accepted as a synonym.\&lt;/li>
&lt;li>&lt;code>nstep_average&lt;/code> - When averaged variables are being output
to file, this parameter specifies the number of time steps over which
averaging is to occur. &amp;ldquo;min_cycles_per_average&amp;rdquo; is accepted as a
synonym. If both &lt;em>dt_average&lt;/em> and &lt;em>nstep_average&lt;/em> are specified, the
code will use the one which gives the longest simulation time-span.\&lt;/li>
&lt;li>&lt;code>use_offset_grid&lt;/code> - When using moving windows some
visualisation programs (notably VisIt) show the motion of the window by
moving the visualisation window rather than by changing the x-axis.
Setting this option to &amp;ldquo;T&amp;rdquo; causes the code to write another grid which
always gives the offset relative to the left hand edge of the window
rather than the true origin. Performs no function when not using the
moving window. The default value is &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>filesystem&lt;/code> - String parameter. Some filesystems can be
unreliable when performing parallel I/O. Often this is fixable by
prefixing the filename with &amp;lsquo;ufs&amp;rsquo; or &amp;lsquo;nfs&amp;rsquo;. This parameter supplies the
prefix to be used. The default value is an empty string.\&lt;/li>
&lt;li>&lt;code>file_prefix&lt;/code> - Although this parameter is supported by
the traditional style of output block, its primary purpose is for use
with multiple output blocks so it is documented in .&lt;br>
A few additional parameters have been added for use with the new style
of output block. These are documented
&lt;a href="#multiple_output_blocks">below&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h1 id="particle_variables">Particle Variables&lt;/h1>
&lt;p>The next set are per particle properties. If you wish to plot these
according to their spatial positions, you must include the
&amp;ldquo;particle_grid&amp;rdquo; in your output variables. All entries have a default
dumpmask of &amp;ldquo;never&amp;rdquo;.\&lt;/p>
&lt;ul>
&lt;li>&lt;code>particle_grid&lt;/code> - Requests the output of particle
positions. This is a restart variable. No particle variables can be
plotted in VisIt unless this is dumped. If any particle variables are
written then the &amp;ldquo;particle_grid&amp;rdquo; is automatically written unless
&amp;ldquo;particle_grid = never&amp;rdquo; is specified. The synonym &amp;ldquo;particles&amp;rdquo; may also
be used.\&lt;/li>
&lt;li>&lt;code>px,py,pz&lt;/code> - The dumpmasks for the particle momenta.
Restart variable.\&lt;/li>
&lt;li>&lt;code>vx,vy,vz&lt;/code> - The dumpmasks for the particle velocities.\&lt;/li>
&lt;li>&lt;code>charge&lt;/code> - The dumpmask for the charge of a given particle.
This has no effect if the code is not compiled with the flag
&amp;ldquo;-DPER_PARTICLE_CHARGE_MASS&amp;rdquo; (see
&lt;a href="/tutorial/compiler_flags">here&lt;/a> ).\&lt;/li>
&lt;li>&lt;code>mass&lt;/code> - The dumpmask for the mass of a given particles.
This has no effect if the code is not compiled with the flag
&amp;ldquo;-DPER_PARTICLE_CHARGE_MASS&amp;rdquo; (see
&lt;a href="/tutorial/compiler_flags">here&lt;/a>). The synonym
&amp;ldquo;rest_mass&amp;rdquo; may also be used.\&lt;/li>
&lt;li>&lt;code>particle_weight&lt;/code> - The dumpmask for the weighting
function which describes how many real particles each pseudoparticle
represents. Restart variable. The synonym &amp;ldquo;weight&amp;rdquo; may also be used.\&lt;/li>
&lt;li>&lt;code>ejected_particles&lt;/code> - If requested then all the particles
which have left the simulation domain since the last output dump of this
type are included in the output. The list of ejected particles is
treated as if it were a separate species and the particle variables
which get written are requested using the other particle variable flags
(ie. &amp;ldquo;particle_grid&amp;rdquo;, etc). Once the data has been written, the ejected
particle lists are reset and will accumulate particles until the next
requested output dump.\&lt;/li>
&lt;li>&lt;code>particle_energy&lt;/code> - The dumpmask for per-particle kinetic
energy.\&lt;/li>
&lt;li>&lt;code>relativistic_mass&lt;/code> - The dumpmask for per-particle
relativistic mass (ie. not rest mass).\&lt;/li>
&lt;li>&lt;code>gamma&lt;/code> - The dumpmask for per-particle relativistic gamma
(ie. $[1-(v/c)^2]^{-1/2}$).\&lt;/li>
&lt;li>&lt;code>optical_depth&lt;/code> - The dumpmask for per-particle optical
depth. Restart variable. This option is only supplied for debugging
purposes and should not be required by most users.\&lt;/li>
&lt;li>&lt;code>trident_optical_depth&lt;/code> - The dumpmask for per-particle
optical depth used by the Trident model. Restart variable. This option
is only supplied for debugging purposes and should not be required by
most users.\&lt;/li>
&lt;li>&lt;code>qed_energy&lt;/code> - The dumpmask for per-particle QED-related
particle energy. Restart variable. This option is only supplied for
debugging purposes and should not be required by most users.\&lt;/li>
&lt;li>The dumpmask for the work exerted by the fields on each particle
during the last time step. The work is divided into its three spatial
components. The output is in numbers of $mc^2$ corresponding to the
particle&amp;rsquo;s $\gamma$-factor. Requires compiler flag
&amp;ldquo;WORK_DONE_INTEGRATED&amp;rdquo;.\&lt;/li>
&lt;li>Same as above, but the work is integrated over the entire simulation
duration. The sum of all three components equals the particle&amp;rsquo;s
$\gamma$-factor. Requires compiler flag &amp;ldquo;WORK_DONE_INTEGRATED&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>id&lt;/code> - Global particle ID. See below for details.&lt;br>
Particle IDs are useful if you want to track the progress of each
particle throughout the simulation. Since they increase the size of each
particle data structure, they are disabled by default and must be
enabled using a compiler flag. The &amp;ldquo;PARTICLE_ID&amp;rdquo; flag will use an
8-byte integer to represent the ID and &amp;ldquo;PARTICLE_ID4&amp;rdquo; uses a 4-byte
integer. They are written to file using the &amp;ldquo;id&amp;rdquo; flag.&lt;/li>
&lt;/ul>
&lt;p>Note: In the current implementation, the particle IDs are passed between
processors and written to file using REAL numbers. This means that in
double precision the maximum particle ID is $2^{53} \sim 10^{16}$. This
should be ample for the foreseeable future. However, if the code is
compiled for single precision then the maximum ID is
$2^{24} = 16777216$. Probably not big enough.&lt;/p>
&lt;h1 id="grid_variables">Grid Variables&lt;/h1>
&lt;p>The next set of parameters specify properties which are defined on a
regular cartesian mesh. All entries have a default dumpmask of &amp;ldquo;never&amp;rdquo;.\&lt;/p>
&lt;ul>
&lt;li>&lt;code>grid&lt;/code> - The dumpmask for the Cartesian grid which defines
the locations of the grid variables. No grid variables can be plotted in
VisIt unless this variable is output. If any grid variables are written
then the &amp;ldquo;grid&amp;rdquo; is automatically written unless &amp;ldquo;grid = never&amp;rdquo; is
specified. The synonym &amp;ldquo;field_grid&amp;rdquo; may also be used.\&lt;/li>
&lt;li>&lt;code>ex,ey,ez&lt;/code> - The electric field vectors pointing in all
three directions. Restart variables.\&lt;/li>
&lt;li>&lt;code>bx,by,bz&lt;/code> - The magnetic field vectors pointing in all
three directions. Restart variables. In 1D bx is a trivial variable
because of the Solenoidal condition. It is included simply for symmetry
with higher dimension codes.\&lt;/li>
&lt;li>&lt;code>jx,jy,jz&lt;/code> - The current densities pointing in all three
directions. Restart variables. Can have species dumpmask.\&lt;/li>
&lt;/ul>
&lt;h1 id="derived_variables">Derived Variables&lt;/h1>
&lt;p>The final set of parameters specify properties which are not variables
used in the code but are derived from them. The first six variables are
derived by summing properties of all the particles in each grid cell.
The resulting quantities are defined on the regular cartesian mesh used
for grid variables. All entries have a default dumpmask of &amp;ldquo;never&amp;rdquo;.\&lt;/p>
&lt;ul>
&lt;li>&lt;code>ekbar&lt;/code> - Mean kinetic energy on grid in $J$. Can have
species dumpmask.\&lt;/li>
&lt;li>&lt;code>ekflux&lt;/code> - Mean kinetic energy flux in each direction on
the grid in $W/m^2$. Can have species dumpmask.\&lt;/li>
&lt;li>&lt;code>mass_density&lt;/code> - Mass density on grid in $kg/m^3$. Can
have species dumpmask.\&lt;/li>
&lt;li>&lt;code>charge_density&lt;/code> - Charge density on grid in $C/m^3$. Can
have species dumpmask.\&lt;/li>
&lt;li>&lt;code>number_density&lt;/code> - Number density on grid in $m^{-3}$. Can
have species dumpmask.\&lt;/li>
&lt;li>&lt;code>particles per cell&lt;/code> - Number of particles per cell. Can
have species dumpmask. The synonym &amp;ldquo;ppc&amp;rdquo; may also be used.\&lt;/li>
&lt;li>&lt;code>average weight&lt;/code> - Average of weight of the particles in
each cell. Can have species dumpmask.\&lt;/li>
&lt;li>&lt;code>temperature&lt;/code> - Isotropic temperature on grid in $K$.
Calculated from standard deviation of particle momenta, so in general
matches mean kinetic energy only for isotropic plasma with no net drift.
The synonym &amp;ldquo;temp&amp;rdquo; may also be used. Can have species dump mask.&lt;br>
-The temperature in each of the {x,y,z} directions, respectively, in
$K$. The synonyms &amp;ldquo;temp_{x,y,z}&amp;rdquo; and &amp;ldquo;t{x,y,z}&amp;rdquo; may also be used.
Can have species dumpmask.\&lt;/li>
&lt;li>&lt;code>poynt_flux&lt;/code> - Poynting flux in each direction in
$W/m^2$.\&lt;/li>
&lt;/ul>
&lt;h1 id="other_variables">Other Variables&lt;/h1>
&lt;ul>
&lt;li>&lt;code>distribution_functions&lt;/code> - Dumpmask for outputting
distribution functions specified in the input deck. Each individual
distribution function can have its own dumpmask and these will be
applied after the value of &amp;ldquo;distribution_functions&amp;rdquo; has been
considered. For example, if the output block contains
&amp;ldquo;distribution_functions = full&amp;rdquo; and the dist_fn block (see
&lt;a href="/tutorial/input_deck_dist_fn">here&lt;/a>)
contains &amp;ldquo;dumpmask = always&amp;rdquo; then the distribution function will
only be output at full dumps.\&lt;/li>
&lt;li>&lt;code>particle_probes&lt;/code> - Dumpmask for outputting particle
probes specified in the input deck. Each individual particle probe
can have its own dumpmask and these will be applied after the value
of &amp;ldquo;particle_probes&amp;rdquo; has been considered. For example, if the
output block contains &amp;ldquo;particle_probes = always&amp;rdquo; and the dist_fn
block contains &amp;ldquo;dumpmask = full&amp;rdquo; then the particle probe will only
be output at full dumps.\&lt;/li>
&lt;li>&lt;code>absorption&lt;/code> - This is a two-valued output variable. It
accepts a dumpmask in the same manner as other output variables.
When selected, two numbers will be calculated and written to file:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>&amp;ldquo;Absorption/Laser_enTotal&amp;rdquo; - The total amount of energy injected
into the simulation by laser boundaries.&lt;/li>
&lt;li>&amp;ldquo;Absorption/Abs_frac&amp;rdquo; - The fraction of the total laser energy
being absorbed by the open boundaries.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;code>total_energy_sum&lt;/code> - This is also a two-valued output
variable. It accepts a dumpmask in the same manner as other output
variables. When selected, the following two numbers will be
calculated and written to file:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>&amp;ldquo;Total Particle Energy in Simulation (J)&amp;rdquo;&lt;/li>
&lt;li>&amp;ldquo;Total Field Energy in Simulation (J)&amp;rdquo;&lt;/li>
&lt;/ol>
&lt;h1 id="data_averaging">Data Averaging&lt;/h1>
&lt;p>EPOCH can accumulate an average value for field variables to be written
to output dumps. These may be requested by using the &amp;ldquo;average&amp;rdquo; keyword
when specifying a dump variable. The non-averaged variable will still be
written to restart dumps where required for restarting the code but not
full or normal dumps. If you also want the non-averaged variable to be
written then you can add the &amp;ldquo;snapshot&amp;rdquo; option.&lt;/p>
&lt;p>The period of time over which averaging occurs can be specified using
the &amp;ldquo;dt_average&amp;rdquo; keyword. Alternatively, you may specify the number of
cycles over which to perform the averaging using the &amp;ldquo;nstep_average&amp;rdquo;
keyword. If both &amp;ldquo;dt_average&amp;rdquo; and &amp;ldquo;nstep_average&amp;rdquo; are specified then
the averaging will be performed over the longest of the two intervals.&lt;/p>
&lt;p>Note that previous versions of the code would alter the time step to
ensure that there were enough cycles between output dumps to satisfy the
&amp;ldquo;nstep_average&amp;rdquo; parameter. However, since it affects the accuracy of
the result, this is no longer the case and only a warning message is
issued.&lt;/p>
&lt;p>The following shows an example use of averaging in the output block.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
dt_snapshot = 1.0e-15
full_dump_every = 10
dt_average = 1.0e-17
charge_density = always + average + snapshot
mass_density = full + average + snapshot
ekbar = full + average
end:output
&lt;/code>&lt;/pre>
&lt;p>With this configuration, &amp;ldquo;charge_density&amp;rdquo; will be written in both
normal and averaged form at normal, full and restart dumps.
&amp;ldquo;mass_density&amp;rdquo; will be written in both forms at full dumps. Only the
average value of &amp;ldquo;ekbar&amp;rdquo; will be written at full dumps.&lt;/p>
&lt;p>Only field and derived variables can be averaged currently in EPOCH.
Particle properties, distribution functions and particle probes cannot
currently be averaged.&lt;/p>
&lt;h1 id="single_precision_output">Single-precision output&lt;/h1>
&lt;p>By default, EPOCH is compiled and run using double precision arithmetic.
This is the only method which has been fully tested and the method that
we recommend to other users of the code. However, this also means that
data files can get very large.&lt;/p>
&lt;p>To avoid this problem, it is possible to run the code in double
precision but convert the data to single precision when writing to disk.
This is done by adding the &amp;ldquo;single&amp;rdquo; field the the dumpmask of an output
variable. It can be specified on a per-variable basis.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
dt_snapshot = 8 * femto
grid = always
ex = always
ey = always + single
end:output
&lt;/code>&lt;/pre>
&lt;p>In this example, the grid variable &amp;ldquo;ex&amp;rdquo; will be written as a double
precision array and &amp;ldquo;ey&amp;rdquo; will be converted to single precision.&lt;/p>
&lt;p>Dumping variable averages adds an extra field variable for each average
requested. These take up memory during runtime but do not influence the
simulation behaviour in any way. For this reason, if the average is to
be written out in single precision then it may as well be stored in a
single precision variable. This behaviour can be requested using the
&amp;ldquo;average_single&amp;rdquo; dumpmask flag.&lt;/p>
&lt;h1 id="multiple_output_blocks">Multiple output blocks&lt;/h1>
&lt;p>In more recent versions of EPOCH, it is now possible to have multiple
&amp;ldquo;output&amp;rdquo; blocks in the input deck, each with their own &amp;ldquo;dt_snapshot&amp;rdquo; or
&amp;ldquo;nstep_snapshot&amp;rdquo; and their own set of output variables.&lt;/p>
&lt;p>The syntax remains the same as the original &amp;ldquo;output&amp;rdquo; block syntax with
the addition of &amp;ldquo;name&amp;rdquo; and &amp;ldquo;restartable&amp;rdquo; fields.&lt;/p>
&lt;p>The &amp;ldquo;name&amp;rdquo; field specifies the file name to use for the output list.
Each time EPOCH generates an output dump, it writes an entry into the
file &amp;ldquo;&lt;code>&amp;lt;name&amp;gt;.visit&lt;/code>&amp;rdquo;. This can be used to find all the output dumps of
a specific output block. It is named with a &amp;ldquo;.visit&amp;rdquo; suffix to enable
its use as a file grouping list in the VisIt data analysis tool, but it
is just a plain text file so it can equally be used by any other
program.&lt;/p>
&lt;p>If two output blocks are written at the same time, the output will be
combined into a single file.&lt;/p>
&lt;p>The &amp;ldquo;restartable&amp;rdquo; field specifies that the output block should generate
output dumps containing all the information necessary to restart a
simulation.&lt;/p>
&lt;p>The following parameters are supported by the new style of output block
in addition to those for the traditional style:&lt;/p>
&lt;ul>
&lt;li>&lt;code>name&lt;/code> - Identifies the output block with a name which is
required when multiple output blocks are used.\&lt;/li>
&lt;li>&lt;code>restartable&lt;/code> - Specifies whether or not the output for
this block is a restartable dump.\&lt;/li>
&lt;li>&lt;code>dump_at_times&lt;/code> - Floating point parameter which
specifies a set of simulation times at which to write the current
output block. This can only be used with named output blocks. The
values are given as a comma separated list. eg. &amp;ldquo;dump_at_times =
0, 0.15, 1.1&amp;rdquo;. The name &amp;ldquo;times_dump&amp;rdquo; is accepted as a synonym. By
default the list is empty.\&lt;/li>
&lt;li>&lt;code>dump_at_nsteps&lt;/code> - Integer parameter which specifies a
set of step numbers at which to write the current output block. This
can only be used with named output blocks. The values are given as a
comma separated list. eg. &amp;ldquo;dump_at_nsteps = 5, 11, 15&amp;rdquo;. The name
&amp;ldquo;nsteps_dump&amp;rdquo; is accepted as a synonym. By default the list is
empty.\&lt;/li>
&lt;/ul>
&lt;p>- Floating point parameter which specifies a set of elapsed walltimes
at which to write the current output block. This can only be used with
named output blocks. The values are given as a comma separated list. eg.
&amp;ldquo;dump_at_walltimes = 10, 100.1, 250.5&amp;rdquo;. These times are the total
elapsed time in seconds since the start of the simulation. Note that if
the simulation has been restarted then the total elapsed time will
include the accumulated walltime of all previous runs that were used to
produce the restart dump. The name &lt;strong>walltimes_dump&lt;/strong> is accepted as a
synonym. By default the list is empty.\&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Floating point parameter which specifies the interval between output
dumps in elapsed walltime seconds. Setting zero or negative means that
the code will not output based on this condition. The default value is
-1.0.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>file_prefix&lt;/code> - String parameter. It is sometimes useful
to distinguish between dumps generated by the different output blocks.
This parameter allows the user to supply a file prefix to be prepended
to all dumps generated by the current output block. See below for
further details. The default value is an empty string.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>rolling_restart&lt;/code> - Logical flag. If set to &amp;ldquo;T&amp;rdquo;, this sets
the parameters required for performing rolling restarts on the current
block. It is a shorthand for setting the following flags: &amp;ldquo;dump_cycle =
1&amp;rdquo;, &amp;ldquo;restartable = T&amp;rdquo; and &amp;ldquo;file_prefix = roll&amp;rdquo;. With rolling restarts
enabled the first file will be named &amp;ldquo;roll0000.sdf&amp;rdquo; and the second will
be &amp;ldquo;roll0001.sdf&amp;rdquo;. The third dump will again be named &amp;ldquo;roll0000.sdf&amp;rdquo;,
overwriting the first one. In this way, restart dumps can be generated
throughout the duration of the simulation whilst limiting the amount of
disk space used.&lt;br>
The following parameters cannot be used in conjunction with the new
style of output block:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>full_dump_every&lt;/p>
&lt;/li>
&lt;li>
&lt;p>restart_dump_every&lt;/p>
&lt;/li>
&lt;li>
&lt;p>force_first_to_be_restartable&lt;/p>
&lt;/li>
&lt;li>
&lt;p>force_last_to_be_restartable&lt;/p>
&lt;/li>
&lt;li>
&lt;p>use_offset_grid&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The &amp;ldquo;file_prefix&amp;rdquo; parameter warrants some further discussion. This
parameter prepends the given prefix to all files generated by the output
block in which it is specified. For example, if &amp;ldquo;file_prefix = aa&amp;rdquo; is
set then files generated by the output block will be named &amp;ldquo;aa0000.sdf&amp;rdquo;,
etc. instead of just &amp;ldquo;0000.sdf&amp;rdquo;.&lt;/p>
&lt;p>This also allows different variables to different files at the same time
step. For example, here are two output blocks which do not use file
prefixes:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
name = o1
nstep_snapshot = 1
charge_density = always
end:output
begin:output
name = o2
dump_at_nsteps = 10
restartable = T
end:output
&lt;/code>&lt;/pre>
&lt;p>With this input deck, we want to have the &amp;ldquo;charge_density&amp;rdquo; derived
variable at every snapshot and then periodically write a restart dump.
The problem is that the dump file &amp;ldquo;0010.sdf&amp;rdquo; contains both the restart
information and the &amp;ldquo;charge_density&amp;rdquo; variable. At the end of the run we
can&amp;rsquo;t just delete the large restart dumps without losing the smaller
variables at that time step.&lt;/p>
&lt;p>With the new version we would add a prefix to one or both blocks:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
name = o1
file_prefix = small
nstep_snapshot = 1
charge_density = always
end:output
begin:output
name = o2
nstep_snapshot = 10
restartable = T
end:output
&lt;/code>&lt;/pre>
&lt;p>Now the &amp;ldquo;charge_density&amp;rdquo; will be written to &amp;ldquo;small0000.sdf&amp;rdquo;, etc. At
step 10, two files will be written: &amp;ldquo;small0010.sdf&amp;rdquo; containing just the
charge_density and &amp;ldquo;0000.sdf&amp;rdquo; containing all the restart variables.&lt;/p>
&lt;p>Note that some care must be taken, since if the same variable is in the
output block for multiple file prefixes then multiple copies will be
written to file. This obviously uses more disk space and is more time
consuming than necessary.&lt;/p>
&lt;p>It should also be noted that if multiple output blocks use the same file
stem then their output will be combined. eg:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
name = o1
file_prefix = a
dump_at_nsteps = 2,4
ex = always
end:output
begin:output
name = o2
file_prefix = a
dump_at_nsteps = 3,4
ey = always
end:output
begin:output
name = o3
file_prefix = b
dump_at_nsteps = 4
ez = always
end:output
&lt;/code>&lt;/pre>
&lt;p>In this example, at step 2 a0000.sdf contains ex, step 3 a0001.sdf
contains ey, step 4 a0002.sdf contains ex, ey and b0000.sdf contains ez.&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_output_global">The output global block&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_output_global/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_output_global/</guid><description>&lt;p>This block contains parameters which should be applied to all output
blocks. See
&lt;a href="/tutorial/input_deck">EPOCH input deck&lt;/a> for more
information on the input deck.&lt;/p>
&lt;p>With the introduction of multiple output blocks, there are now a few
parameters that only make sense to be applied globally across all output
blocks. To accommodate this, a new block named &amp;ldquo;output_global&amp;rdquo; has been
added. Most of the parameters accepted by this block have the same
meaning as those in the &amp;ldquo;output&amp;rdquo; block except that they are applied to
all &amp;ldquo;output&amp;rdquo; blocks.&lt;/p>
&lt;p>The parameters that can be specified in the &amp;ldquo;output_global&amp;rdquo; block are
as follows:\&lt;/p>
&lt;ul>
&lt;li>&lt;code>force_first_to_be_restartable&lt;/code> - Logical flag which
determines whether the file written at time zero is a restart dump. The
default value is &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>force_last_to_be_restartable&lt;/code> - Force the code to
override other output settings and make the last output dump it writes
be a restart dump. Any internal condition which causes the code to
terminate will make the code write a restart dump, but code crashes or
scheduler terminations will not cause the code to write a restart dump.
&amp;ldquo;force_final_to_be_restartable&amp;rdquo; is accepted as a synonym. The
default value is &amp;ldquo;T&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>dump_first&lt;/code> - Logical flag which determines whether to
write an output file immediately after initialising the simulation. The
default is &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>dump_last&lt;/code> - Logical flag which determines whether to
write an output file just before ending the simulation. The default is
&amp;ldquo;T&amp;rdquo; if an output block exists in the input deck and &amp;ldquo;F&amp;rdquo; otherwise.
&amp;ldquo;dump_final&amp;rdquo; is accepted as a synonym.\&lt;/li>
&lt;li>&lt;code>time_start&lt;/code> - Floating point parameter which specifies
the simulation time at which to start considering output for all output
blocks. Note that if &amp;ldquo;dump_first&amp;rdquo; or &amp;ldquo;dump_last&amp;rdquo; are set to true for
any block then dumps will occur at the first or last timestep regardless
of the value of this parameter. This also applies to the three following
parameters. The default value is 0.\&lt;/li>
&lt;li>&lt;code>time_stop&lt;/code> - Floating point parameter which specifies the
simulation time at which to stop considering output for all output
blocks. The default value is the largest possible float.\&lt;/li>
&lt;li>&lt;code>nstep_start&lt;/code> - Integer parameter which specifies the step
number at which to start considering output for the block. The default
value is 0.\&lt;/li>
&lt;li>&lt;code>nstep_stop&lt;/code> - Integer parameter which specifies the step
number at which to stop considering output for the block. The default
value is the largest possible integer.\&lt;/li>
&lt;li>Floating point parameter which specifies the elapsed walltime in
seconds at which to start considering output for all output blocks. Note
that if &lt;strong>dump_first&lt;/strong> or &lt;strong>dump_last&lt;/strong> are set to true for any blocks
then dumps will occur at the first or last timestep regardless of the
value of the &lt;strong>walltime_start&lt;/strong> parameter. The default value is 0.\&lt;/li>
&lt;li>Floating point parameter which specifies the elapsed walltime in
seconds at which to stop considering output all output blocks. The
default value is the largest possible float.\&lt;/li>
&lt;li>&lt;code>sdf_buffer_size&lt;/code> - Integer parameter. When writing
particle data to an SDF file, the data is first transferred into an
output buffer. The size of this buffer can have a big impact on the
overall speed of writing dump files. This parameter allows the size of
the buffer to be specified in bytes. The default value is 67108864 (64
MB).\&lt;/li>
&lt;li>&lt;code>filesystem&lt;/code> - String parameter. Some filesystems can be
unreliable when performing parallel I/O. Often this is fixable by
prefixing the filename with &amp;lsquo;ufs&amp;rsquo; or &amp;lsquo;nfs&amp;rsquo;. This parameter supplies the
prefix to be used. The default value is an empty string.\&lt;/li>
&lt;li>&lt;code>use_offset_grid&lt;/code> - When using moving windows some
visualisation programs (notably VisIt) show the motion of the window by
moving the visualisation window rather than by changing the x-axis.
Setting this option to &amp;ldquo;T&amp;rdquo; causes the code to write another grid which
always gives the offset relative to the left hand edge of the window
rather than the true origin. Performs no function when not using the
moving window. The default value is &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code> dump_first_after_restart&lt;/code> - Logical flag to enable a
dump to occur immediately after restart. In the past, a &lt;code>dump_first&lt;/code>
flag in the output block would cause an output dump immediately after
restarting. Since this is rarely the desired behaviour, the flag is now
ignored when restarting. To force a dump to occur immediately after
restart, set &lt;code>dump_first_after_restart = T&lt;/code> in the output block. The
default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_dist_fn">The dist_fn block&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_particle_file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_particle_file/</guid><description>&lt;p>This block contains information about the block used to load particles
from file. See
&lt;a href="/tutorial/input_deck">EPOCH input deck&lt;/a> for more
information on the input deck.&lt;/p>
&lt;p>The particles_from_file block is similar in function to the fields
block, it allows the loading of custom particle data from raw binary
data files. An example usage of the block is shown below&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:particles_from_file
species = &amp;quot;electron&amp;quot;
# Load mandatory data for 3D simulation
x_data = &amp;quot;xdata.dat&amp;quot;
y_data = &amp;quot;ydata.dat&amp;quot;
z_data = &amp;quot;ydata.dat&amp;quot;
w_data = &amp;quot;ydata.dat&amp;quot;
# Load particle ids in 4 byte int format,
# ignoring first 8 bytes of file
#offset = 8
#id4_data = &amp;quot;iddata.dat&amp;quot;
end:particles_from_file
&lt;/code>&lt;/pre>
&lt;p>Specifying a particles_from_file block for a species causes EPOCH to
load the per-particle data from the specified files. Data files are
assumed to be in order such that the first variable in each file will be
attributed to one particle, the second variable in each file to a second
electron, and so on. A target species to load to, as well as particle
position and weight data (unless has been set) must be supplied. With
the exception of particle ID, any optional parameters which are left
unspecified will be initialised to zero.&lt;br>
If the code has been compiled with or then particle IDs may be loaded
from a raw binary file of integers of either size 4 or size 8 regardless
of the compile time flag choice. If no particle ID data is supplied, IDs
will be generated sequentially from 1.&lt;br>
All other data should be in the form of floating point numbers of the
same precision as in the core code.&lt;br>
A particles_from_file block accepts the following parameters:\&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>species&lt;/code> - Name of the species to which the particles will
be loaded. This is a mandatory parameter and the corresponding species
block must be defined.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{x,y,z}_data&lt;/code> - File containing particle position data in
$m$. This data must be supplied, up to the dimensionality of the
simulation.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>w_data&lt;/code> - File containing pseudoparticle weight, this is
the number of real particles the pseudoparticle represents. This data
must be supplied.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>{px,py,pz}_data&lt;/code> - File containing particle momentum
data in $kg,ms^{-1}$. The default value is zero.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>id{4,8}_data&lt;/code> - File containing particle IDs in either
4 or 8 byte unsigned integer representation.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>offset&lt;/code> - File offset. Number of bytes at the head of
the file to be ignored, may be specified multiple times. see for
more details of behaviour.\&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_window">The window block&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_pipeline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_pipeline/</guid><description>&lt;p>The new, more flexible output system in the Epoch 5.0 series is around
the concept of a &amp;lsquo;pipeline&amp;rsquo;. These are designed to allow as much
in-code data reduction as possible. A pipeline for outputting particle
data lets you go through a series of selection steps so that you output
only the particles you&amp;rsquo;re actually interested in. As in the older
system, you can select by species or momentum, make a random selection,
or track only those particles that have left the system. Unlike the
older system, you can also produce much more complex selection operators
such as tracking all those particles that started the simulation in a
particular grid cell. Additionally, distributions functions have been
made much more flexible, adding more axes and allowing you to directly
output e.g. energy as a function of angle.&lt;/p>
&lt;p>Pipelines start with a source of particles (usually the name of a
species or probe), apply a series of operators to select some subset of
these, and then produce a series of outputs, either raw particle data or
derived variables such as number density on a grid. Grid based or
distribution function outputs can be further processed to restrict in
space, average over time, etc.&lt;/p>
&lt;p>Everything that was possible under the old system remains possible, and
decks should continue to work as before. More complex decks may benefit
from rewriting in the new system.&lt;/p>
&lt;h1 id="simple_outputs_in_old_and_new_systems">Simple outputs in old and new systems&lt;/h1>
&lt;p>Before going through the details of the new pipelines, we show a few
examples compared to the old system to illustrate the general structure
and benefits.&lt;/p>
&lt;p>A typical output using the old system is something like this, taken from
the two-stream deck (tests/twostream/input.deck)&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
... # Omitting dumptime specs etc
# Properties at particle positions
particles = always
px = always
# Properties on grid
grid = always
ex = always
number_density = always + species
end:output
&lt;/code>&lt;/pre>
&lt;p>We can reproduce this with pipelines&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:pipeline
name = particles # Pipeline name, for use in output block where timings are set
species : Left, Right # Do sum of Left and Right
species : Left # Also output Left only
species : Right # Also output Right only
particle_variable : dir_px # Output px
derived_variable : number_density # Built in number density output
field_variable : io_ex # Output ex also
end:pipeline
&lt;/code>&lt;/pre>
&lt;p>Doing more complex selection in the old system used the concept of
subsets, such as&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:subset
name = mysub
random_fraction = 0.1
include_species : Left
include_species : Right
end:subset
begin:output
... # Omitting dumptime specs etc
# Properties on grid
grid = always
number_density = always + species + mysub
end:output
&lt;/code>&lt;/pre>
&lt;p>which now becomes&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:pipeline
name = particles
species : Left
species : Right
particle_operator : random_fraction(0.1)
derived_variable : number_density # Built in number density output
end:pipeline
&lt;/code>&lt;/pre>
&lt;h1 id="a_more_complex_output">A more complex output&lt;/h1>
&lt;p>The real power of the pipelines is to shorten and simplify relatively
complex output specs using multiple selectors, which would previously
have required multiple subsets. For instance, if we have multiple
ionisation states, but the high-numbered ones contain very few
particles, so we want to sum their number densities, we would have used
something like&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:subset
name = base
random_fraction = 0.1
include_species : Carbon
end:subset
begin:subset
name = one
random_fraction = 0.1
include_species : Carbon1
end:subset
begin:subset
name = two
random_fraction = 0.1
include_species : Carbon2
end:subset
begin:subset
name = high
random_fraction = 0.1
include_species : Carbon3
include_species : Carbon4
include_species : Carbon5
end:subset
begin:output
number_density = always + base + one + two + high + sum
end:output
&lt;/code>&lt;/pre>
&lt;p>where with pipelines we can specify the species directly, as&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:pipeline
name = particles
species: Carbon
species : Carbon1
species : Carbon2
species : Carbon3, Carbon4, Carbon5
particle_operator : random_fraction(0.1)
derived_variable : number_density
end:pipeline
&lt;/code>&lt;/pre>
&lt;p>and it&amp;rsquo;s now far easier to add more selection criteria, such as a
momentum lower bound etc.&lt;/p>
&lt;h1 id="block_details">Block details&lt;/h1>
&lt;p>A typical new output pipeline might look something like&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:pipeline
name = pipe1
species : electron
species : electron, proton
ejected_species : electron
probe : probe1
particle_operator : restriction_op
particle_operator : random_fraction(0.01)
particle_variable : dir_px
particle_variable : dir_vz
derived_variable : number_density # Built in number density output
derived_variable : x_px_df # User specified distribution function specified by name
field_variable : io_ex
end:pipeline
&lt;/code>&lt;/pre>
&lt;p>This will create 4 sets of output, for electrons, the sum of electrons
and protons, ejected electrons and for probe1. An unspecified
restriction is applied, and a random fraction of 1% of the particles are
used. Particle x momentum and z velocity are included in the output. It
also outputs the number density for each species, a custom distribution
function (see below) and the ex field.&lt;/p>
&lt;p>The keys are described below. Note that most keys are optional, but:&lt;/p>
&lt;ul>
&lt;li>Name is a required key&lt;/li>
&lt;li>If you don&amp;rsquo;t specify any [particle,derived,field]_variable keys
nothing will be output&lt;/li>
&lt;li>Operators are applied in the order specified. This should never
change the output, but may have minor effects on memory and time
taken&lt;/li>
&lt;/ul>
&lt;h3 id="name">Name&lt;/h3>
&lt;p>All pipelines must be named using the name key. This is to allow them to
be referred to in output blocks&lt;/p>
&lt;h3 id="particle_sources">Particle sources&lt;/h3>
&lt;p>Particle sources are specified using one of the following keys&lt;/p>
&lt;ul>
&lt;li>species - Named species or list of species to output. For each new
species key a new output pipeline for just that species is created.
If a comma separated list of species is specified then the output is
calculated summed over that species&lt;/li>
&lt;li>ejected_species - Named species to output. This outputs particle
data for all particles that have left the domain going through any
of the boundaries. Particles that remain in the domain after
interacting with the boundary (such as through thermal or periodic
boundaries) are not considered ejected. Particles that leave due to
the moving window are not considered ejected.&lt;/li>
&lt;li>probe - Named particle probe. All species specified in the probe are
summed over for output&lt;/li>
&lt;/ul>
&lt;p>For all outputs except for field_variable outputs require at lest one
particle source. No output will be generated if no particle sources are
specified&lt;/p>
&lt;h3 id="particle_operators">Particle operators&lt;/h3>
&lt;p>Particle operators are specified with the particle_operator keyword and
may be either the name of a
&lt;a href="/tutorial/input_deck_operator">named operator
block&lt;/a> or a constructor function
for a particle operator (such as random_fraction)&lt;/p>
&lt;h3 id="particle_variable_output">Particle variable output&lt;/h3>
&lt;p>You can specify any
&lt;a href="/tutorial/calculable_particle_properties">calculable particle
property&lt;/a> known to
EPOCH as a particle output variable. Simply specify the
particle_variable key, followed by the named calculable particle
property&lt;/p>
&lt;h3 id="derived_variables">Derived variables&lt;/h3>
&lt;p>A derived variable is any output that is ultimately derived from a
particle source. This is either a user specified
&lt;a href="/tutorial/input_deck_adf">advanced distribution
function&lt;/a>, specified by name, or a
built in named derived variable. All of the built in variables are
defined on the main simulation grid. The build in derived variables are&lt;/p>
&lt;ul>
&lt;li>number_density - Output particle number density&lt;/li>
&lt;li>temperature - Particle temperature&lt;/li>
&lt;li>ekbar - Particle mean kinetic energy&lt;/li>
&lt;li>mass_density - Mass density&lt;/li>
&lt;li>charge_density - Charge density&lt;/li>
&lt;li>particles_per_cell - Particles per cell diagnostic&lt;/li>
&lt;li>px_bar - Mean x momentum in each cell&lt;/li>
&lt;li>py_bar - Mean y momentum in each cell&lt;/li>
&lt;li>pz_bar - Mean z momentum in each cell&lt;/li>
&lt;li>modp_bar - Mean total momentum in each cell&lt;/li>
&lt;li>vx_bar - Mean x velocity in each cell&lt;/li>
&lt;li>vy_bar - Mean y velocity in each cell&lt;/li>
&lt;li>vz_bar - Mean z velocity in each cell&lt;/li>
&lt;li>modv_bar - Mean total velocity in each cell&lt;/li>
&lt;/ul>
&lt;h3 id="field_variables">Field variables&lt;/h3>
&lt;p>A field variable is any output on a grid that is not derived from a
particle source and are specified by name. The possible names are&lt;/p>
&lt;ul>
&lt;li>poynting_x - Poynting flux in X&lt;/li>
&lt;li>poynting_y - Poynting flux in Y&lt;/li>
&lt;li>poynting_z - Poynting flux in Z&lt;/li>
&lt;li>io_ex - Ex field&lt;/li>
&lt;li>io_ey - Ey field&lt;/li>
&lt;li>io_ez - Ez field&lt;/li>
&lt;li>io_bx - Bx field&lt;/li>
&lt;li>io_by - By field&lt;/li>
&lt;li>io_bz - Bz field&lt;/li>
&lt;li>io_jx - Jx field&lt;/li>
&lt;li>io_jy - Jy field&lt;/li>
&lt;li>io_jy - Jz field&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_probe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_probe/</guid><description>&lt;p>This block contains information about particle probes used for output.
See
&lt;a href="/tutorial/input_deck">EPOCH input deck&lt;/a> for more information
on the input deck.&lt;/p>
&lt;p>Sometimes it is useful to consider all the properties of particle which
pass through a point/line/plane (depending on dimension) in the
simulation. To allow this, it is possible to specify one or more
&lt;em>&lt;code>Particle Probe&lt;/code>&lt;/em> blocks in the input deck. These record
copies of all particles which cross a point/line/plane in a given
direction which meet minimum and maximum kinetic energy criteria and
output the particle properties into the normal output files. Particle
probes record the positions, momenta and weight of all particles passing
through the plane. To use particle probes, the code must not have been
compiled with the &lt;strong>&lt;code>-DNO_PARTICLE_PROBES&lt;/code>&lt;/strong> compiler option. This is a
fairly heavyweight diagnostic since each particle position must be
tested from within the particle push. The code will run faster if it is
not compiled in.&lt;br>
The probe is specified in terms of a point in the plane and the normal
vector to the plane which is to be monitored. Particles are only
recorded if they cross the plane in the direction given by the normal
vector. If you want to record particles travelling in both directions
then use two particle probes, one with an opposite signed normal vector
to the other.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:probe
name = electron_back_probe
point = (50.0e-6, -50.0e-6)
normal = (1.0, 0.0)
ek_min = 0.0
ek_max = -1.0
include_species : s1
dumpmask = always
end:probe
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>name&lt;/code> - The name that the probe should have in output
dumps. Output variables are then named this as a prefix. For
example, the block shown above will result in the name
&lt;strong>electron_back_probe_px&lt;/strong> for the x momentum. The particle
positions would just be called &lt;strong>electron_back_probe&lt;/strong>.\&lt;/li>
&lt;li>&lt;code>point&lt;/code> - An arbitrary point in the plane of the probe.\&lt;/li>
&lt;li>&lt;code>normal&lt;/code> - A vector normal to the plane of the probe, in
the direction of crossings you wish to monitor.\&lt;/li>
&lt;li>&lt;code>include_species&lt;/code> - The species to which this probe
should be applied. To probe several species, use several probe
blocks in the input deck. &amp;ldquo;probe_species&amp;rdquo; is accepted as a
synonym.\&lt;/li>
&lt;li>&lt;code>ek_min&lt;/code> - The minimum kinetic energy of particles to
store information about. Set to 0 for no minimum kinetic energy.\&lt;/li>
&lt;li>&lt;code>ek_max&lt;/code> - The maximum kinetic energy of particles to
store information about. Set to -1 for no maximum kinetic energy.\&lt;/li>
&lt;li>&lt;code>dumpmask&lt;/code> - The dump code for this particle probe. This
is the same as that for the main output controls in &lt;strong>input.deck&lt;/strong>.
Note that the code has to store copies of particles which pass
through the probe until a dump occurs. This means that the code&amp;rsquo;s
memory requirements can increase drastically if this code only dumps
probe information infrequently. If this is set to &lt;strong>never&lt;/strong> then the
code effectively never uses the probe.\&lt;/li>
&lt;/ul>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_collisions">The collisions block&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_qed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_qed/</guid><description>&lt;p>This block contains information about QED pair production. See
&lt;a href="/tutorial/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;p>EPOCH can model QED pair production, synchrotron emission and radiation
reaction as described in Duclous et al&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> and Ridgers et al. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> It is
enabled using the compiler flag &lt;strong>&lt;code>-DPHOTONS&lt;/code>&lt;/strong>. Additionally, the
Trident process is enabled using &lt;strong>&lt;code>-DTRIDENT_PHOTONS&lt;/code>&lt;/strong>.&lt;/p>
&lt;p>A new input deck block named &amp;ldquo;qed&amp;rdquo; has been added which accepts the
following parameters:\&lt;/p>
&lt;ul>
&lt;li>&lt;code>use_qed&lt;/code> - Logical flag which turns QED on or off. The
default is &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>qed_start_time&lt;/code> - Floating point value specifying the
time after which QED effects should be turned on. The default is 0.\&lt;/li>
&lt;li>&lt;code>produce_photons&lt;/code> - Logical flag which specifies whether
to track the photons generated by synchrotron emission. If this is &amp;ldquo;F&amp;rdquo;
then the radiation reaction force is calculated but the properties of
the emitted photons are not tracked. The default is &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>photon_energy_min&lt;/code> - Minimum energy of produced photons.
Radiation reaction is calculated for photons of all energies, but
photons with energy below this cutoff are not tracked. The default is
0.\&lt;/li>
&lt;li>&lt;code>photon_dynamics&lt;/code> - Logical flag which specifies whether
to push photons. If &amp;ldquo;F&amp;rdquo; then photons are generated, but their motion
through the domain is not simulated and they stay where they were
generated. The default is &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>produce_pairs&lt;/code> - Logical flag which determines whether or
not to simulate the process of pair generation from gamma ray photons.
Both produce_photons and photon_dynamics must be &amp;ldquo;T&amp;rdquo; for this to work.
The default is &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>qed_table_location&lt;/code> - EPOCH&amp;rsquo;s QED routines use lookup
tables to calculate gamma ray emission and pair production. If you want
to use tables in a different location from the default, specify the new
location using this parameter. The default is
&amp;ldquo;src/physics_packages/TABLES&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>use_radiation_reaction&lt;/code> - Logical flag which determines
whether or not to calculate the radiation reaction force. If set to &amp;ldquo;F&amp;rdquo;
then the force is not calculated. This should nearly always be enabled
when using the QED model. It is only provided for testing purposes. The
default value is &amp;ldquo;T&amp;rdquo;.&lt;br>
QED also requires that the code now know which species are electrons,
positrons and photons. The species type is specified using a single
&amp;ldquo;identify&amp;rdquo; tag in a species block. To specify an electron the block in
the deck would look like&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-perl">begin:species
name = electron
frac = 0.5
number_density = 7.7e29
identify:electron
end:species
&lt;/code>&lt;/pre>
&lt;p>Once the identity of a species is set then the code automatically
assigns mass and charge states for the species. Possible identities
are:\&lt;/p>
&lt;ul>
&lt;li>&lt;code>electron&lt;/code> - A normal electron species. All species of
electrons in the simulation must be identified in this way or they will
not generate photons.\&lt;/li>
&lt;li>&lt;code>positron&lt;/code> - A normal positron species. All species of
positron in the simulation must be identified in this way or they will
not generate photons.\&lt;/li>
&lt;li>&lt;code>photon&lt;/code> - A normal photon species. One species of this
type is needed for photon production to work. If multiple species are
present then generated photons will appear in the first species of this
type.\&lt;/li>
&lt;li>&lt;code>bw_electron&lt;/code> - The electron species for pair production
by the Breit-Wheeler process. If a species of this type exists then
electrons from the pair production module will be created in this
species. If no species of this type is specified then pair electrons
will be generated in the first electron species.\&lt;/li>
&lt;li>&lt;code>bw_positron&lt;/code> - As above but for positrons.\&lt;/li>
&lt;li>&lt;code>trident_electron&lt;/code> - The electron species for pair
production by the Trident process. If a species of this type exists then
electrons from the pair production module will be created in this
species. If no species of this type is specified then pair electrons
will be generated in the first electron species.\&lt;/li>
&lt;li>&lt;code>trident_positron&lt;/code> - As above but for positrons.\&lt;/li>
&lt;li>&lt;code>proton&lt;/code> - A normal proton species. This is for convenience
only and is not required by the pair production routines.&lt;br>
A species should be identified only once, so a &amp;ldquo;bw_electron&amp;rdquo; species
does not need to also be identified as an &amp;ldquo;electron&amp;rdquo; species. If the
code is running with &amp;ldquo;produce_photons=T&amp;rdquo; then a photon species must be
created by the user and identified. If the code is running with
&amp;ldquo;produce_pairs=T&amp;rdquo; then the code must specify at least one electron (or
bw_electron) species and one positron (or bw_positron) species. These
species will usually be defined with zero particles from the start of
the simulation and will accumulate particles as the simulation
progresses. The code will fail to run if the needed species are not
specified.&lt;/li>
&lt;/ul>
&lt;p>The basic input deck has now been considered fully but it is possible
for an end user to add new blocks to the input deck As a result, a
version of the code which you have obtained from a source other than the
Warwick GitLab server may include other input deck blocks. These should
be described in additional documentation provided with the version of
the code that you have.&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_subset">The subset block&lt;/a>&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>R. Duclous, J. G. Kirk, and A. R. Bell, &amp;ldquo;Monte carlo calculations
of pair production in high-intensity laserplasma interactions,&amp;rdquo;
Plasma Phys. Contr. F., vol. 53, no. 1, p. 015009,
2011
&lt;a href="http://iopscience.iop.org/article/10.1088/0741-3335/53/1/015009" target="_blank" rel="noopener">1&lt;/a>.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>C. P. Ridgers, J. G. Kirk, R. Duclous, T. G. Blackburn, C. S.
Brady, K. Bennett, T. D. Arber, A. R. Bell, &amp;ldquo;Modelling gamma-ray
photon emission and pair production in high-intensity laser&amp;ndash;matter
interactions,&amp;rdquo; J. Comp. Phys., vol. 260, p. 273-285,
2014
&lt;a href="https://doi.org/10.1016/j.jcp.2013.12.007" target="_blank" rel="noopener">2&lt;/a>.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title/><link>/tutorial/input_deck_species/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_species/</guid><description>&lt;p>This block contains information about the species of particles which are
used in the code. Also details of how these are initialised. See
&lt;a href="/tutorial/input_deck">EPOCH
input deck&lt;/a> for more information on the
input deck.&lt;/p>
&lt;h1 id="basics">Basics&lt;/h1>
&lt;p>The next section of the input deck describes the particle species used
in the code. An example species block for any EPOCH code is given below.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Electron
charge = -1.0
mass = 1.0
frac = 0.5
# npart = 2000 * 100
number_density = 1.e4
temp = 1e6
temp_x = 0.0
temp_y = temp_x(Electron)
number_density_min = 0.1 * den_max
number_density = if(abs(x) lt thick, den_max, 0.0)
number_density = if((x gt -thick) and (abs(y) gt 2e-6), \
0.0, number_density(Carbon))
end:species
begin:species
name = Carbon
charge = 4.0
mass = 1836.0*12
frac = 0.5
number_density = 0.25*number_density(Electron)
temp_x = temp_x(Electron)
temp_y = temp_x(Electron)
dumpmask = full
end:species
&lt;/code>&lt;/pre>
&lt;p>Each species block accepts the following parameters:\&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>name&lt;/code> - This specifies the name of the particle species
defined in the current block. This name can include any alphanumeric
characters in the basic ASCII set. The name is used to identify the
species in any consequent input block and is also used for labelling
species data in any output dumps. It is a mandatory parameter.&lt;br>
**&lt;code>NOTE: IT IS IMPOSSIBLE TO SET TWO SPECIES WITH THE SAME NAME!&lt;/code>&lt;br>
**&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>charge&lt;/code> - This sets the charge of the species in
multiples of the electron charge. Negative numbers are used for
negatively charged particles. This is a mandatory parameter.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>mass&lt;/code> - This sets the mass of the species in multiples
of the electron mass. Cannot be negative. This is a mandatory
parameter.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>npart&lt;/code> - This specifies the number of pseudoparticles
which should be loaded into the simulation domain for this species
block. Using this parameter is the most convenient way of loading
particles for simulations which contain multiple species with
different number densities. If &lt;em>npart&lt;/em> is specified in a species
block then any value given for &lt;em>npart&lt;/em> in the
&lt;a href="/tutorial/input_deck_control">&lt;em>control&lt;/em>&lt;/a> block is ignored.
&lt;em>npart&lt;/em> should not be specified at the same time as &lt;em>frac&lt;/em> within a
&lt;em>species&lt;/em> block.\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>frac&lt;/code> - This specifies what fraction of &lt;em>npart&lt;/em> (the
global number of particles specified in the control block) should be
assigned to the species.\&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>**&lt;code>NOTE: frac should not be specified at the same time as npart for a given species.&lt;/code>&lt;br>
**&lt;/p>
&lt;ul>
&lt;li>&lt;code>npart_per_cell&lt;/code> - Integer parameter which specifies
the number of particles per cell to use for the initial particle
loading. At a later stage this may be extended to allow
&amp;ldquo;npart_per_cell&amp;rdquo; to be a spatially varying function.&lt;/li>
&lt;/ul>
&lt;p>If per-species weighting is used then the value of &amp;ldquo;npart_per_cell&amp;rdquo;
will be the average number of particles per cell. If &amp;ldquo;npart&amp;rdquo; or &amp;ldquo;frac&amp;rdquo;
have also been specified for a species, then they will be ignored.&lt;/p>
&lt;p>To avoid confusion, there is no globally used &amp;ldquo;npart_per_species&amp;rdquo;. If
you want to have a single value to change in the input deck then this
can be achieved using a
&lt;a href="/tutorial/input_deck_constant">&lt;em>constant&lt;/em>&lt;/a> block.\&lt;/p>
&lt;ul>
&lt;li>&lt;code>dumpmask&lt;/code> - Determines which output dumps will include
this particle species. The dumpmask has the same semantics as those used
by variables in the
&lt;a href="/tutorial/input_deck_output_block">&lt;em>output&lt;/em>&lt;/a>
block. The actual dumpmask from the output block is applied first and
then this one is applied afterwards. For example, if the species block
contains &amp;ldquo;dumpmask = full&amp;rdquo; and the output block contains &amp;ldquo;vx = always&amp;rdquo;
then the particle velocity will be only be dumped at full dumps for this
particle species. The default dumpmask is &amp;ldquo;always&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>dump&lt;/code> - This logical flag is provided for backwards
compatibility. If set to &amp;ldquo;F&amp;rdquo; it has the same meaning as &amp;ldquo;dumpmask =
never&amp;rdquo;. If set to &amp;ldquo;T&amp;rdquo; it has the same meaning as &amp;ldquo;dumpmask = always&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>zero_current&lt;/code> - Logical flag switching the particle
species into zero-current particles. Zero-current particles are enabled
if the if the &amp;ldquo;NO_TRACER_PARTICLES&amp;rdquo; precompiler option has not been
used and the &amp;ldquo;zero_current&amp;rdquo; flag is set to true for a given species.
When set, the species will move correctly for its charge and mass, but
contribute no current. This means that these particles are passive
elements in the simulation. In all other respects they are designed to
behave identically to ordinary particles, so they do take part in
collisions by default. This can be prevented using the
&lt;a href="/tutorial/input_deck_collisions">collision
matrices&lt;/a>.
&lt;span style="color: red; font-weight: bold;">WARNING:&lt;/span> Since the
particles effectively have zero weight in terms of their numerical
heating properties, they do not always behave in the same way that an
ordinary particle with weight would behave and this can sometimes lead
to unexpected behaviour. If the purpose is merely to track a subset of a
particle species to use as output then a better mechanism to use is
&amp;ldquo;persistent subsets&amp;rdquo; (see
&lt;a href="/tutorial/input_deck_subset">here&lt;/a>).
&amp;ldquo;tracer&amp;rdquo; is currently accepted as an alias but this will be removed in
version 5.0. &amp;ldquo;zero_current = F&amp;rdquo; is the default value.\&lt;/li>
&lt;li>&lt;code>identify&lt;/code> - Used to identify the type of particle.
Currently this is used primarily by the QED routines. See
&lt;a href="/tutorial/input_deck_qed">here&lt;/a> for details.\&lt;/li>
&lt;li>&lt;code>immobile&lt;/code> - Logical flag. If this parameter is set to &amp;ldquo;T&amp;rdquo;
then the species will be ignored during the particle push. The default
value is &amp;ldquo;F&amp;rdquo;.&lt;br>
The species blocks are also used for specifying initial conditions for
the particle species. The initial conditions in EPOCH can be specified
in various ways, but the easiest way is to specify the initial
conditions in the input deck file. This allows any initial condition
which can be specified everywhere in space by a number density and a
drifting Maxwellian distribution function. These are built up using the
normal maths expressions, by setting the density and temperature for
each species which is then used by the autoloader to actually position
the particles.&lt;/li>
&lt;/ul>
&lt;p>The elements of the species block used for setting initial conditions
are:\&lt;/p>
&lt;ul>
&lt;li>&lt;code>number_density&lt;/code> - Particle number density in $m^{-3}$. As
soon as a number_density= line has been read, the values are calculated
for the whole domain and are available for reuse on the right hand side
of an expression. This is seen in the above example in the first two
lines for the Electron species, where the number density is first set
and then corrected. If you wish to specify the number density in parts
per cubic metre then you can divide by the &amp;ldquo;cc&amp;rdquo; constant (see
[here][maths_parser__constants]). This parameter is
mandatory. &amp;ldquo;density&amp;rdquo; is accepted as an alias.\&lt;/li>
&lt;li>&lt;code>number_density_min&lt;/code> - Minimum particle number density in
$m^{-3}$. When the number density in a cell falls below
number_density_min the autoloader does not load any pseudoparticles
into that cell to minimise the number of low weight, unimportant
particles. If set to 0 then all cells are loaded with particles. This is
the default. &amp;ldquo;density_min&amp;rdquo; is accepted as an alias.\&lt;/li>
&lt;li>&lt;code>number_density_max&lt;/code> - Maximum particle number density in
$m^{-3}$. When the number density in a cell rises above
number_density_max the autoloader clips the number_density to
number_density_max allowing easy implementation of exponential rises
to plateaus. If it is a negative value then no clipping is performed.
This is the default. &amp;ldquo;density_max&amp;rdquo; is accepted as an alias.\&lt;/li>
&lt;li>&lt;code>mass_density&lt;/code> - Particle mass density in $kg,m^{-3}$.
The same as &amp;ldquo;number_density&amp;rdquo; but multiplied by the particle mass. If
you wish to use units of $g,cm^{-3}$ then append the appropriate
multiplication factor. For example: &amp;ldquo;&lt;code>mass_density = 2 * 1e3 / cc&lt;/code>&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>temp_{x,y,z}&lt;/code> - The temperature in each direction for a
thermal distribution in Kelvin.\&lt;/li>
&lt;li>&lt;code>temp&lt;/code> - Sets an isotropic temperature distribution in
Kelvin. If both temp and a specific temp_x, temp_y, temp_z parameter
is specified then the last to appear in the deck has precedence. If
neither are given then the species will have a default temperature of
zero Kelvin.\&lt;/li>
&lt;li>&lt;code>temp_{x,y,z}_ev, temp_ev&lt;/code> - These are the same as the
temperature parameters described above except the units are given in
electronvolts rather than Kelvin, i.e. using 1ev = 11604.5K .\&lt;/li>
&lt;li>&lt;code>drift_{x,y,z}&lt;/code> - Specifies a momentum space offset in
$kg\ ms^{-1}$ to the distribution function for this species. By default,
the drift is zero.\&lt;/li>
&lt;li>&lt;code>offset&lt;/code> - File offset. See below for details.\&lt;/li>
&lt;/ul>
&lt;h1 id="loading_data_from_a_file">Loading data from a file&lt;/h1>
&lt;p>It is also possible to set initial conditions for a particle species
using an external file. Instead of specifying the initial conditions
mathematically in the input deck, you specify in quotation marks the
filename of a simple binary file containing the information required.
For more information on what is meant by a &amp;ldquo;simple binary file&amp;rdquo;, see
&lt;a href="/tutorial/binary_files">here&lt;/a>.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Electron
number_density = 'Data/ic.dat'
offset = 80000
temp_x = 'Data/ic.dat'
end:species
&lt;/code>&lt;/pre>
&lt;p>The sizes of the variables to be filled do not need to be provided: the
code will continue reading until the given variable is filled. Note that
ghost or guard cells should not be included in the file as they cannot
be set this way.&lt;/p>
&lt;p>An additional element is also introduced, the offset element. This is
the offset in bytes from the start of the file to where the data should
be read from. As a given line in the block executes, the file is opened,
the file handle is moved to the point specified by the offset parameter,
the data is read and the file is then closed. Therefore, unless the
offset value is changed between data reading lines the same data will be
read into all the variables. The data is read in as soon as a line is
executed, and so it is perfectly possible to load data from a file and
then modify the data using a mathematical expression.&lt;br>
The example block above is for 10,000 values at double precision, i.e.
8-bytes each. The density data is the first 80,000 bytes of &amp;ldquo;ic.dat&amp;rdquo;.
Bytes 80,000 to 160,000 are the temp_x data.&lt;/p>
&lt;p>The file should be a simple binary file consisting of floating point
numbers of the same precision as &lt;strong>_num&lt;/strong> in the core EPOCH code. For
multidimensional arrays, the data is assumed to be written according to
FORTRAN array ordering rules (i.e. column-major order).&lt;br>
&lt;strong>&lt;code>NOTE: The files that are expected by this block are SIMPLE BINARY files, NOT FORTRAN unformatted files. It is possible to read FORTRAN unformatted files using the offset element, but care must be taken!&lt;/code>&lt;/strong>&lt;/p>
&lt;h1 id="delta_f_parameters">Delta-f parameters&lt;/h1>
&lt;p>The following entries are used for configuring the
&lt;a href="/tutorial/using_delta_f">Delta-f
method&lt;/a>&lt;br>
*number_density_back&lt;/p>
&lt;ul>
&lt;li>drift_{x,y,z}_back&lt;/li>
&lt;li>temp_{x,y,z}_back&lt;/li>
&lt;li>temp_{x,y,z}_back_ev&lt;/li>
&lt;li>temp_back&lt;/li>
&lt;li>temp_back_ev&lt;/li>
&lt;/ul>
&lt;p>These all have the same meanings as the parameters listed above that
don&amp;rsquo;t include the &amp;ldquo;_back&amp;rdquo; text, except that they specify the values to
use for the background distribution function.\&lt;/p>
&lt;h1 id="particle_migration_between_species">Particle migration between species&lt;/h1>
&lt;p>It is sometimes useful to separate particle species into separate energy
bands and to migrate particles between species when they become more or
less energetic. A method to achieve this functionality has been
implemented. It is specified using two parameters to the &amp;ldquo;control&amp;rdquo;
block:\&lt;/p>
&lt;ul>
&lt;li>&lt;code>use_migration&lt;/code> - Logical flag which determines whether or
not to use particle migration. The default is &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>migration_interval&lt;/code> - The number of timesteps between
each migration event. The default is 1 (migrate at every timestep).&lt;br>
The following parameters are added to the &amp;ldquo;species&amp;rdquo; block:\&lt;/li>
&lt;li>&lt;code>migrate&lt;/code> - Logical flag which determines whether or not to
consider this species for migration. The default is &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>promote_to&lt;/code> - The name of the species to promote
particles to.\&lt;/li>
&lt;li>&lt;code>demote_to&lt;/code> - The name of the species to demote particles
to.\&lt;/li>
&lt;li>&lt;code>promote_multiplier&lt;/code> - The particle is promoted when its
energy is greater than &amp;ldquo;promote_multiplier&amp;rdquo; times the local average.
The default value is 1.\&lt;/li>
&lt;li>&lt;code>demote_multiplier&lt;/code> - The particle is demoted when its
energy is less than &amp;ldquo;demote_multiplier&amp;rdquo; times the local average. The
default value is 1.\&lt;/li>
&lt;li>&lt;code>promote_number_density&lt;/code> - The particle is only
considered for promotion when the local number density is less than
&amp;ldquo;promote_number_density&amp;rdquo;. The default value is the largest floating
point number.\&lt;/li>
&lt;li>&lt;code>demote_number_density&lt;/code> - The particle is only considered
for demotion when the local number density is greater than
&amp;ldquo;demote_number_density&amp;rdquo;. The default value is 0.\&lt;/li>
&lt;/ul>
&lt;h1 id="ionisation">Ionisation&lt;/h1>
&lt;p>EPOCH now includes field ionisation which can be activated by defining
ionisation energies and an electron for the ionising species. This is
done via the species block using the following parameters:\&lt;/p>
&lt;ul>
&lt;li>&lt;code>ionisation_energies&lt;/code> - This is an array of ionisation
energies (in Joules) starting from the outermost shell. It expects to be
given all energies down to the fully ionised ion; if the user wishes to
exclude some inner shell ionisation for some reason they need to give
this a very large number. Note that the ionisation model assumes that
the outermost electron ionises first always, and that the orbitals are
filled assuming ground state. When this parameter is specified it turns
on ionisation modelling. If you wish to specify the values in
Electron-Volts, add the &amp;ldquo;ev&amp;rdquo; [multiplication
factor][maths_parser__constants].\&lt;/li>
&lt;li>&lt;code>ionisation_electron_species&lt;/code> - Name of the electron
species. This can be specified as an array in the event that the user
wishes some levels to have a different electron species which can be
handy for monitoring ionisation at specific levels. &amp;ldquo;electron&amp;rdquo; and
&amp;ldquo;electron_species&amp;rdquo; are accepted as synonyms. Either one species for
&lt;em>all&lt;/em> levels, or one species for &lt;em>each&lt;/em> species should be specified.&lt;br>
For example, ionising carbon species might appear in the input deck as:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-perl">begin:species
charge = 0.0
mass = 1837.2
name = carbon
ionisation_energies = (11.26*ev,24.38*ev,47.89*ev,64.49*ev,392.1*ev,490.0*ev)
ionisation_electron_species = \
(electron,electron,electron,fourth,electron,electron)
number_density= den_gas
end:species
begin:species
charge = -1.0
mass = 1.0
name = electron
number_density = 0.0
end:species
begin:species
charge = -1.0
mass = 1.0
name = fourth
number_density = 0.0
end:species
&lt;/code>&lt;/pre>
&lt;p>Ionised states are created automatically and are named according to the
ionising species name with a number appended. For example&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Helium
ionisation_energies = (24.6*ev,54.4*ev)
dump = F
end:species
&lt;/code>&lt;/pre>
&lt;p>With this species block, the species named &amp;ldquo;Helium1&amp;rdquo; and &amp;ldquo;Helium2&amp;rdquo; are
automatically created. These species will also inherit the &amp;ldquo;dump&amp;rdquo;
parameter from their parent species, so in this example they will both
have &amp;ldquo;dump = F&amp;rdquo; set. This behaviour can be overridden by explicitly
adding a species block of the same name with a differing dumpmask. eg.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Helium1
dump = T
end:species
&lt;/code>&lt;/pre>
&lt;p>Field ionisation consists of three distinct regimes; multiphoton in
which ionisation is best described as absorption of multiple photons,
tunnelling in which deformation of the atomic Coulomb potential is the
dominant factor, and barrier suppression ionisation in which the
electric field is strong enough for an electron to escape classically.
It is possible to turn off multiphoton or barrier suppression ionisation
through the input deck using the following control block parameters:\&lt;/p>
&lt;ul>
&lt;li>&lt;code>use_multiphoton&lt;/code> - Logical flag which turns on modelling
ionisation by multiple photon absorption. This should be set to &amp;ldquo;F&amp;rdquo; if
there is no laser attached to a boundary as it relies on laser
frequency. The default is &amp;ldquo;T&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>use_bsi&lt;/code> - Logical flag which turns on barrier
suppression ionisation correction to the tunnelling ionisation model for
high intensity lasers. The default is &amp;ldquo;T&amp;rdquo;.\&lt;/li>
&lt;/ul>
&lt;h1 id="species_boundary_conditions">Species Boundary Conditions&lt;/h1>
&lt;ul>
&lt;li>&lt;code>bc_x_min&lt;/code> - Boundary condition to be applied to this
species only on the lower x boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_x_max&lt;/code> - Boundary condition to be applied to this
species only on the upper x boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_y_min&lt;/code> - Boundary condition to be applied to this
species only on the lower y boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_y_max&lt;/code> - Boundary condition to be applied to this
species only on the upper y boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_z_min&lt;/code> - Boundary condition to be applied to this
species only on the lower z boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>bc_z_max&lt;/code> - Boundary condition to be applied to this
species only on the upper z boundary. Can be any normal boundary
condition apart from periodic. If not specified then the global
boundary condition is applied.&lt;/li>
&lt;li>&lt;code>meet_injectors&lt;/code> - Logical flag determining whether the
background plasma should be extended to meet the point where
particle injectors operate from. This means that plasma is loaded
one particle shape function length outside the boundary. This means
that it is possible to use an injector to &amp;ldquo;continue&amp;rdquo; an existing
drifting plasma. NOT COMPATIBLE WITH PERIODIC BOUNDARY CONDITIONS!&lt;/li>
&lt;/ul>
&lt;h1 id="maxwell_juttner_distributions">Maxwell Juttner distributions&lt;/h1>
&lt;p>As of version 4.15, EPOCH allows the user to request a Maxwell-Jüttner
distribution rather than a Maxwellian distribution when sampling the
particle momentum for a species.&lt;/p>
&lt;p>This feature does not at present work with the delta_f loader and is
not available for particle injectors. It does work correctly with the
moving window.&lt;/p>
&lt;ul>
&lt;li>&lt;code>use_maxwell_juttner&lt;/code> - Logical flag determining
whether to sample from the Maxwell-Jüttner distribution when loading
the particle species. If &amp;ldquo;T&amp;rdquo; then Maxwell-Jüttner is used and if
&amp;ldquo;F&amp;rdquo; Maxwellian is used. The default value is &amp;ldquo;F&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;!-- -->
&lt;ul>
&lt;li>`fractional_tail_cutoff - The sampling is carried out using a
rejection method with an arbitrary cut-off. This parameter takes a
floating-point argument which specifies the fraction of maximum
value at which the sampling should be cut off. Smaller values lead
to distortion nearer the peak of the distribution but are faster to
sample. Larger values lead to a better approximation of the
distribution function but are slower to sample. The default value is
0.0001.&lt;/li>
&lt;/ul>
&lt;p>If drifts are specified with the Maxwell-Jüttner distribution then the
distribution is calculated in the rest frame and then Lorentz
transformed to the specified drifting frame.&lt;/p>
&lt;h1 id="arbitrary_distribution_functions">Arbitrary Distribution functions&lt;/h1>
&lt;p>As of version 4.15, EPOCH also allows the user to request an arbitrary
non-Maxwellian distribution function to use when sampling the particle
momentum for a species. If combined with a specified drift then the
distribution function is calculated first and the drift is applied to
the resulting particles by Lorentz transform.&lt;/p>
&lt;p>This feature does not at present work with the delta_f loader and is
not available for particle injectors. It does work correctly with the
moving window.&lt;/p>
&lt;ul>
&lt;li>&lt;code>dist_fn&lt;/code> - Specifies the functional form of the
distribution function, normalised to have a maximum value of 1. The
variables &amp;ldquo;px&amp;rdquo;, &amp;ldquo;py&amp;rdquo; and &amp;ldquo;pz&amp;rdquo; should be used to parameterise
the x, y and z components of momentum. This may freely vary in space
but temporal variation will be ignored since this is only evaluated
at the start of the simulation.&lt;/li>
&lt;/ul>
&lt;!-- -->
&lt;ul>
&lt;li>&lt;code>dist_fn_p{x,y,z}_range&lt;/code> - Comma separated pair of
numbers to specify the range of momentum for p_{x,y,z} in SI units.
Should be of the form &amp;ldquo;&amp;lt;lower_range&amp;gt;, &amp;lt;upper_range&amp;gt;&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>If a range for a momentum direction is not specified then that momentum
is assumed to be zero. It is up to the user to ensure that the range is
large enough to correctly capture their desired distribution function.
Sampling is by a simple rejection sampling and may be much slower than
the existing Maxwellian sampler. EPOCH will print a warning if a large
number of samples are needed to complete the sampling. If this occurs
then you might need to reduce the range of momentum over which sampling
is considered.&lt;/p>
&lt;p>If the &amp;ldquo;dist_fn&amp;rdquo; key is supplied then any supplied temperature keys
are ignored. An example of setting up a truncated power law distribution
in px would be&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
dens = 10
v0 = 0.05 * c
vmax = 0.5 * c
p0 = v0 * me * (1.0 + 4.0 * x/x_max)
pmax = vmax * me
alpha = -2.0
end:constant
begin:species
name = Electron_pl
charge = -1
mass = 1.0
frac = 0.5
number_density = dens
#Truncated power law distribution in px
dist_fn = exp(-p0/px) * (px/p0)^(alpha)
dist_fn_px_range = (0, pmax)
end:species
&lt;/code>&lt;/pre>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_laser">The laser block&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_subset/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_subset/</guid><description>&lt;p>This block contains configuration for filters which can be used to
modify the data to be output. See
&lt;a href="/tutorial/input_deck">EPOCH input
deck&lt;/a> for more information on the input
deck.&lt;/p>
&lt;p>It is possible to restrict the number of particles written to file
according to various criteria. For example, you can now output the
momentum of all particles which have a gamma lower than 1.8 or the
positions of a randomly chosen subset of a given species.&lt;/p>
&lt;p>A new input deck block named &amp;ldquo;subset&amp;rdquo; is defined which accepts the
following parameters:\&lt;/p>
&lt;ul>
&lt;li>&lt;code>name&lt;/code> - The name given to this subset. This is used to
identify the subset in the output block and is also used when labelling
the data in the SDF files.\&lt;/li>
&lt;li>&lt;code>include_species&lt;/code> - Add the given particle species to the
set of particles that this subset applies to. By default, no particle
species are included.\&lt;/li>
&lt;li>&lt;code>dumpmask&lt;/code> - The dumpmask to use when considering this
subset in an output block. This takes the same form as the output block
dumpmask. The default value is &amp;ldquo;always&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>random_fraction&lt;/code> - Select a random percentage of the
particle species. This is a real value between zero and one. If 0 is
specified, no particles are selected. If 1 is specified, all the
particles are selected. If 0.2 is specified, 20% of the particles are
selected.\&lt;/li>
&lt;li>&lt;code>{px,py,pz,weight,charge,mass,gamma}_min&lt;/code> - Select only
the particles with momentum, weight, charge, mass or gamma which is
greater than the given value.\&lt;/li>
&lt;li>&lt;code>{px,py,pz,weight,charge,mass,gamma}_max&lt;/code> - Select only
the particles with momentum, weight, charge, mass or gamma which is less
than the given value.\&lt;/li>
&lt;li>&lt;code>{x,y,z}_min&lt;/code> - Select only the particles whose position
lies above the given value.\&lt;/li>
&lt;li>&lt;code>{x,y,z}_max&lt;/code> - Select only the particles whose position
lies below the given value.\&lt;/li>
&lt;li>&lt;code>id_min,max&lt;/code> - Select only the particles whose &amp;ldquo;id&amp;rdquo; is
greater than or less than the given values. The &amp;ldquo;id&amp;rdquo; field is explained
below.\&lt;/li>
&lt;li>&lt;code>skip,skip_{x,y,z}&lt;/code> - Integer parameter for subsampling
output. If set to a positive integer then all grid-based variables using
the subset restriction will be reduced when being written to file. This
is achieved by skipping by the specified number of cells in each of the
specified directions. The &amp;ldquo;skip&amp;rdquo; parameter provides a quick method for
setting the same number of cells to skip in all directions. This
currently only applies to grid-based variables and is ignored for data
averages. The default value is &amp;ldquo;0&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;p>Once a subset has been defined, the subset name can then be used in
place of (or in addition to) the dumpmask in an &amp;ldquo;output&amp;rdquo; block (see also
&lt;a href="/tutorial/input_deck_output_block/#dumpmask">here&lt;/a>). For example:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:subset
name = background
random_fraction = 0.1
include_species:electron
include_species:proton
end:subset
begin:subset
name = high_gamma
gamma_min = 1.3
include_species:electron
end:subset
begin:output
particles = background + high_gamma + always
px = background + high_gamma
py = background
pz = always
end:output
&lt;/code>&lt;/pre>
&lt;p>In this example, three &amp;ldquo;px&amp;rdquo; blocks will be written:
&amp;ldquo;Particles/background/electron/Px&amp;rdquo;, &amp;ldquo;Particles/background/proton/Px&amp;rdquo; and
&amp;ldquo;Particles/high_gamma/electron/Px&amp;rdquo;. The &amp;ldquo;background&amp;rdquo; blocks will
contain 10% of the each species, randomly selected. The &amp;ldquo;high_gamma&amp;rdquo;
block will contain all the electrons with a gamma greater than 1.3.&lt;/p>
&lt;p>There will also be &amp;ldquo;Particles/background/electron/Py&amp;rdquo; and
&amp;ldquo;Particles/background/proton/Py&amp;rdquo; block containing y-momentum for the
same 10% random subset of particles. Finally, the
&amp;ldquo;Particles/All/electron/Pz&amp;rdquo; and &amp;ldquo;Particles/All/proton/Pz&amp;rdquo; will contain
the z-momentum for all particles.&lt;/p>
&lt;p>The final selection criteria given in the list above is &amp;ldquo;id_min&amp;rdquo; and
&amp;ldquo;id_max&amp;rdquo;. As of EPOCH version 4.0, the code can now assign a unique ID
field to every particle in the simulation. This can be useful for
tracking specific particles as they move through a simulation. As this
field adds extra memory requirements to the particles, it is disabled by
default and must be compiled in using the &lt;strong>&lt;code>-DPARTICLE_ID&lt;/code>&lt;/strong> compiler
flag.&lt;/p>
&lt;p>Particle IDs can be written to file using the &amp;ldquo;id&amp;rdquo; variable name in the
&lt;a href="/tutorial/input_deck_output_block">&amp;ldquo;output&amp;rdquo;&lt;/a> block. Eg.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:output
particles = always
id = always
end:output
&lt;/code>&lt;/pre>
&lt;h3 id="subsets_of_fields">Subsets of fields&lt;/h3>
&lt;p>Subset blocks can be applied to per-species variables such as current
and temperature. Only particles within the given momentum ranges and of
the selected species are included in the calculations. In addition,
subset blocks can now be applied to field or grid variables. This allows
you to output spatial sections using the &lt;code>{x,y,z}_max,min&lt;/code>
restrictions. The output data will be trimmed to the selected ranges and
a corresponding restricted grid included in the output. Note that
specifying an empty range will lead to output of the entire domain. For
example, the following snippet will output an ex_c_centre variable
restricted to the centre 1/3rd of the domain with a corresponding grid
grid_centre:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:subset
name = centre
x_min = x_min + (x_max - x_min) / 3.0
x_max = x_min + 2.0 * (x_max - x_min) / 3.0
end:subset
begin:output
...
ex = always + centre
end:output
&lt;/code>&lt;/pre>
&lt;h3 id="persistent_subsets">Persistent subsets&lt;/h3>
&lt;p>Persistent subsets are subsets that capture a set of particles once,
given a specified set of parameters, and then track those particles
permanently. Persistent subsets use the same blocks as normal subsets
and take the same parameters as normal subsets (except the skip
parameters which only apply to fields). Subsets are marked as persistent
by setting either&lt;/p>
&lt;ul>
&lt;li>&lt;code>persist_start_time&lt;/code> - Time at which to record the list
of particles to be tracked. Throughout the rest of the simulation
this recorded list will be used whenever requesting output for this
subset. &amp;ldquo;persist_after_time&amp;rdquo; is accepted as an alias. Set to 0
to record from the start of the simulation.\&lt;/li>
&lt;li>&lt;code>persist_start_step&lt;/code> - Similar to persist_start_time
except this specifies a simulation step number to use instead of
time. &amp;ldquo;persist_after_step&amp;rdquo; is accepted as an alias.\&lt;/li>
&lt;/ul>
&lt;p>If the input deck is edited on restart to add a new persistent subset
then it must be added &lt;strong>after&lt;/strong> existing persistent subsets or problems
may occur on restart.&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_constant">The constant block&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/input_deck_test_page/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_test_page/</guid><description/></item><item><title/><link>/tutorial/input_deck_window/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/input_deck_window/</guid><description>&lt;p>This block contains information about the moving window if the code is
used in that fashion. See
&lt;a href="/tutorial/input_deck">EPOCH input
deck&lt;/a> for more information on the input
deck.&lt;/p>
&lt;p>EPOCH can include an optional block which causes the simulation domain
to operate as a moving window. At present, it is only possible to have
the window moving at a speed parallel to the x direction, although the
window does not have to start moving at t = 0. When the window moves,
the code removes particles from the left hand edge of the domain and
introduces new particles at the right hand edge. The new particles are
placed by re-evaluating the species density, temperature and drift using
the new time and spatial coordinates. The block looks like:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:window
move_window = T
window_v_x = 3.0e8
window_start_time = 7.0e-13
bc_x_min_after_move = simple_outflow
bc_x_max_after_move = simple_outflow
end:window
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>move_window&lt;/code> - Logical flag determining whether or not
to move the window. If the window block is absent then this is the
same as setting move_window to &amp;ldquo;F&amp;rdquo;.\&lt;/li>
&lt;li>&lt;code>window_v_x&lt;/code> - The speed in m/s of the window.\&lt;/li>
&lt;li>&lt;code>window_start_time&lt;/code> - The time in seconds at which the
window should start moving.\&lt;/li>
&lt;/ul>
&lt;p>- The time in seconds at which the window should stop moving.\&lt;/p>
&lt;ul>
&lt;li>&lt;code>bc_x_min_after_move&lt;/code> - The boundary condition which
should apply to the left boundary after the window has started moving.
This is to allow the swapping of a laser boundary to a simple outflow
boundary. Boundary codes are the same as when just specifying normal
boundaries. If a boundary value isn&amp;rsquo;t specified then it is assumed that
the boundary isn&amp;rsquo;t changed when the window starts moving.
&amp;ldquo;xbc_left_after_move&amp;rdquo; is accepted as a synonym.\&lt;/li>
&lt;li>&lt;code>bc_x_max_after_move&lt;/code> - The boundary condition which
should apply to the right boundary after the window has started moving.
&amp;ldquo;xbc_right_after_move&amp;rdquo; is accepted as a synonym. - &amp;ldquo;y&amp;rdquo; and &amp;ldquo;z&amp;rdquo;
versions of the previous two parameters. &lt;strong>ybc_down_after_move&lt;/strong>,
&lt;strong>ybc_up_after_move&lt;/strong>, &lt;strong>zbc_back_after_move&lt;/strong> and
&lt;strong>zbc_front_after_move&lt;/strong> are accepted as synonyms.\&lt;/li>
&lt;/ul>
&lt;h1 id="compatibility">Compatibility&lt;/h1>
&lt;p>Because of how the moving window must work, there are some compatibility
issues with certain features. In particular:&lt;/p>
&lt;ul>
&lt;li>lasers attached to an X boundary which remain in place after the
window moves, or attached to Y or Z boundaries:
&lt;ul>
&lt;li>The laser will behave as though it is attached to the window
itself: for Y or Z boundaries with spatial variations this may
not give the expected result&lt;/li>
&lt;li>For X boundaries, the moving emitter will result in a form of
numerical Doppler shifting. In addition to this the boundary
used to drive the field will shift discontinuously, yielding
noisy and erratic changes in the electromagnetic field.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Injectors attached to an X boundary will not work. Those on a Y or Z
boundary may appear to work, but the rates will be incorrect.&lt;/li>
&lt;li>CPML boundary conditions:
&lt;ul>
&lt;li>in X these cannot work as they rely on time-history which is
simply missing.&lt;/li>
&lt;li>On Y or Z boundaries they will approximately work, but the
history will be truncated and so they will generally require
more tuning. We can&amp;rsquo;t help with this in general.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Load of particles from file is not supported since it can&amp;rsquo;t be made
to work in general.&lt;/li>
&lt;/ul>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck_output_block">The output block&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/landing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/landing/</guid><description>&lt;p>These pages contain user-supplied examples.&lt;/p>
&lt;h1 id="a_list_of_all_user_submitted_examples_pages">A list of all user submitted examples pages&lt;/h1>
&lt;h1 id="submit_an_example">Submit an example&lt;/h1>
&lt;p>A link to submit an example problem will be provided soon&lt;/p></description></item><item><title/><link>/tutorial/landing_page/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/landing_page/</guid><description>&lt;h1 id="how_to_use_these_pages">How to use these pages&lt;/h1>
&lt;p>If you are new to EPOCH, start with the
&lt;a href="/tutorial/faq">FAQ&lt;/a> and
the
&lt;a href="#basic_usage"> introductory information.&lt;/a> Then read
&lt;a href="/tutorial/basic_examples">the
basic examples&lt;/a>. There&amp;rsquo;s quite a lot to
learn in order to get started, so you should plan to read through all of
this section. You will also need to refer to
&lt;a href="/tutorial/input_deck">the input deck
pages&lt;/a>. Next, look at the code and have a
play with some test problems. After that re-read the
&lt;a href="/tutorial/faq">FAQ&lt;/a>. This should be enough for testing simple
problems. See
&lt;a href="#visualising_epoch_output">below&lt;/a> for more
information on visualising the output files.&lt;/p>
&lt;p>For specific information, see the
&lt;a href="#epoch_manual_index">index&lt;/a> below or use the search
function. Alternately, start with the
&lt;a href="/tutorial/faq">FAQ&lt;/a> and
read through the pages in order by following the &amp;ldquo;Next section&amp;rdquo; links.&lt;/p>
&lt;h1 id="basic_usage">Basic usage&lt;/h1>
&lt;ul>
&lt;li>
&lt;a href="/tutorial/faq">The EPOCH FAQ list&lt;/a>\&lt;/li>
&lt;li>
&lt;a href="/tutorial/faq/#how_do_i_obtain_the_code">Getting the code&lt;/a>\&lt;/li>
&lt;li>
&lt;a href="/tutorial/structure">The structure of the EPOCH codes&lt;/a>\&lt;/li>
&lt;li>
&lt;a href="/tutorial/libraries">Library requirements for the EPOCH
codes&lt;/a>\&lt;/li>
&lt;li>
&lt;a href="/tutorial/compiling"> Compiling EPOCH&lt;/a>\&lt;/li>
&lt;li>
&lt;a href="/tutorial/compiler_flags">Compiler flags and preprocessor
defines&lt;/a>\&lt;/li>
&lt;li>
&lt;a href="/tutorial/running">Running EPOCH and basic control of
EPOCH&lt;/a>\&lt;/li>
&lt;/ul>
&lt;h1 id="the_input_deck">The input deck&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>
&lt;a href="/tutorial/input_deck">The EPOCH input deck&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_control">The control block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_boundaries">The boundaries block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_species">The species block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_laser">The laser block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_fields">The fields block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_window">The window block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_output_block">The output block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_output_global">The output_global
block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_dist_fn">The dist_fn block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_probe">The probe block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_collisions">The collisions block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_qed">The qed block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_subset">The subset block&lt;/a>&lt;br>
*
&lt;a href="/tutorial/input_deck_constant">The constant block&lt;/a>\&lt;/p>
&lt;/li>
&lt;li>
&lt;p>
&lt;a href="/tutorial/input_deck_injector">The injector block&lt;/a>\&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="code_details">Code details&lt;/h1>
&lt;ul>
&lt;li>[The EPOCH maths parser][maths_parser]\&lt;/li>
&lt;li>
&lt;a href="/tutorial/using_epoch_in_practice">EPOCH use in practice&lt;/a>\&lt;/li>
&lt;li>
&lt;a href="/tutorial/using_delta_f">Using EPOCH in delta_f form&lt;/a>\&lt;/li>
&lt;li>
&lt;a href="/tutorial/basic_examples">Basic examples of using EPOCH&lt;/a>\&lt;/li>
&lt;li>
&lt;a href="/tutorial/previous_versions">Changes from previous versions of
EPOCH&lt;/a>\&lt;/li>
&lt;/ul>
&lt;h1 id="visualising_epoch_output">Visualising EPOCH output&lt;/h1>
&lt;p>
&lt;a href="/tutorial/visualising_sdf_files_with_idl_or_gdl">Visualising SDF files using Harris Geospatial Solutions IDL or GNU Data
Language (GDL)&lt;/a>&lt;br>
&lt;a href="/tutorial/visualising_sdf_files_with_llnl_visit">Visualising SDF files using LLNL
VisIt&lt;/a>&lt;br>
&lt;a href="/tutorial/python">Visualising SDF files using Python&lt;/a>\&lt;/p>
&lt;h1 id="examples_with_epoch">Examples with EPOCH&lt;/h1>
&lt;p>Example decks and output are available in a few places:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="/tutorial/basic_examples">Basic examples of using EPOCH&lt;/a>
from the manual&lt;/li>
&lt;li>
&lt;a href="/tutorial/landing">User submitted examples&lt;/a> (tbc)&lt;/li>
&lt;/ul>
&lt;p>A link to submit your own examples will be provided soon&lt;/p>
&lt;h3 id="the_epoch_workshop">The EPOCH workshop&lt;/h3>
&lt;p>The examples from the EPOCH workshop are in two parts:
&lt;a href="/tutorial/workshop_examples">(part
1)&lt;/a>
&lt;a href="/tutorial/workshop_examples_continued">(part
2)&lt;/a>&lt;/p>
&lt;h1 id="helpful_information">Helpful information&lt;/h1>
&lt;p>
&lt;a href="/tutorial/links">Links and references&lt;/a>&lt;br>
&lt;a href="/tutorial/acknowledging_epoch">Acknowledging EPOCH&lt;/a>&lt;br>
The EPOCH
&lt;a href="https://cfsa-pmw.warwick.ac.uk/EPOCH/epoch/wikis/Downloads" target="_blank" rel="noopener">Developer
Manual&lt;/a> is
quite out of date at this point, so it contains some information which
is no longer correct. However, the fundamental algorithms have not
changed so it still contains plenty of useful and relevant information.\&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/libraries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/libraries/</guid><description>&lt;p>The EPOCH codes are written using MPI for parallelism, but have no other
libraries or dependencies. Currently, the codes are written to only
require MPI1.2 compatible libraries, although this may change to require
full MPI2 compliance in the future. Current versions of both MPICH and
OpenMPI implement the MPI2 standard and are known to work with this
code. The SCALI MPI implementation is only compliant with the MPI1.2
specification and may loose support soon. There are no plans to write a
version of EPOCH which does not require the MPI libraries.&lt;/p>
&lt;p>The code is supplied with a standard GNU make Makefile, which is also
compatible with most other forms of the &lt;em>&lt;code>*make*&lt;/code>&lt;/em> utility.
In theory it is possible to compile the code without a
&lt;em>&lt;code>*make*&lt;/code>&lt;/em> utility, but it is much easier to compile the code
using the supplied makefile.&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/compiling"> Compiling EPOCH&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title>License</title><link>/contact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/contact/</guid><description/></item><item><title>License</title><link>/license/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/license/</guid><description/></item><item><title/><link>/tutorial/links/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/links/</guid><description>&lt;h1 id="useful_links">Useful links&lt;/h1>
&lt;p>
&lt;a href="https://wci.llnl.gov/simulation/computer-codes/visit" target="_blank" rel="noopener">VisIt&lt;/a>&lt;br>
&lt;a href="http://www.visitusers.org/" target="_blank" rel="noopener">VisIt user documentation&lt;/a>&lt;br>
&lt;a href="http://gnudatalanguage.sourceforge.net/" target="_blank" rel="noopener">GDL&lt;/a>\&lt;/p>
&lt;h1 id="references_in_the_manual">References in the manual&lt;/h1>
&lt;p>Contemporary particle-in-cell approach to laser-plasma modelling &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Buneman &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Taflove and Hagness&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Roden and Gedney&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Sentoku and Kemp&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Duclous et al &lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Ridgers et al &lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Lehe et al &lt;sup id="fnref:8">&lt;a href="#fn:8" class="footnote-ref" role="doc-noteref">8&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Cowan et al &lt;sup id="fnref:9">&lt;a href="#fn:9" class="footnote-ref" role="doc-noteref">9&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Pukhov &lt;sup id="fnref:10">&lt;a href="#fn:10" class="footnote-ref" role="doc-noteref">10&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Blinne et al &lt;sup id="fnref:11">&lt;a href="#fn:11" class="footnote-ref" role="doc-noteref">11&lt;/a>&lt;/sup>&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>T D Arber, K Bennett, C S Brady, A Lawrence-Douglas, M G Ramsay, N
J Sircombe, P Gillies, R G Evans, H Schmitz, A R Bell,
&amp;ldquo;Contemporary particle-in-cell approach to laser-plasma
modelling,&amp;rdquo; Plasma Physics and Controlled Fusion, 2015.
&lt;a href="http://iopscience.iop.org/article/10.1088/0741-3335/57/11/113001/pdf" target="_blank" rel="noopener">link&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>O. Buneman, &amp;ldquo;TRISTAN: The 3-D Electromagnetic Particle Code.&amp;rdquo; in
Computer Space Plasma Physics: Simulations Techniques and Software,
1993.
&lt;a href="https://www.terrapub.co.jp/e-library/cspp/" target="_blank" rel="noopener">link&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>A. Taflove and S. C. Hagness, Computational Electrodynamics: The
Finite-Difference Time-Domain Method. Artech House,
2000.
&lt;a href="https://www.researchgate.net/publication/202924435_Computational_Electrodynamics_The_Finite-Difference_Time-Domain_Method" target="_blank" rel="noopener">link&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>J. Roden and S. Gedney, &amp;ldquo;Convolution pml (cpml): An efficient fdtd
implementation of the cfs-pml for arbitrary media,&amp;rdquo; Microw. Opt.
Technol. Lett.,
2000.
&lt;a href="https://www.researchgate.net/publication/228078114_Convolutional_PML_CPML_an_efficient_FDTD_implementation_of_the_CFS-PML_for_arbitrary_media" target="_blank" rel="noopener">link&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>Y. Sentoku and A. J. Kemp, &amp;ldquo;Numerical methods for particle
simulations at extreme densities and temperatures: Weighted
particles, relativistic collisions and reduced currents,&amp;rdquo; J. Comput.
Phys., 2008.
&lt;a href="http://www.sciencedirect.com/science/article/pii/S0021999108001988" target="_blank" rel="noopener">link&lt;/a>&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6" role="doc-endnote">
&lt;p>R. Duclous, J. G. Kirk, and A. R. Bell, &amp;ldquo;Monte carlo calculations
of pair production in high-intensity laserplasma interactions,&amp;rdquo;
Plasma Phys. Contr. F., vol. 53, no. 1, p. 015009,
2011
&lt;a href="http://iopscience.iop.org/article/10.1088/0741-3335/53/1/015009" target="_blank" rel="noopener">1&lt;/a>.&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:7" role="doc-endnote">
&lt;p>C. P. Ridgers, J. G. Kirk, R. Duclous, T. G. Blackburn, C. S.
Brady, K. Bennett, T. D. Arber, A. R. Bell, &amp;ldquo;Modelling gamma-ray
photon emission and pair production in high-intensity laser&amp;ndash;matter
interactions,&amp;rdquo; J. Comp. Phys., vol. 260, p. 273-285,
2014
&lt;a href="https://doi.org/10.1016/j.jcp.2013.12.007" target="_blank" rel="noopener">2&lt;/a>&amp;#160;&lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:8" role="doc-endnote">
&lt;p>R. Lehe, A. Lifschitz, C. Thaury, V. Malka, and X. Davoine,
&amp;ldquo;Numerical growth of emittance in simulations of laser-wakefield
acceleration,&amp;rdquo; Phys. Rev. Accel. Beams, vol. 16, no. 2, p.021301,
2013
&lt;a href="https://www.researchgate.net/publication/258097872_Numerical_growth_of_emittance_in_simulations_of_laser-wakefield_acceleration" target="_blank" rel="noopener">3&lt;/a>.&amp;#160;&lt;a href="#fnref:8" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:9" role="doc-endnote">
&lt;p>B. Cowan, D. Bruhwiler, J. Cary, E. Cormier-Michel, and C. Geddes,
&amp;ldquo;Generalized algorithm for control of numerical dispersion in
explicit time-domain electromagnetic simulations&amp;rdquo;, Phys. Rev.
Accel. Beams, vol. 16, no. 4, p. 041303, 2013
&lt;a href="https://journals.aps.org/prab/abstract/10.1103/PhysRevSTAB.16.041303" target="_blank" rel="noopener">4&lt;/a>.&amp;#160;&lt;a href="#fnref:9" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:10" role="doc-endnote">
&lt;p>Pukhov, A., &amp;ldquo;Three-dimensional electromagnetic relativistic
particle-in-cell code VLPL (Virtual Laser Plasma Lab)&amp;rdquo;, J. Plasma
Phys., vol. 61, no. 3, p. 425, 1999
&lt;a href="https://www.cambridge.org/core/journals/journal-of-plasma-physics/article/three-dimensional-electromagnetic-relativistic-particle-in-cell-code-vlpl-virtual-laser-plasma-lab/7FBA476D599E2F19DFEA3F0F2F84FFAB" target="_blank" rel="noopener">5&lt;/a>.&amp;#160;&lt;a href="#fnref:10" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:11" role="doc-endnote">
&lt;p>A. Blinne, D. Schinkel, S. Kuschel, N. Elkina, S. G. Rykovanov,
and M. Zepf, &amp;ldquo;A systematic approach to numerical dispersion in
Maxwell solvers&amp;rdquo;, Computer Physics Communications, 00104655,
2017
&lt;a href="https://arxiv.org/pdf/1710.06829.pdf" target="_blank" rel="noopener">6&lt;/a>&amp;#160;&lt;a href="#fnref:11" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title/><link>/tutorial/maths_parser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/maths_parser/</guid><description>&lt;p>A discussion of the input deck for EPOCH would not be complete without
consideration of the maths parser. The maths parser is the code which
reads the input decks. The parser makes it possible that any parameter
taking a numerical value (integer or real) can be input as a
mathematical expression rather than as a numerical constant. The maths
parser is fairly extensive and includes a range of mathematical
functions, physical and simulation constants and appropriately
prioritised mathematical operators.&lt;/p>
&lt;h3 id="constants">Constants&lt;/h3>
&lt;p>The maths parser in EPOCH has the following constants&lt;/p>
&lt;ul>
&lt;li>pi - The ratio of the circumference of a circle to its diameter.&lt;/li>
&lt;li>kb - Boltzmann&amp;rsquo;s constant.&lt;/li>
&lt;li>me - Mass of an electron.&lt;/li>
&lt;li>qe - Charge of an electron.&lt;/li>
&lt;li>c - Speed of light.&lt;/li>
&lt;li>epsilon0 - Permeability of free space.&lt;/li>
&lt;li>mu0 - Permittivity of free space.&lt;/li>
&lt;li>ev - Electronvolt.&lt;/li>
&lt;li>kev - Kilo-Electronvolt.&lt;/li>
&lt;li>mev - Mega-Electronvolt.&lt;/li>
&lt;li>micron - A convenience symbol for specifying wavelength in microns
rather than metres.&lt;/li>
&lt;li>milli - $10^{-3}$&lt;/li>
&lt;li>micro - $10^{-6}$&lt;/li>
&lt;li>nano - $10^{-9}$&lt;/li>
&lt;li>pico - $10^{-12}$&lt;/li>
&lt;li>femto - $10^{-15}$&lt;/li>
&lt;li>atto - $10^{-18}$&lt;/li>
&lt;li>cc - A convenience symbol for converting from cubic metres to cubic
centimetres (ie. $10^{-6}$)&lt;/li>
&lt;li>time - Initial simulation time.&lt;/li>
&lt;li>x,y,z - Grid coordinates in the x,y,z direction.&lt;/li>
&lt;li>ix,iy,iz - Grid index in the x,y,z direction.&lt;/li>
&lt;li>nx,ny,nz - Number of grid points in the x,y,z direction.&lt;/li>
&lt;li>dx,dy,dz - Grid spacing in the x,y,z direction.&lt;/li>
&lt;li>{x,y,z}_min - Grid coordinate of the minimum x,y,z boundary.&lt;/li>
&lt;li>{x,y,z}_max - Grid coordinate of the maximum x,y,z boundary.&lt;/li>
&lt;li>length_{x,y,z} - The length of the simulation box in the x,y,z
direction.&lt;/li>
&lt;li>nproc_{x,y,z} - The number of processes in the x,y,z directions.&lt;/li>
&lt;li>nsteps - The number of timesteps requested.&lt;/li>
&lt;li>t_end - The end time of the simulation.&lt;/li>
&lt;li>p{x,y,z} - Momentum in the x, y, z directions. Used in specifying
arbitrary distribution functions. EPOCH 4.15 or later required&lt;/li>
&lt;/ul>
&lt;p>It is also possible for an end user to specify custom constants both
within the code and from the input deck. These topics are covered later
in this subsection. An example of using a constant would be:&lt;br>
&lt;strong>length_x = pi&lt;/strong>&lt;/p>
&lt;h3 id="functions">Functions&lt;/h3>
&lt;p>The maths parser in EPOCH has the following functions&lt;/p>
&lt;ul>
&lt;li>abs(a) - Absolute value.&lt;/li>
&lt;li>floor(a) - Convert real to integer rounding down.&lt;/li>
&lt;li>ceil(a) - Convert real to integer rounding up.&lt;/li>
&lt;li>nint(a) - Convert real to integer rounding to nearest integer.&lt;/li>
&lt;li>sqrt(a) - Square root.&lt;/li>
&lt;li>sin(a) - Sine.&lt;/li>
&lt;li>cos(a) - Cosine.&lt;/li>
&lt;li>tan(a) - Tangent.&lt;/li>
&lt;li>asin(a) - Arcsine.&lt;/li>
&lt;li>acos(a) - Arccosine.&lt;/li>
&lt;li>atan(a) - Arctangent.&lt;/li>
&lt;/ul>
&lt;p>- Arctangent using the Fortran ATAN2 function. This computes the
principal value of the argument function of the complex number
$X + i Y$. This function can be used to transform from Cartesian into
polar coordinates and allows to determine the angle in the correct
quadrant.&lt;/p>
&lt;ul>
&lt;li>sinh(a) - Hyperbolic sine.&lt;/li>
&lt;li>cosh(a) - Hyperbolic cosine.&lt;/li>
&lt;li>tanh(a) - Hyperbolic tangent.&lt;/li>
&lt;li>exp(a) - Exponential.&lt;/li>
&lt;li>loge(a) - Natural logarithm.&lt;/li>
&lt;li>log10(a) - Base-10 logarithm.&lt;/li>
&lt;li>log_base(a,b) - Base-b logarithm.&lt;/li>
&lt;li>gauss($x,x_0,w$) - Calculate a Gaussian profile in variable
&lt;em>&lt;code>x&lt;/code>&lt;/em> centred on &lt;em>&lt;code>$x_0$&lt;/code>&lt;/em> with a
characteristic width &lt;em>&lt;code>w&lt;/code>&lt;/em>.
$f(x) = \exp{(-((x-x_0)/w)^2)}$. In this expression the full width
at half maximum is given by $fwhm = 2 w \sqrt{\ln{2}}$&lt;/li>
&lt;li>supergauss($x,x_0,w,n$) - This is identical to &amp;ldquo;gauss&amp;rdquo; except it
takes a fourth parameter, &lt;em>&lt;code>n&lt;/code>&lt;/em>, which is the power to
raise the exponential argument to.&lt;/li>
&lt;li>semigauss($t,A,A_0,w$) - Calculate a semi Gaussian profile in
variable $t$ with maximum amplitude $A$, amplitude at $t=0$ $A_0$
and width $w$. The parameter $A_0$ is used to calculate $t_0$, the
point at which the Gaussian reaches its maximum value. For $t$ less
than $t_0$ the profile is Gaussian and for $t$ greater than $t_0$ it
is the constant $A$. $t_0 = w\sqrt{-\ln{(A_0/A)}}$&lt;math>f(t) =&lt;/li>
&lt;/ul>
&lt;p>\begin{cases} A \exp{(-((t-t_0)/w)^2)}, &amp;amp; t &amp;lt; t_0 \\ A, &amp;amp;
\mbox{otherwise} \end{cases}&lt;/math>&lt;/p>
&lt;ul>
&lt;li>interpolate(interp_var,.&amp;hellip;,n_pairs) - Linear interpolation
function, explained later.&lt;/li>
&lt;li>if(a,b,c) - Conditional function. If a != 0 the function returns b,
otherwise the function returns c.&lt;/li>
&lt;li>number_density(a) - Returns the number density for species a.&lt;/li>
&lt;li>temp_{x,y,z}(a) - Returns temperature in the x, y or z direction
for species a.&lt;/li>
&lt;li>temp(a) - Returns the isotropic temperature for species a.&lt;/li>
&lt;li>e{x,y,z}(x,y,z) - Returns the x, y or z component of the electric
field at the specified location.&lt;/li>
&lt;li>b{x,y,z}(x,y,z) - Returns the x, y or z component of the magnetic
field at the specified location.&lt;/li>
&lt;li>critical($\omega$) - Returns the critical density for the given
frequency $\omega$. ie.
$n_{crit}(\omega) = \omega^2 m_0 \epsilon_0 / e^2$&lt;/li>
&lt;/ul>
&lt;p>It is also possible for an end user to specify custom functions within
the code. An example of using a function would be:&lt;br>
&lt;strong>length_x = exp(pi)&lt;/strong>&lt;br>
The use of most of these functions is fairly simple, but &amp;ldquo;interpolate&amp;rdquo;
requires some additional explanation. This function allows a user to
specify a set of position,value pairs and have the code linearly
interpolate the values between these control points. This function is
mainly intended for ease of converting initial conditions from other
existing PIC codes, and the same effect can usually be obtained more
elegantly using the &amp;ldquo;if&amp;rdquo; command. The structure of the &amp;ldquo;interpolate&amp;rdquo;
command is as follows: The first parameter is the variable which is to
be used as the axis over which to interpolate the values. This can in
general be any valid expression, but will normally just be a coordinate
axis. The next 2n entries are the position,value pairs and the final
parameter is the number of position,value pairs. The slightly clunky
syntax of this command is unfortunately necessary to allow it to work
with some fairly fundamental features of the maths parser used in EPOCH.&lt;/p>
&lt;h3 id="operators">Operators&lt;/h3>
&lt;p>The maths parser in EPOCH allows the following operators&lt;/p>
&lt;ul>
&lt;li>a + b - Addition operator.&lt;/li>
&lt;li>a - b - Subtraction operator or unary negation operator
(auto-detected).&lt;/li>
&lt;li>a * b - Multiplication operator.&lt;/li>
&lt;li>a / b - Division operator.&lt;/li>
&lt;li>a ^ b - Power raise operator.&lt;/li>
&lt;li>a e b - Power of ten operator (1.0e3 = 1000).&lt;/li>
&lt;li>a lt b - Less than operator. Returns 1 if a $&amp;lt;$ b, otherwise
returns 0. Intended for use with if.&lt;/li>
&lt;li>a gt b - Greater than operator. Returns 1 if a $&amp;gt;$ b, otherwise
returns 0.&lt;/li>
&lt;li>a eq b - Equality operator. Returns 1 if a == b, otherwise
returns 0.&lt;/li>
&lt;li>a and b - Logical and operator. Returns 1 if a != 0 and b != 0,
otherwise returns 0.&lt;/li>
&lt;li>a or b - Logical or operator. Returns 1 if a != 0 or b != 0,
otherwise returns 0.&lt;/li>
&lt;/ul>
&lt;p>These follow the usual rules for operator precedence, although it is
best to surround more complex expressions in parenthesis if the
precedence is important. It is not possible at this time to specify
custom operators without major changes to the code. An example of using
an operator would be:\&lt;/p>
&lt;pre>&lt;code class="language-perl"> length_x = 10.0 + 12.0
&lt;/code>&lt;/pre>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/using_epoch_in_practice">Using EPOCH&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/non-thermal_initial_conditions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/non-thermal_initial_conditions/</guid><description>&lt;h1 id="this_section_superseded">THIS SECTION SUPERSEDED&lt;/h1>
&lt;p>As of EPOCH 4.15 arbitrary distribution functions can be specified in
the deck (see
&lt;a href="/tutorial/input_deck_species/#arbitrary_distribution_functions">here&lt;/a>).
The approach in this section is no longer needed.&lt;/p>
&lt;h1 id="background">Background&lt;/h1>
&lt;p>Before version 4.15 EPOCH&amp;rsquo;s input deck is only set up to allow you to
specify Maxwellian particle distributions. You do this by putting the
relevant keys into the &lt;code>species&lt;/code> block for each species. You can specify
an isotropic Maxwellian by specifying the &lt;code>temp&lt;/code> key in Kelvin. You can
specify an anisotropic Maxwellian by specifying some or all of the
&lt;code>temp_x&lt;/code>, &lt;code>temp_y&lt;/code> and &lt;code>temp_z&lt;/code> which sets the distribution function in
each of these directions You can extend this to include distributions
consisting of multiple Maxwellians by combining multiple species each
with an individual temperature.&lt;/p>
&lt;p>Sometimes though you want to use a truly arbitrary distribution
function, and at present to do that you have to modify the EPOCH code
itself. There is a specific routine &lt;code>manual_load&lt;/code> in the file
&lt;code>src/user_interaction/ic_module.90&lt;/code> which is the intended place for
users to control EPOCH from within the EPOCH source code. This routine
is not as simple to use as the input deck, as it requires some knowledge
of the internal design of EPOCH, and some familiarity with modern
Fortran, but for most uses you will not have to worry about things like
the parallelism or the detailed internal EPOCH data structures. It
should all just work. When the routine is first called the particles are
in the state that is specified in the input deck, with the associated
density and temperature. You only need to modify the things that are
different to the state specified in the input deck.&lt;/p>
&lt;h1 id="epoch_internals">EPOCH internals&lt;/h1>
&lt;p>There are three elements of EPOCH&amp;rsquo;s internals that you do have to
interact with, the particle_species objects, particle_list objects and
the particle objects themselves. All of them are implemented as Fortran
&lt;code>TYPE&lt;/code> and are prototyped in the &lt;code>src/shared_data.F90&lt;/code> file. For this
problem, the only bits that you will need to use are&lt;/p>
&lt;pre>&lt;code class="language-fortran"> TYPE particle_species
CHARACTER(string_length) :: name
TYPE(particle_list) :: attached_list
END TYPE particle_species
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>name&lt;/code> parameter is self explanatory and is the name of the species
as specified in the input deck. The &lt;code>attached_list&lt;/code> parameter is a
particle_list object which holds the particles belonging to this
species.&lt;/p>
&lt;p>You will need only one element of the &lt;code>particle_list&lt;/code> object, called
&lt;code>head&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-fortran"> TYPE particle_list
TYPE(particle), POINTER :: head
END TYPE particle_list
&lt;/code>&lt;/pre>
&lt;p>&lt;code>head&lt;/code> is a pointer to the first particle in the list. EPOCH stores the
particles using a
&lt;a href="https://en.wikipedia.org/wiki/Linked_list" target="_blank" rel="noopener">linked list&lt;/a>
format, so that each particle stores a pointer to the next particle.
&lt;code>head&lt;/code> Gives you access to the start of the list of particles.&lt;/p>
&lt;p>You might need to interact with two elements of the particle type&lt;/p>
&lt;pre>&lt;code class="language-fortran"> TYPE particle
REAL(num), DIMENSION(3) :: part_p
REAL(num) :: part_pos ! In EPOCH 1D
REAL(num), DIMENSION(2) :: part_pos ! In EPOCH 2D
REAL(num), DIMENSION(3) :: part_pos ! In EPOCH 3D
END TYPE particle
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>part_pos&lt;/code> parameter is the position of the particle. It is a single
REAL type value in EPOCH1D, a 2 element array in EPOCH2D and a 3 element
array in EPOCH3D. You might need to read these values if you want to
have spatially varying distribution functions. It is possible to change
the position of a particle in this routine, but it is not recommended
and most uses of this are beyond the scope of this article. The &lt;code>part_p&lt;/code>
parameter is the particle moment in SI units. It is always a 3 element
array, with the elements ordered as &lt;code>[px,py,pz]&lt;/code>. This is the array that
you must change to specify a non-Maxwellian distribution. It is up to
you how to specify the momentum of the particles, but the most general
algorithm is
&lt;a href="https://en.wikipedia.org/wiki/Rejection_sampling" target="_blank" rel="noopener">rejection sampling&lt;/a>
which is detailed in an example below.&lt;/p>
&lt;h1 id="examples">Examples&lt;/h1>
&lt;p>As an example, code will be shown that modifies EPOCH so that the
&lt;code>two_stream.deck&lt;/code> example deck produces one species with a power law
distribution in $p_x$ and $p_y$ with a spectral index of -2&lt;/p>
&lt;p>$f(p_x,p_y) = A |p|^{-2}$.&lt;/p>
&lt;p>There are three related problems in setting up this distribution :
looping over all of the particle species until the one that you want is
found, looping over all of the particles in that species, and finally
sampling the distribution that you want. Finding the particle species is
easy. There is an array called &lt;code>species_list&lt;/code> which runs from 1 to
&lt;code>n_species&lt;/code> which returns a &lt;code>particle_species&lt;/code> type. One can then simply
test for the species wanted by comparing&lt;/p>
&lt;pre>&lt;code class="language-fortran">TRIM(species_list(ispecies)%name)
&lt;/code>&lt;/pre>
&lt;p>to the name of the required species as specified in the input deck. The
comparison is case sensitive. To loop over the particles in the species
the current particle pointer &lt;code>current&lt;/code> is pointed to the head of the
particle list attached to the species &lt;code>species_list(ispecies)&lt;/code>. The main
loop over the particles looks slightly strange because of the linked
list. The pointer &lt;code>current&lt;/code> points to the current particle in the linked
list. It is set to be the start of the list in the line&lt;/p>
&lt;pre>&lt;code class="language-fortran">current=&amp;gt; species_list(ispecies)%attached_list%head
&lt;/code>&lt;/pre>
&lt;p>After each loop the pointer is reassigned to point to the &lt;code>next&lt;/code> element
of the current particle which advances through the linked list. The loop
terminates when the current pointer points to an unassigned (NULL)
value. The minimum loop to just iterate over the particles is&lt;/p>
&lt;pre>&lt;code class="language-fortran">MODULE ic_module
USE shared_data
USE helper
IMPLICIT NONE
PRIVATE
PUBLIC :: manual_load
CONTAINS
!This manual_load file does nothing other than loop over
!the particles in a species specified by name
SUBROUTINE manual_load
INTEGER :: ispecies
TYPE(particle), POINTER :: current
DO ispecies = 1, n_species
IF (TRIM(species_list(ispecies)%name) == 'Right') THEN
!Have found the species that I want, so grab the start of the
!linked list
current=&amp;gt; species_list(ispecies)%attached_list%head
!Now loop until I reach the end of the linked list
DO WHILE(ASSOCIATED(current))
!Advanced the linked list
current=&amp;gt;current%next
END DO
END IF
END DO
END SUBROUTINE manual_load
END MODULE ic_module
&lt;/code>&lt;/pre>
&lt;p>To actually select particles one must also implement a standard
&lt;a href="https://en.wikipedia.org/wiki/Rejection_sampling" target="_blank" rel="noopener">rejection sampling&lt;/a>
algorithm,
This is shown below.&lt;/p>
&lt;pre>&lt;code class="language-fortran">MODULE ic_module
USE shared_data
USE helper
IMPLICIT NONE
PRIVATE
PUBLIC :: manual_load
CONTAINS
!This manual_load file is an example of using an accept/reject algorithm
!to specify an arbitrary initial condition. In this case a power law
!distribution with index -alpha is specified. It is designed to work with the
!two_stream.deck example input deck
SUBROUTINE manual_load
INTEGER :: ispecies
TYPE(particle), POINTER :: current
REAL(num) :: random_number, probability
REAL(num) :: momentum_x, momentum_y, momentum
!Specify particle's momentum in mc units for simplicity
REAL(num), PARAMETER :: p_min = 0.002_num
REAL(num), PARAMETER :: p_max = 0.02_num
REAL(num), PARAMETER :: alpha = 2.0_num
DO ispecies = 1, n_species
IF (TRIM(species_list(ispecies)%name) == 'Right') THEN
!Have found the species that I want, so grab the start of the
!linked list
current=&amp;gt; species_list(ispecies)%attached_list%head
!Now loop until I reach the end of the linked list
DO WHILE(ASSOCIATED(current))
!Erase whatever momentum the particle starts with. Can keep bits
!if you want too. The particle will have momentum sampled from
!whatever temperature is specified in the deck at this point.
!part_p(1) = px
!part_p(2) = py
!part_p(3) = pz
current%part_p = 0.0_num
!Loop around until a momentum is accepted for this particle
DO
!Generate random x and y momenta between p_min and p_max
momentum_x = random() * (p_max-p_min) + p_min
momentum_y = random() * (p_max-p_min) + p_min
momentum = SQRT(momentum_x**2+momentum_y**2)
!From that value, have to generate the probability that a particle
!with that momentum should be accepted.
!This is just the particle distribution function scaled to have
!a maximum of 1 (or lower).
!In general you will have to work this out yourself
!Total momentum runs from SQRT(2.0_num)*p_min to SQRT(2.0_num)*p_max
probability = momentum**(-alpha) / (SQRT(2.0_num)*p_min) **(-alpha)
!Once you know your probability you just generate a random number
!between 0 and 1 and if the generated number is less than the
!probability then accept the particle and exit this loop.
random_number=random()
IF (random_number &amp;lt;= probability) EXIT
END DO
current%part_p(1) = momentum_x * m0 * c
current%part_p(2) = momentum_y * m0 * c
!Advanced the linked list
current=&amp;gt;current%next
END DO
END IF
END DO
END SUBROUTINE manual_load
END MODULE ic_module
&lt;/code>&lt;/pre>
&lt;h1 id="efficient_sampling">Efficient sampling&lt;/h1>
&lt;p>The power law example in the previous section has a maximum acceptance
probability of 100% at $|p| = SQRT(2.0)*p_{min}$, a minimum of 1% at
$|p| = SQRT(2.0)*p_{max}$ and an average of 2.5%. This means that in
general, we will have to consider 40 times the number of particles we
need to assign. This is inefficient and, for large numbers of particles,
potentially slow. The maximum probability cannot be above 100%, but a
smaller $p_{max}$ increases the average acceptance and speeds up the
loading. **Watch out for large power-law indices or distributions with
rapid fall-off, where the average acceptance can be very low, and the
overall loading time large.**&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/numerical_heating/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/numerical_heating/</guid><description>&lt;h1 id="pic_noise">PIC Noise&lt;/h1>
&lt;p>PIC codes effectively work by modelling packets of physical particles as
&amp;ldquo;pseudo particles&amp;rdquo; having a single velocity and a fixed spatial
extent. The number of real particles in these pseudoparticles is termed
the weight. These pseudoparticles then move as rigid objects with all of
the particles contained in them moving at that single velocity. So long
as the physics of interest in the problem are well resolved on the
spatial scale of these pseudoparticles then this model works well, but
it does inevitably average across much of the small scale physics that
takes place within the pseudoparticles. In particular the thermal motion
of the particles within the pseudoparticles are suppressed in favour of
a thermal distribution of the velocities of the entire pseudoparticles.
An ideal, non-drifting, non-relativistic Maxwellian distribution carries
zero current but even in reality since there are a finite number of
particles there will be deviations from this perfectly symmetric
distribution. Combining particles together into pseudoparticles
amplifies this effect by a factor of $w^\frac{1}{2}$ where $w$ is the
weight. So if your pseudoparticles represent 1,000,000 real particles
then the deviation from Maxwellian will be 1,000 times the level in the
real physical system. In real PIC simulations particle weights many
orders of magnitude higher than this are common. This artificial
deviation is termed PIC noise and means that you get electric and
magnetic fields purely due to deviations from the smooth Maxwellian that
are much larger than those in the real plasma.&lt;/p>
&lt;p>Since these pseudoparticles are combinations of particles with the same
charge and mass, the charge to mass ratio of the pseudoparticle is
always exactly the same as the real particles inside them and so their
trajectory in an applied field is always the same regardless of their
weight. The weight comes into the calculations through the calculation
of the current which directly involves the number of particles that are
moving.&lt;/p>
&lt;h1 id="self_heating">Self Heating&lt;/h1>
&lt;p>In real thermal plasmas at equilibrium energy is freely moving back and
forth between thermal and wave energy of the plasma and EM energy. Since
energy is conserved (ignoring loss processes) the total energy summed
over these forms is constant and so the plasma will sit quietly in
equilibrium. In an energy conserving PIC code the same process would
happen, although PIC noise would mean that the excursions of the
different forms of energy would be larger. PIC codes that do not
conserve energy however exhibit the same exchange of energy back and
forth but since conservation of energy is not enforced the plasma will
tend to heat over time. EPOCH is a momentum conserving code rather than
an energy conserving code.&lt;/p>
&lt;p>The simplest class of PIC codes, those using nearest grid point
weighting (assuming that all of the current due to a particle is
attributed to the grid point nearest that particle) exhibit very rapid
self heating unless the Debye length is resolved. This is detailed in
Langdon 1970. &lt;a href="https://doi.org/10.1016/0021-9991(70)90024-0">https://doi.org/10.1016/0021-9991(70)90024-0&lt;/a>. EPOCH does
not use nearest grid point weighting even at lowest order and has much
lower levels of self heating, especially when using spline interpolation
(see Arber et al.
&lt;a href="http://iopscience.iop.org/article/10.1088/0741-3335/57/11/113001/meta#ppcfaa013as5">http://iopscience.iop.org/article/10.1088/0741-3335/57/11/113001/meta#ppcfaa013as5&lt;/a>).
It is essential that simulations are performed at a resolution, particle
number and interpolation method that ensures that self heating is much
lower than all processes of physical interest since self heating is
entirely numerical.&lt;/p>
&lt;h1 id="weight_based_stochastic_heating_wbsh">Weight Based Stochastic Heating (WBSH)&lt;/h1>
&lt;p>This process is important where you have particles with different
weights in the same simulation (and tracer particles which effectively
have zero weight in this sense). WBSH is caused by a mixture of real and
numerical effects. In a real physical system a system of charged
particles in a stochastic electric field will heat up since the &amp;ldquo;random
kicks&amp;rdquo; to their velocity from the stochastic field causes them to
undergo a random walk in phase space, on average expanding outwards as
$t^{\frac{1}{2}}$. This process will continue until the current
contributed by the particles is large enough to modify the stochastic
field, at which point self consistent effects will cause the heating to
stop.&lt;/p>
&lt;p>In a PIC simulation with all particles having equal weight, this process
is generally uninteresting. While the motion of the particles creates a
stochastic electric field since this field is created by the current of
the particles that current is also, by construction, sufficient to
induce the self-consistent limiting of the effect. In the default mode
of operation EPOCH does not ensure that all particles have equal weights
(if you compile EPOCH with the PER_SPECIES_WEIGHT compiler flag then
all particles in a single species do have equal weight but there are
fewer simulation particles in low density regions. Even then WBSH can
occur between species with different peak densities). The number of
simulation particles per cell is set first and then the particle weight
is modified to match the requested real particle number density, which
means that particles can have weights which differ by orders of
magnitude. This can then lead to WBSH effects if the particles of high
weight and particles of low weight share the same cell (or are within a
particle shape function length of each other).&lt;/p>
&lt;p>Imagine two populations of physically identical particles modelled in a
PIC code: population 1 comes from a high density region and contains
high weight particles and population 2 comes from a low density region
and contains low weight particles. Assuming that both populations start
with the same temperature the magnitude of the stochastic field is
dominated by the behaviour of the population 1 since these particles are
of higher weight. This effect is entirely numerical since all of the
underlying physical particles in both populations are the same, but by
combining more particles together in population 1 the PIC noise is
higher than it would have been if only population 2 was present.
Population 1 particles then self consistently interact with that field
and do not heat. Population 2 particles react to that field, but do not
deposit enough current to induce their self-consistent limiting of the
heating rate and so will heat up. This heating of population 2 will
continue until they contribute broadly as much current as the particles
in population 1. This will roughly be when $wT = \mathrm{const}$ where
$w$ is the weight of the population and $T$ is the temperature of the
population. For particles with orders of magnitude difference in weight
this can be very significant.&lt;/p>
&lt;h3 id="tracer_particles">Tracer particles&lt;/h3>
&lt;p>Tracer particles are passive test particles that move in the EM fields,
but do not deposit current. As a consequence they are always affected by
WBSH since they never contribute a thermal current at all and so cannot
reach equilibrium with the currents due to other species. They are
intended to be used in place of particles with low intrinsic weights
(such as particles far into the tails of distributions) which deposit
negligible current and would suffer from WBSH anyway. They should not be
used to attempt to mimic the behaviour of particles which would deposit
substantial current were they not tracer particles without substantial
care to ensure that WBSH is not affecting your solution.&lt;/p>
&lt;hr>
&lt;h3 id="when_tracer_particles_fail">When tracer particles fail&lt;/h3>
&lt;p>While it might feel like a natural use of tracer particles one of the
cases where they will fail is when you use them to track a subset of
particles for output purposes. So it would be tempting to use a deck
like&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Electron
charge = -1
mass = 1
npart_per_cell = 1000
number_density = 1.e4
dumpmask = never
end:species
begin:species
name = Tracer
charge = -1
mass = 1
npart_per_cell = 10
number_density = density(Electron)
tracer = T
end:species
&lt;/code>&lt;/pre>
&lt;p>to produce a &amp;ldquo;1%&amp;rdquo; species that you could dump and process rather than
having to handle the large number of particles in your electron species.
This will lead to uncontrolled heating of the tracer species due to
WBSH. You can achieve the intended effect easily by&lt;/p>
&lt;hr>
&lt;h4 id="using_real_particles">Using real particles&lt;/h4>
&lt;p>Simply replace your tracer species with real particles and adjust the
densities of the two species to add to your requested overall density.
both species will have the same weight and experience the same
stochastic heating&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Electron
charge = -1
mass = 1
npart_per_cell = 1000
number_density = 1.e4 * 0.99
dumpmask = never
end:species
begin:species
name = Tracer
charge = -1
mass = 1
npart_per_cell = 10
number_density = 1e4*0.01
end:species
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h4 id="using_subsets">Using subsets&lt;/h4>
&lt;p>If you just want a representative 1% of the particles to be dumped at
each output then you can use
&lt;a href="/tutorial/input_deck_subset">subsets&lt;/a>. The below example will
produce output of a random 1% sample on each output dump. The selected
1% is different on every output.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = Electron
charge = -1
mass = 1
npart_per_cell = 1000
number_density = 1.e4
end:species
begin:subset
name = background
random_fraction = 0.01
include_species:Electron
end:subset
begin:output
particles = background
px = background
py = background
pz = background
end:output
&lt;/code>&lt;/pre>
&lt;hr>
&lt;h4 id="using_persistent_subsets">Using persistent subsets&lt;/h4>
&lt;p>If you need to always track the same 1% of the particles then you can
use
&lt;a href="/tutorial/input_deck_subset"> persistent subsets&lt;/a>. They are
almost identical to subsets but you have to tell EPOCH at which time to
&amp;ldquo;lock&amp;rdquo; the particles to follow. The below example will lock in a
random 1% of the particles at the start of the simulation and always
output that 1% at all subsequent dumps. Persistent subsets do increase
EPOCH&amp;rsquo;s memory footprint by about 10% of the number of particles that
you request it to store, in this case about 0.1% of the total memory
footprint.&lt;/p>
&lt;pre>&lt;code class="language-perl">
begin:species
name = Electron
charge = -1
mass = 1
npart_per_cell = 1000
number_density = 1.e4
end:species
begin:subset
name = background
persist_after = 0.0
random_fraction = 0.01
include_species:Electron
end:subset
begin:output
particles = background
px = background
py = background
pz = background
end:output
&lt;/code>&lt;/pre>
&lt;h3 id="when_tracer_particles_work">When tracer particles work&lt;/h3>
&lt;p>Tracer particles are intended for a situation where you believe that you
have a small number of particles that you believe will not contribute
meaningfully to the current and don&amp;rsquo;t want to waste time calculating
the current for those particles. A classical example of this is when you
want to simulate particles well into the tail of a distribution function
that you wish to trace the behaviour of in the self consistent fields
from the bulk plasma.&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
temperature = 1e6
pte = sqrt(me * kb * temperature) #Non relativistic thermal momentum
end:constant
begin:species
name = Electron
charge = -1
mass = 1
npart_per_cell = 10
number_density = 1.e4
temp = temperature
end:species
begin:species
name = Tail
charge = -1
mass = 1
npart_per_cell = 10
number_density = 1 #Don't actually care about absolute number density so normalise to 1
drift = 6 * pte #Put these particles 6 thermal velocities out
tracer = T
end:species
&lt;/code>&lt;/pre>
&lt;p>This allows you to have many particles in the tail of the distribution
while having comparatively few in the core (you would need 10s of
millions of particles per cell to get 10 particles per cell at 6 thermal
velocities in a single species). The advantage of using tracer particles
rather than real particles are&lt;/p>
&lt;ol>
&lt;li>You can arbitrarily normalise the density without it having any
effect on the simulation. This is helpful if it would be onerous to
calculate the density in the wings of your distribution function.&lt;/li>
&lt;li>The particle pusher is about 10% faster when not calculating
currents so if many of your particles are in your tail species EPOCH
can be usefully faster&lt;/li>
&lt;/ol>
&lt;p>While the particles in your Tail species will experience WBSH, real
particles in the tail would need very low weights to get the correct
density while retailing the requested particle per cell numbers. Since
the current due to the tail particles is very small the effect of
completely ignoring it is also very small so the benefits in performance
and simplicity of setup are useful.&lt;/p>
&lt;h3 id="when_wbsh_is_important">When WBSH is important&lt;/h3>
&lt;p>WBSH is generally not a major concern in PIC codes, but it can be
important for certain classes of problem, especially when particles with
very different weights are present at the same spatial location for long
periods before they interact with the physics of interest in your
simulation.&lt;/p>
&lt;ol>
&lt;li>Putting a very low density positron population inside a higher
density plasma as an initial condition unless you also adjust the
number of particles per cell so that the weight is the same for both
positrons and plasma electrons. This might well require many
particles per cell for your plasma electrons if the number of
positrons is very low.&lt;/li>
&lt;li>Putting in a &amp;ldquo;patch&amp;rdquo; of space with a large number of particles per
cell to try and resolve distribution functions locally&lt;/li>
&lt;li>Putting tracer particles in with real particles to monitor a section
of space&lt;/li>
&lt;li>At very large jumps in density (not smooth ramps, but substantial
discontinuities)&lt;/li>
&lt;/ol>
&lt;p>There is no guarantee that a particular simulation having these
properties will show substantial changes to the output as a result of
WBSH, but care must be taken to ensure that it does not. As always,
convergence testing your answer will help to show up statistical
problems in your simulation. In particular you should increase the
number of psuedo-particles in the higher weight species to reduce the
weight discrepancy.&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/previous_versions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/previous_versions/</guid><description>&lt;h1 id="changes_between_version_3" class="1_and_4 0">Changes between version 3.1 and 4.0&lt;/h1>
&lt;h1 id="changes_to_the_makefile">Changes to the Makefile&lt;/h1>
&lt;p>Some changes have been made to the Makefile. These are documented
&lt;a href="/tutorial/compiler_flags">here&lt;/a>.&lt;br>
The following compile-time defines have been added to the Makefile:&lt;/p>
&lt;ul>
&lt;li>NO_IO&lt;/li>
&lt;li>PARTICLE_ID&lt;/li>
&lt;li>PARTICLE_ID4&lt;/li>
&lt;li>COLLISIONS_TEST&lt;/li>
&lt;li>PHOTONS&lt;/li>
&lt;li>TRIDENT_PHOTONS&lt;/li>
&lt;li>PREFETCH&lt;/li>
&lt;/ul>
&lt;p>The following compile-time defines have been removed from the Makefile:&lt;/p>
&lt;ul>
&lt;li>COLLISIONS&lt;/li>
&lt;li>SPLIT_PARTICLES_AFTER_PUSH&lt;/li>
&lt;li>PARTICLE_IONISE&lt;/li>
&lt;/ul>
&lt;h1 id="major_features_and_new_blocks_added_to_the_input_deck">Major features and new blocks added to the input deck&lt;/h1>
&lt;ul>
&lt;li>
&lt;a href="/tutorial/input_deck_boundaries/#cpml_boundary_conditions">CPML boundary
conditions&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/tutorial/input_deck_boundaries/#thermal_boundary_conditions">Thermal boundary
conditions&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/tutorial/input_deck_collisions">Collisions&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/tutorial/input_deck_qed">QED&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/tutorial/input_deck_subset">Subsets&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/tutorial/input_deck_species/#ionisation">Ionisation&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/tutorial/input_deck_output_block/#single-precision_output">Single-precision
output&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/tutorial/input_deck_output_block/#multiple_output_blocks">Multiple output
blocks&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/tutorial/input_deck_species/#particle_migration_between_species">Particle
migration&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="additional_output_block_parameters">Additional output block parameters&lt;/h1>
&lt;p>The following parameters have also been added to the &amp;ldquo;output&amp;rdquo; block (see
&lt;a href="/tutorial/input_deck_output/#directives">here&lt;/a>):&lt;/p>
&lt;ul>
&lt;li>dump_first&lt;/li>
&lt;li>dump_last&lt;/li>
&lt;li>force_first_to_be_restartable&lt;/li>
&lt;li>ejected_particles&lt;/li>
&lt;li>absorption&lt;/li>
&lt;li>id&lt;/li>
&lt;li>name&lt;/li>
&lt;li>restartable&lt;/li>
&lt;/ul>
&lt;h1 id="other_additions_to_the_input_deck">Other additions to the input deck&lt;/h1>
&lt;ul>
&lt;li>
&lt;a href="/tutorial/input_deck_species">npart_per_cell&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/tutorial/input_deck_dist_fn">dir_{xy,yz,zx}_angle&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/tutorial/input_deck_control">particle_tstart&lt;/a>&lt;/li>
&lt;li>
&lt;a href="/tutorial/input_deck_species">identify&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Finally, the input deck now has a method for writing continuation lines.
If the deck contains a &amp;ldquo;&amp;quot; character then the rest of the line is
ignored and the next line becomes a continuation of the current one.&lt;/p>
&lt;h1 id="changes_between_version_4" class="0_and_4 3">Changes between version 4.0 and 4.3&lt;/h1>
&lt;h1 id="changes_to_the_makefile_1">Changes to the Makefile&lt;/h1>
&lt;p>Some changes have been made to the Makefile. These are documented
&lt;a href="/tutorial/compiler_flags">here&lt;/a> .&lt;br>
The following compile-time define has been added to the Makefile:&lt;/p>
&lt;ul>
&lt;li>MPI_DEBUG&lt;/li>
&lt;/ul>
&lt;p>The following compile-time define has been removed from the Makefile:&lt;/p>
&lt;ul>
&lt;li>FIELD_DEBUG&lt;/li>
&lt;/ul>
&lt;h1 id="additions_to_the_input_deck">Additions to the input deck&lt;/h1>
&lt;p>The following parameters have been added to the
&lt;a href="/tutorial/input_deck_control">&amp;ldquo;control&amp;rdquo;&lt;/a> block of the input
deck:&lt;/p>
&lt;ul>
&lt;li>nproc{x,y,z}&lt;/li>
&lt;li>smooth_currents&lt;/li>
&lt;li>field_ionisation&lt;/li>
&lt;li>use_exact_restart&lt;/li>
&lt;li>allow_cpu_reduce&lt;/li>
&lt;li>check_stop_file_frequency&lt;/li>
&lt;li>stop_at_walltime&lt;/li>
&lt;li>stop_at_walltime_file&lt;/li>
&lt;li>simplify_deck&lt;/li>
&lt;li>print_constants&lt;/li>
&lt;li>The &amp;ldquo;restart_snapshot&amp;rdquo; parameter now accepts filenames&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the
&lt;a href="/tutorial/input_deck_output_block">&amp;ldquo;output&amp;rdquo;&lt;/a> block of the input
deck:&lt;/p>
&lt;ul>
&lt;li>disabled&lt;/li>
&lt;li>time_start&lt;/li>
&lt;li>time_stop&lt;/li>
&lt;li>nstep_start&lt;/li>
&lt;li>nstep_stop&lt;/li>
&lt;li>dump_at_times&lt;/li>
&lt;li>dump_at_nsteps&lt;/li>
&lt;li>dump_cycle&lt;/li>
&lt;li>dump_cycle_first_index&lt;/li>
&lt;li>filesystem&lt;/li>
&lt;li>file_prefix&lt;/li>
&lt;li>rolling_restart&lt;/li>
&lt;li>particle_energy&lt;/li>
&lt;li>relativistic_mass&lt;/li>
&lt;li>gamma&lt;/li>
&lt;li>total_energy_sum&lt;/li>
&lt;li>optical_depth&lt;/li>
&lt;li>qed_energy&lt;/li>
&lt;li>trident_optical_depth&lt;/li>
&lt;li>The default value of &amp;ldquo;dump_first&amp;rdquo; is now &amp;ldquo;T&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>The following parameter has been added to the
&lt;a href="/tutorial/input_deck_collisions">&amp;ldquo;collisions&amp;rdquo;&lt;/a> block of the
input deck:&lt;/p>
&lt;ul>
&lt;li>collisional_ionisation&lt;/li>
&lt;/ul>
&lt;p>The following parameter has been added to the
&lt;a href="/tutorial/input_deck_qed">&amp;ldquo;qed&amp;rdquo;&lt;/a> block of the input deck:&lt;/p>
&lt;ul>
&lt;li>use_radiation_reaction&lt;/li>
&lt;/ul>
&lt;p>The following parameter has been added to the
&lt;a href="/tutorial/input_deck_species">&amp;ldquo;species&amp;rdquo;&lt;/a> block of the input
deck:&lt;/p>
&lt;ul>
&lt;li>immobile&lt;/li>
&lt;/ul>
&lt;p>The following parameters were changed in the
&lt;a href="/tutorial/input_deck_laser">&amp;ldquo;laser&amp;rdquo;&lt;/a> block of the input deck:&lt;/p>
&lt;ul>
&lt;li>The &amp;ldquo;phase&amp;rdquo; parameter can now be time varying&lt;/li>
&lt;li>The &amp;ldquo;profile&amp;rdquo; parameter can now be time varying&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the list of pre-defined
[constants][maths_parser__constants].&lt;/p>
&lt;ul>
&lt;li>nproc_{x,y,z}&lt;/li>
&lt;li>nsteps&lt;/li>
&lt;li>t_end&lt;/li>
&lt;li>cc&lt;/li>
&lt;/ul>
&lt;p>There has also been a new
&lt;a href="/tutorial/input_deck_output_global">&amp;ldquo;output_global&amp;rdquo;&lt;/a> block
added to the input deck.&lt;/p>
&lt;h1 id="changes_in_behaviour_which_are_not_due_to_changes_in_the_input_deck">Changes in behaviour which are not due to changes in the input deck&lt;/h1>
&lt;ul>
&lt;li>The species &amp;ldquo;drift&amp;rdquo; property is now applied to particles whilst the
moving window model is active. In previous versions of the code,
this property was ignored once the moving window began.&lt;/li>
&lt;li>Ionisation species now inherit their &amp;ldquo;dumpmask&amp;rdquo;. See
&lt;a href="/tutorial/input_deck_species/#ionisation">here&lt;/a> for details.&lt;/li>
&lt;li>Default values for ignorable directions were added. This change
allows submitting 3D or 2D input decks to a 1D version of and 3D
input decks to a 2D version of . Any references to y/z will be set
equal to zero unless overridden by a deck constant. Other y/z values
also assume sensible defaults, eg. 1 grid cell, 1 metre thick, etc.&lt;/li>
&lt;li>Automatic byte swapping is carried out by the SDF library. The
library now checks the endianness of the SDF file and byte-swaps the
data if required.&lt;/li>
&lt;li>&amp;ldquo;qed&amp;rdquo; blocks may now be present even if the code was not compiled
using the &amp;ldquo;-DPHOTONS&amp;rdquo; flag. The code will only halt if &amp;ldquo;use_qed=T&amp;rdquo;
inside the &amp;ldquo;qed&amp;rdquo; block.&lt;/li>
&lt;li>The code now checks for the Data directory in a file named
&amp;ldquo;USE_DATA_DIRECTORY&amp;rdquo; before prompting at the command-line. This
allows the code to be run without waiting for input at the
command-line.&lt;/li>
&lt;li>The field and particle grids are now automatically written to SDF
output files if they are needed.&lt;/li>
&lt;li>The Data directory may now contain a &amp;lsquo;&lt;code>/&lt;/code>&amp;rsquo; character.&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="3_and_4 8">Changes between version 4.3 and 4.8&lt;/h1>
&lt;h1 id="changes_to_the_makefile_2">Changes to the Makefile&lt;/h1>
&lt;p>Some changes have been made to the Makefile. These are documented
&lt;a href="/tutorial/compiler_flags">here&lt;/a>.&lt;br>
The following compile-time define has been added to the Makefile:&lt;/p>
&lt;ul>
&lt;li>PER_SPECIES_WEIGHT&lt;/li>
&lt;li>NO_TRACER_PARTICLES&lt;/li>
&lt;li>NO_PARTICLE_PROBES&lt;/li>
&lt;li>PARSER_CHECKING&lt;/li>
&lt;/ul>
&lt;p>The following compile-time define has been removed from the Makefile:&lt;/p>
&lt;ul>
&lt;li>PER_PARTICLE_WEIGHT&lt;/li>
&lt;li>TRACER_PARTICLES&lt;/li>
&lt;li>PARTICLE_PROBES&lt;/li>
&lt;/ul>
&lt;h1 id="additions_to_the_input_deck_1">Additions to the input deck&lt;/h1>
&lt;p>The following parameters have been added to the
&lt;a href="/tutorial/input_deck_control">&amp;ldquo;control&amp;rdquo;&lt;/a> block of the input
deck:&lt;/p>
&lt;ul>
&lt;li>allow_missing_restart&lt;/li>
&lt;li>print_eta_string&lt;/li>
&lt;li>n_zeros&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the
&lt;a href="/tutorial/input_deck_output_block">&amp;ldquo;output&amp;rdquo;&lt;/a> block of the input
deck):&lt;/p>
&lt;ul>
&lt;li>weight (synonym for particle_weight)&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the
&lt;a href="/tutorial/input_deck_output_global">&amp;ldquo;output_global&amp;rdquo;&lt;/a> block of
the input deck:&lt;/p>
&lt;ul>
&lt;li>dump_first_after_restart&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the
&lt;a href="/tutorial/input_deck_subset">&amp;ldquo;subset&amp;rdquo;&lt;/a> block of the input deck:&lt;/p>
&lt;ul>
&lt;li>skip, skip_&lt;code>x,y,z&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="8_and_4 9">Changes between version 4.8 and 4.9&lt;/h1>
&lt;h1 id="new_capabilities">New capabilities&lt;/h1>
&lt;p>Version 4.9 adds significant new capabilities as follows:&lt;/p>
&lt;ul>
&lt;li>delta-f version: particle distributions can be expressed as
$f_0 + f_1$ where $f_0$ is a specified background plasma and all
simulation particles are used to describe the $f_1$ component,
documented in .&lt;/li>
&lt;li>selectable field solvers: 3 new solvers have been added for fields,
fully documented in .&lt;/li>
&lt;/ul>
&lt;h1 id="changes_to_the_makefile_3">Changes to the Makefile&lt;/h1>
&lt;p>Some changes have been made to the Makefile. These are documented in .&lt;br>
The following compile-time define has been added to the Makefile:&lt;/p>
&lt;ul>
&lt;li>DELTAF_METHOD&lt;/li>
&lt;li>DELTAF_DEBUG&lt;/li>
&lt;li>USE_ISATTY&lt;/li>
&lt;/ul>
&lt;h1 id="additions_to_the_input_deck_2">Additions to the input deck&lt;/h1>
&lt;p>The following alterations were made to the input deck:&lt;/p>
&lt;ul>
&lt;li>ioniz* (with a &amp;ldquo;z&amp;rdquo;) aliases have been added for ionis* keywords.&lt;/li>
&lt;li>y and z parameters can now appear in the input deck in EPOCH 1D and
2D.&lt;/li>
&lt;/ul>
&lt;p>A new deck block has been added. The particles_from_file block allows
loading of custom particle data from raw binary data files. See for
details. This block accepts the following parameters:&lt;/p>
&lt;ul>
&lt;li>species&lt;/li>
&lt;li>{xyz}_data&lt;/li>
&lt;li>w_data&lt;/li>
&lt;li>{xyz}_data&lt;/li>
&lt;li>id{4,8}_data&lt;/li>
&lt;li>offset&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the &amp;ldquo;control&amp;rdquo; block of the
input deck (see ):&lt;/p>
&lt;ul>
&lt;li>maxwell_solver&lt;/li>
&lt;li>use_current_correction&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the &amp;ldquo;species&amp;rdquo; block of the
input deck (see ):&lt;/p>
&lt;ul>
&lt;li>maxwell_solver&lt;/li>
&lt;li>number_density_back&lt;/li>
&lt;li>drift_{x,y,z}_back&lt;/li>
&lt;li>temp_{x,y,z}_back&lt;/li>
&lt;li>temp_{x,y,z}_back_ev&lt;/li>
&lt;li>temp_back&lt;/li>
&lt;li>temp_back_ev&lt;/li>
&lt;/ul>
&lt;p>The following parameters have been added to the &amp;ldquo;dist_fn' block of the
input deck (see ):&lt;/p>
&lt;ul>
&lt;li>dir may now take the value mod_p&lt;/li>
&lt;li>restrict_mod_p&lt;/li>
&lt;/ul>
&lt;h1 id="changes_not_resulting_from_changes_to_the_deck">Changes not resulting from changes to the deck&lt;/h1>
&lt;ul>
&lt;li>Lasers can be specified with time-varying frequency profile.&lt;/li>
&lt;li>The existing subset blocks can now be applied to field and derived
grid variables. If spatial restrictions are used, subsections will
be output, along with a corresponding grid. Note that these are not
compatible with the &amp;ldquo;skip&amp;rdquo; parameter to subset blocks.&lt;/li>
&lt;li>The dist_fn block &amp;ldquo;range&amp;rdquo; keyword is now respected for spatial
directions, allowing a spatial subset of the distribution function
to be output directly.&lt;/li>
&lt;li>Some corrections were applied to calculation of thermal boundary
conditions for particles.&lt;/li>
&lt;li>The load balancer may now be disabled by setting a 0 or negative
threshold.&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="9_and_4 10">Changes between version 4.9 and 4.10&lt;/h1>
&lt;h1 id="new_capabilities_1">New capabilities&lt;/h1>
&lt;p>Version 4.10 adds the following new capabilities:&lt;/p>
&lt;ul>
&lt;li>Time varying particle injectors. See
&lt;a href="/tutorial/input_deck_injector">
here&lt;/a>&lt;/li>
&lt;li>Per-species particle boundaries. You can now specify bc_x_min and
bc_x_max to a species block. This overrides the global boundaries
for that species. See
&lt;a href="/tutorial/input_deck_species/#species_boundary_conditions">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;particles_per_cell&amp;rdquo; output diagnostic. See
&lt;a href="/tutorial/input_deck_output_block/#derived_variables">here&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="10_and_4 11">Changes between version 4.10 and 4.11&lt;/h1>
&lt;h1 id="new_capabilities_2">New capabilities&lt;/h1>
&lt;p>Version 4.11 adds the following new capabilities:&lt;/p>
&lt;ul>
&lt;li>Added time dependent moving window. No new input deck parameters
have been added, but it is now possible to specify &amp;ldquo;window_v_x&amp;rdquo; to
be a function that varies in time. See
&lt;a href="/tutorial/input_deck_window">here&lt;/a>&lt;/li>
&lt;li>If &amp;ldquo;print_constants=T&amp;rdquo; in the control block (see
&lt;a href="/tutorial/input_deck_control">here&lt;/a>) deck constants are now
output to a separate file named &amp;ldquo;const.status&amp;rdquo;. This allows for
easier post-processing.&lt;/li>
&lt;li>Added COMPILER=auto option to automatically detect compiler. See
&lt;a href="/tutorial/compiling">here&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>The following correction has been made:&lt;/p>
&lt;ul>
&lt;li>Fractional numbers of particles-per-cell now function as expected
when used in conjunction with the moving window.&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="11_and_4 12">Changes between version 4.11 and 4.12&lt;/h1>
&lt;h1 id="new_capabilities_3">New capabilities&lt;/h1>
&lt;p>Version 4.12 adds the following new capabilities:&lt;/p>
&lt;ul>
&lt;li>Added &amp;ldquo;average_weight&amp;rdquo; output diagnostic. See
&lt;a href="/tutorial/input_deck_output_block/#derived_variables">here&lt;/a>&lt;/li>
&lt;li>Removed the &amp;ldquo;PARTICLE_COUNT_UPDATE&amp;rdquo; Makefile flag and replaced it
with a &amp;ldquo;use_particle_count_update&amp;rdquo; parameter in the control
block. See
&lt;a href="/tutorial/input_deck_control/#basics">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;use_flux_maxwellian&amp;rdquo; option to the &amp;ldquo;injector&amp;rdquo; block. See
&lt;a href="/tutorial/input_deck_injector/#keys">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;lehe_{x,y,z}&amp;rdquo; flags to the &amp;ldquo;maxwell_solver&amp;rdquo; option in the
control block. See
&lt;a href="/tutorial/input_deck_control/#maxwell_solvers">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;use_accurate_n_zeros&amp;rdquo; control block parameter. See
&lt;a href="/tutorial/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;custom&amp;rdquo; flag to the &amp;ldquo;maxwell_solver&amp;rdquo; option in the control
block. See
&lt;a href="/tutorial/input_deck_control">here&lt;/a> and
&lt;a href="/tutorial/input_deck_control/#stencil_block">here&lt;/a>&lt;/li>
&lt;li>Added the &amp;ldquo;WORK_DONE_INTEGRATED&amp;rdquo; Makefile flag and corresponding
dumpmask directives &amp;ldquo;work_{x,y,z}&amp;rdquo; and &amp;ldquo;work_{x,y,z}_total&amp;rdquo;.
These add a diagnostic for the work done on a particle by the
electric field. See
&lt;a href="/tutorial/compiler_flags">here&lt;/a> and
&lt;a href="/tutorial/input_deck_output_block/#particle_variables">here&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="12_and_4 14">Changes between version 4.12 and 4.14&lt;/h1>
&lt;h1 id="new_capabilities_4">New capabilities&lt;/h1>
&lt;p>Version 4.14 adds the following new capabilities:&lt;/p>
&lt;ul>
&lt;li>Added the &amp;ldquo;reset_walltime&amp;rdquo; flag to the control block. See
&lt;a href="/tutorial/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>Changed the default value of &amp;ldquo;print_eta_string&amp;rdquo; to &amp;ldquo;T&amp;rdquo; in the
control block.&lt;/li>
&lt;li>Added the ability to request an output dump at run time. See
&lt;a href="/tutorial/input_deck_control/#requesting_output_dumps_at_run_time">here&lt;/a>&lt;/li>
&lt;li>Added the &amp;ldquo;window_stop_time&amp;rdquo; parameter to the window block. See
&lt;a href="/tutorial/input_deck_window">here&lt;/a>&lt;/li>
&lt;li>Added the &amp;ldquo;atan2&amp;rdquo; function to the maths parser. See
&lt;a href="/tutorial/maths_parser/#functions">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;dlb_maximum_interval&amp;rdquo; parameter to the control block. See
&lt;a href="/tutorial/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;dlb_force_interval&amp;rdquo; parameter to the control block. See
&lt;a href="/tutorial/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;balance_first&amp;rdquo; parameter to the control block. See
&lt;a href="/tutorial/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>Added y and z versions of the &amp;ldquo;bc_x_min_after_move&amp;rdquo; and
&amp;ldquo;bc_x_max_after_move&amp;rdquo; parameters to the window block. See
&lt;a href="/tutorial/input_deck_window">here&lt;/a>&lt;/li>
&lt;li>Added a &amp;ldquo;dump_at_walltimes&amp;rdquo; parameter to the output block. See
&lt;a href="/tutorial/input_deck_output_block/#multiple_output_blocks">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;walltime_start&amp;rdquo; and &amp;ldquo;walltime_stop&amp;rdquo; parameters to the
output block and output_global block. See
&lt;a href="/tutorial/input_deck_output_block/#directives">here&lt;/a> and
&lt;a href="/tutorial/input_deck_output_global">here&lt;/a>&lt;/li>
&lt;li>Added &amp;ldquo;walltime_interval&amp;rdquo; parameter to the output block. See
&lt;a href="/tutorial/input_deck_output_block/#multiple_output_blocks">here&lt;/a>&lt;/li>
&lt;li>Added the Higuera-Cary particle push. This can be enabled using the
&amp;ldquo;HC_PUSH&amp;rdquo; Makefile flag. See
&lt;a href="/tutorial/compiler_flags">here&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="14_and_4 15">Changes between version 4.14 and 4.15&lt;/h1>
&lt;ul>
&lt;li>Added averaging of &amp;ldquo;poynt_flux&amp;rdquo; and &amp;ldquo;ekflux&amp;rdquo; variables.&lt;/li>
&lt;li>The initial problem setup can now be load-balanced before any
particles are loaded. This enables some heavily imbalanced setups to
be run that were not previously possible.
&lt;ul>
&lt;li>Added the &amp;ldquo;use_pre_balance&amp;rdquo; flag to the control block. See
&lt;a href="/tutorial/input_deck_control">here&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Allow the load balancer to adjust the processor topology
&lt;ul>
&lt;li>Added the &amp;ldquo;use_optimal_layout&amp;rdquo; flag to the control block. See
&lt;a href="/tutorial/input_deck_control">here&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Added control block option &amp;ldquo;use_more_setup_memory&amp;rdquo; for
controlling the way that species are setup. See
&lt;a href="/tutorial/input_deck_control">here&lt;/a>&lt;/li>
&lt;li>Added strided multipass digital current filtering (See
&lt;a href="/tutorial/input_deck_control/#strided_current_filtering">here&lt;/a>).
This adds the following flags to the control block.
&lt;ul>
&lt;li>smooth_iterations&lt;/li>
&lt;li>smooth_compensation&lt;/li>
&lt;li>smooth_strides&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Added persistent subsets. See
&lt;a href="/tutorial/input_deck_subset">here&lt;/a>. This adds the following
flags to the subset block
&lt;ul>
&lt;li>persist_start_time&lt;/li>
&lt;li>persist_start_step&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Added loading of relativistic particle species using the
Maxwell-Jüttner distribution. See
&lt;a href="/tutorial/input_deck_species/#maxwell_juttner_distributions">here&lt;/a>.
This adds the following flags to the species block
&lt;ul>
&lt;li>use_maxwell_juttner&lt;/li>
&lt;li>fractional_tail_cutoff&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Added loading of particle species using an arbitrary distribution
function for sampling the momentum components. See
&lt;a href="/tutorial/input_deck_species/#arbitrary_distribution_functions">here&lt;/a>.
This adds the following flags to the species block
&lt;ul>
&lt;li>dist_fn&lt;/li>
&lt;li>dist_fn_p{x,y,z}_range&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Added &amp;ldquo;temperature_{x,y,z}&amp;rdquo; derived output variables to the output
block. See
&lt;a href="/tutorial/input_deck_output_block/#derived_variables">here&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="changes_between_version_4" class="15_and_4 16">Changes between version 4.15 and 4.16&lt;/h1>
&lt;ul>
&lt;li>
&lt;dl>
&lt;dt>Added &amp;ldquo;number_density&amp;rdquo; aliases for &amp;ldquo;density&amp;rdquo; in the species and&lt;/dt>
&lt;dt>injector blocks (see
&lt;a href="/tutorial/input_deck_species">here&lt;/a> and&lt;/dt>
&lt;dt>
&lt;a href="/tutorial/input_deck_injector">here&lt;/a>).&lt;/dt>
&lt;dd>
&lt;p>These aliases include:&lt;/p>
&lt;/dd>
&lt;/dl>
&lt;ul>
&lt;li>number_density for density&lt;/li>
&lt;li>promote_number_density for promote_density&lt;/li>
&lt;li>demote_number_density for demote_density&lt;/li>
&lt;li>number_density_min for density_min&lt;/li>
&lt;li>number_density_max for density_max&lt;/li>
&lt;li>number_density_back for density_back&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Replaced &amp;ldquo;USE_ISATTY&amp;rdquo; Makefile flag with &amp;ldquo;NO_USE_ISATTY&amp;rdquo;. See
&lt;a href="/tutorial/compiler_flags">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Added &amp;ldquo;NO_MPI3&amp;rdquo; Makefile flag. See
&lt;a href="/tutorial/compiler_flags">here&lt;/a>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Added a &amp;ldquo;zero_current&amp;rdquo; alias for &amp;ldquo;tracer&amp;rdquo; in the species blocks.
See
&lt;a href="/tutorial/input_deck_species">here&lt;/a>. The use of &amp;ldquo;tracer&amp;rdquo;
has now been deprecated and will be removed in version 5.0. At that
time, the compiler flag will also be renamed.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/running/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/running/</guid><description>&lt;p>When the code is run, the output is&lt;/p>
&lt;pre>&lt;code> d########P d########b .######b d####### d##P d##P
d########P d########### d########### .########## d##P d##P
---- ---- ---- ----- ---- ----- ---- -- P
d########P d####,,,####P ####. .#### d###P d############P
d########P d#########P #### .###P ####. d############P
d##P d##P #### d#### ####. d##P d##P
d########P d##P ###########P ##########P d##P d##P
d########P d##P d######P #######P d##P d##P
The code was compiled with no compile time options
Welcome to EPOCH2D version 4.12.0 (commit v4.12.0-0-gfd74a464-clean)
Code is running on 1 processing elements
Specify output directory
&lt;/code>&lt;/pre>
&lt;p>At which point the end user should simply type in the name of the
directory where the code output is to be placed. This directory must
also include the file which controls the code setup, specifies how to
set the initial conditions and controls the I/O. Writing an input deck
for EPOCH is fairly time consuming and so the code is supplied with some
example input decks which include all the necessary sections for the
code to run. Alternately, the code checks for the Data directory in a
file named &amp;ldquo;USE_DATA_DIRECTORY&amp;rdquo; before prompting at the command-line.
This allows the code to be run without waiting for input at the
command-line.&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/input_deck"> The EPOCH input deck&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/sdf_landing_page/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/sdf_landing_page/</guid><description>&lt;h1 id="visualising_data_in_sdf_output">Visualising Data in SDF output&lt;/h1>
&lt;p>
&lt;a href="/tutorial/visualising_sdf_files_with_idl_or_gdl">Visualising SDF files using Harris Geospatial IDL or GNU Data Language
(GDL)&lt;/a>&lt;br>
&lt;a href="/tutorial/visualising_sdf_files_with_llnl_visit">Visualising SDF files using LLNL
VisIt&lt;/a>&lt;br>
&lt;a href="/tutorial/python"> Visualising SDF files using Python&lt;/a>\&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/python/</guid><description>&lt;h1 id="installing_the_python_sdf_readers">Installing the python sdf readers&lt;/h1>
&lt;p>To install the python sdf readers you need to have an installation of
python (2 or 3) with the numpy library. The automated plotting library
requires the matplotlib library. Both numpy and matplotlib are available
through most system package managers or are installable through
&lt;a href="https://pip.pypa.io/en/stable/" target="_blank" rel="noopener">pip&lt;/a>.&lt;/p>
&lt;p>Once you have a working python install, just go into one of the epoch
directories (epoch1d, epoch2d or epoch3d) and type&lt;/p>
&lt;p>&lt;code>make sdfutils&lt;/code>&lt;/p>
&lt;p>This will build the SDF python library and install the sdf_helper
wrapper and utility layer.&lt;/p>
&lt;h1 id="using_the_sdf_helper_wrapper_layer">Using the sdf_helper wrapper layer&lt;/h1>
&lt;p>The low level python SDF library is not user friendly, so a wrapper
layer called sdf_helper has been written. This wrapper layer simplifies
loading SDF files and provides simple plotting routines using
matplotlib.&lt;/p>
&lt;h3 id="importing_sdf_helper">Importing sdf_helper&lt;/h3>
&lt;p>Importing sdf_helper is as simple as&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper
&lt;/code>&lt;/pre>
&lt;p>In these examples, the numpy and matplotlib libraries are usually loaded
too, and an alias is created for sdf_helper, so the boilerplate code
looks like&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
import numpy as np
import matplotlib.pyplot as plt
&lt;/code>&lt;/pre>
&lt;h3 id="loading_an_sdf_file_using_sdf_helper">Loading an sdf file using sdf_helper&lt;/h3>
&lt;p>To load a file, use the &lt;code>getdata&lt;/code> function. This function takes either a
string which it loads as a filename, so to load the file &lt;code>Data/0010.df&lt;/code>
you would run&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
data=sh.getdata('Data/0010.sdf')
&lt;/code>&lt;/pre>
&lt;p>or it takes a number which is the dump number, and optionally a second
parameter which is the directory name as a string, so you would run&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
data=sh.getdata(10, 'Data')
&lt;/code>&lt;/pre>
&lt;p>Because memory is only allocated when needed in the SDF python reader
there is no way of specifying which variables to load using getdata. All
variables are available when the file is first loaded, and memory is
allocated when the variable is first used.&lt;/p>
&lt;h3 id="listing_the_available_variables_in_an_sdf_file">Listing the available variables in an sdf file&lt;/h3>
&lt;p>To see what variables are available use the list_variables method&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
data=sh.getdata('Data/0010.sdf')
sh.list_variables(data)
&lt;/code>&lt;/pre>
&lt;p>This produces an output that looks something like&lt;/p>
&lt;pre>&lt;code class="language-text">CPUs_Current_rank &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [0]
CPUs_Original_rank &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [2]
Current_Jx &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400]
Derived_Charge_Density &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400]
Derived_Number_Density &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400]
Derived_Number_Density_Left &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400]
Derived_Number_Density_Right &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400]
Electric_Field_Ex &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400]
Grid_CPUs_Original_rank &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [3]
Grid_CPUs_Original_rank_mid &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [2]
Grid_Grid &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [401]
Grid_Grid_mid &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [400]
Grid_x_px_Left &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [400, 200]
Grid_x_px_Left_mid &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [399, 199]
Grid_x_px_Right &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [400, 200]
Grid_x_px_Right_mid &amp;lt;class 'sdf.BlockPlainMesh'&amp;gt; [399, 199]
Wall_time &amp;lt;class 'sdf.BlockConstant'&amp;gt; [1]
dist_fn_x_px_Left &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400, 200]
dist_fn_x_px_Right &amp;lt;class 'sdf.BlockPlainVariable'&amp;gt; [400, 200]
&lt;/code>&lt;/pre>
&lt;p>These are the names of the variables in the data structure. This example
is taken from the supplied &lt;code>two_stream.deck&lt;/code> example in 1D.&lt;/p>
&lt;h3 id="working_with_the_data_in_an_sdf_file">Working with the data in an SDF file&lt;/h3>
&lt;p>You can access the underlying data using the names obtained from
&lt;code>list_variables&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">variable = data.Electric_Field_Ex
&lt;/code>&lt;/pre>
&lt;p>This returns an instance of either &lt;code>sdf.BlockPlainVariable&lt;/code> or
&lt;code>sdf.BlockPointVariable&lt;/code> depending on whether you have requested a grid
variable (such as Ex, Ey or a distribution function) or a particle
variable (such as particle momentum or weight). The raw contents of the
variable is a numpy array. It is then available using the &lt;code>data&lt;/code> element
of these objects.&lt;/p>
&lt;pre>&lt;code class="language-python">import numpy as np
variable = data.Electric_Field_Ex
raw = variable.data
print(type(raw))
print(np.mean(raw))
&lt;/code>&lt;/pre>
&lt;p>produces the output&lt;/p>
&lt;pre>&lt;code class="language-text">&amp;lt;type 'numpy.ndarray'&amp;gt;
-1.27980874427008e-06
&lt;/code>&lt;/pre>
&lt;h3 id="plotting_using_sdf_helper">Plotting using sdf_helper&lt;/h3>
&lt;p>The sdf_helper wrapper script comes with some plotting routines. They
are incomplete currently, but aim to provide as close as possible to
press ready figures in a single command. You need the &lt;code>matplotlib&lt;/code>
library to use these routines, and they are only available for 1D and 2D
data at present. To plot data, simply provide an
&lt;code>sdf.BlockPlainVariable&lt;/code> object to the routine &lt;code>plot_auto&lt;/code>. An example
of plotting a 1D variable, using the &lt;code>two_stream.deck&lt;/code> example deck to
generate the figures would be&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
import matplotlib.pyplot as plt
plt.ion()
data=sh.getdata('Data/0010.sdf')
sh.plot_auto(data.Current_Jx)
&lt;/code>&lt;/pre>
&lt;p>This will produce a window similar to the image shown here, with slight
difference depending on your version of matplotlib and your operating
system. The code &lt;code>plt.ion()&lt;/code> sets matplotlib to interactive mode, so
control will be returned to you as soon as the plot has finished
drawing.&lt;/p>
&lt;p>
&lt;a href="/tutorial/img/Matplotlib1D_screenshot.png">Example 1D plot generated by sdf_helper.plot_auto&lt;/a>&lt;/p>
&lt;p>Plotting a 2D function is the same basic idea, and the code&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
import matplotlib.pyplot as plt
plt.ion()
data=sh.getdata('Data/0010.sdf')
sh.plot_auto(data.dist_fn_x_px_Right, iso=0)
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="/tutorial/img/Matplotlib2D.png" alt=" thumb \| 200px \| Example 2D plot generated bysdf_helper.plot_auto">&lt;/p>
&lt;p>will produce the figure on the right. The procedure for variables from
EPOCH2D data is exactly the same.&lt;/p>
&lt;h3 id="changing_colour_tables">Changing colour tables&lt;/h3>
&lt;p>The easiest solution to changing colour tables is to set the global
colour table. This is done by&lt;/p>
&lt;pre>&lt;code class="language-python">import matplotlib.pyplot as plt
plt.set_cmap(tablename)
&lt;/code>&lt;/pre>
&lt;p>where &lt;code>tablename&lt;/code> is a string describing the colour table to be used.
The available strings are given
&lt;a href="http://matplotlib.org/users/colormaps.html" target="_blank" rel="noopener">here&lt;/a>&lt;/p>
&lt;h3 id="some_bugs_in_matplotlib">Some bugs in matplotlib&lt;/h3>
&lt;p>There are some bugs in matplotlib which can mean that sometimes the 2D
images don&amp;rsquo;t render properly. If you get incorrect rendering, please
try updating matplotlib to the latest version for your platform. If that
doesn&amp;rsquo;t work then pass the parameter &lt;code>compatibility=True&lt;/code> to the
&lt;code>plot_auto&lt;/code> routine. This may make the plot slightly less pretty, but
tends to work on more platforms.&lt;/p>
&lt;h1 id="core_python_library">Core Python library&lt;/h1>
&lt;p>The SDF python reader allows you to read any SDF file and access any
information within the file. It has very few user friendly features to
assist working with the files. Some of the methods listed in the section
on sdf_helper (notably list_variables) are not available when using
the core library. Loading an sdf file with the core library has the
following syntax&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf
data=sdf.read(filename)
&lt;/code>&lt;/pre>
&lt;p>where filename is a string containing the name of the file to be loaded.
This returns an sdf.BlockList object&lt;/p>
&lt;h3 id="the_sdf" class="blocklist_object">The sdf.BlockList object&lt;/h3>
&lt;p>The &lt;code>list_variables&lt;/code> routine is added by the sdf_helper wrapper, but
you can check what elements are in the file by simply typing&lt;/p>
&lt;pre>&lt;code class="language-python">data.__dict__
&lt;/code>&lt;/pre>
&lt;p>Which will produce an output like the following example from EPOCH2D&lt;/p>
&lt;p>&lt;code>{'Header': {'filename': '/Users/phsiav/dev/epoch/epoch2d/Data/0005.sdf', 'file_version': 1, 'file_revision': 4, 'code_name': 'Epoch2d', 'step': 53, 'time': 2.5293132385759517e-14, 'jobid1': 1552896563, 'jobid2': 376, 'code_io_version': 1, 'restart_flag': False, 'other_domains': False, 'station_file': False}, 'Wall_time': &amp;lt;sdf.BlockConstant object at 0x11a012318&amp;gt;, 'Electric_Field_Ex': &amp;lt;sdf.BlockPlainVariable object at 0x11a012220&amp;gt;, 'Electric_Field_Ey': &amp;lt;sdf.BlockPlainVariable object at 0x11a012128&amp;gt;, 'Electric_Field_Ez': &amp;lt;sdf.BlockPlainVariable object at 0x11a012030&amp;gt;, 'Magnetic_Field_Bx': &amp;lt;sdf.BlockPlainVariable object at 0x117b2ceb8&amp;gt;, 'Magnetic_Field_By': &amp;lt;sdf.BlockPlainVariable object at 0x117b2cdc0&amp;gt;, 'Magnetic_Field_Bz': &amp;lt;sdf.BlockPlainVariable object at 0x117b2ccc8&amp;gt;, 'Grid_Grid': &amp;lt;sdf.BlockPlainMesh object at 0x117b2cbd0&amp;gt;, 'Grid_Grid_mid': &amp;lt;sdf.BlockPlainMesh object at 0x117b2cad8&amp;gt;, 'Grid_CPUs_Original_rank': &amp;lt;sdf.BlockPlainMesh object at 0x117b2c9e0&amp;gt;, 'Grid_CPUs_Original_rank_mid': &amp;lt;sdf.BlockPlainMesh object at 0x117b2c8e8&amp;gt;, 'CPUs_Original_rank': &amp;lt;sdf.BlockPlainVariable object at 0x117b2c7f0&amp;gt;, 'CPUs_Current_rank': &amp;lt;sdf.BlockPlainVariable object at 0x11a015128&amp;gt;}&lt;/code>&lt;/p>
&lt;h3 id="the_sdf" class="blockplainvariable_object">The sdf.BlockPlainVariable object&lt;/h3>
&lt;p>These objects represent the variables in the SDF file. It does not fully
implement the &lt;strong>dict&lt;/strong> property, so to inspect it&amp;rsquo;s contents you
must use&lt;/p>
&lt;pre>&lt;code class="language-python">dir(data.Electric_Field_Ey)
&lt;/code>&lt;/pre>
&lt;p>which produces an output like&lt;/p>
&lt;p>&lt;code>['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'blocklist', 'data', 'data_length', 'datatype', 'dims', 'grid', 'grid_id', 'grid_mid', 'id', 'mult', 'name', 'stagger', 'units']&lt;/code>&lt;/p>
&lt;p>The key elements are &lt;code>data&lt;/code> which contains the raw data for the variable
stored as a numpy array, &lt;code>dims&lt;/code> which is an array containing the number
of elements in each dimension of the array and &lt;code>grid&lt;/code> and &lt;code>grid_mid&lt;/code>
which refer to &lt;code>sdf.BlockPlainMesh &lt;code>objects that represent the
grid axes that the variable is to be plotted against. Grid and grid_mid
do similar but different things. Grid is an array of points
corresponding to the edges of the computational cells, grid_mid to the
midpoints. This means that all of the arrays in &lt;code>grid&lt;/code> are one element
longer than the arrays in &lt;code>grid_mid&lt;/code>. To identify whether to use &lt;code>grid&lt;/code>
or &lt;code>grid_mid&lt;/code> you must compare the sizes of the variable &lt;code>dims&lt;/code> array to
the sizes of the &lt;code>grid&lt;/code> and &lt;code>grid_mid&lt;/code> sizes and &lt;em>for each axis&lt;/em> use
the element of &lt;code>grid&lt;/code> or &lt;code>grid_mid&lt;/code> that has the same number of
elements.&lt;/p>
&lt;p>Important note! - 2D SDF data is loaded into Python rotated by 90
degrees compared to the original Fortran code that generated it.&lt;/p>
&lt;h3 id="the_sdf" class="blockplainmesh_object">The sdf.BlockPlainMesh object&lt;/h3>
&lt;p>Once again you have to use the &lt;code>dir&lt;/code> command to output the information
about an sdf.BlockPlainMesh object, for example in EPOCH&lt;/p>
&lt;pre>&lt;code class="language-python">dir(data.Grid_Grid)
&lt;/code>&lt;/pre>
&lt;p>Which produces output like&lt;/p>
&lt;p>&lt;code>['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'blocklist', 'data', 'data_length', 'datatype', 'dims', 'extents', 'geometry', 'id', 'labels', 'mult', 'name', 'units']&lt;/code>&lt;/p>
&lt;p>The important element of this block is &lt;code>data&lt;/code> which is a tuple of 1D
numpy arrays corresponding to each coordinate axis of the grid.&lt;/p>
&lt;h3 id="plotting_a_variable_using_raw_sdf_and_raw_matplotlib">Plotting a variable using raw SDF and raw matplotlib&lt;/h3>
&lt;ul>
&lt;li>Warning - This is not our recommended suggestion for plotting. We
recommend using our helper routines in sdf_helper*&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-python">import matplotlib.pyplot as plt
import sdf
data=sdf.read('Data/0005.sdf')
ey = data.Electric_Field_Ey
plt.pcolormesh(ey.grid_mid.data[0], ey.grid_mid.data[1], ey.data.T)
plt.show()
&lt;/code>&lt;/pre></description></item><item><title/><link>/tutorial/visualising_sdf_files_with_idl_or_gdl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/visualising_sdf_files_with_idl_or_gdl/</guid><description>&lt;h1 id="using_idl_to_visualise_data">Using IDL to visualise data&lt;/h1>
&lt;p>The EPOCH distribution comes with procedures for loading and inspecting
SDF self-describing data files. The IDL routines are held in the
&lt;code>SDF/IDL/&lt;/code> directory. There is also a procedure named
&lt;code>Start.pro&lt;/code> in each of the &lt;code>epoch\*d/&lt;/code> directories
which is used to set up the IDL environment.&lt;/p>
&lt;p>To load data into IDL, navigate to one of the base directories (eg.
&lt;code>epoch/epoch2d/&lt;/code> where &lt;code>epoch/&lt;/code> is the directory in which you have
checked out the git repository) and type the following:&lt;/p>
&lt;pre>&lt;code>$&amp;amp;gt; idl Start.pro
IDL Version 8.1 (linux x86_64 m64). (c) 2011, ITT Visual Information Solutions
Installation number: .
+Licensed for use by: STAR404570-5University of Warwick
.
% Compiled module: TRACKEX_EVENT.
% Compiled module: ISOPLOT.
% Compiled module: READVAR.
% Compiled module: LOADSDFFILE.
% Compiled module: SDFHANDLEBLOCK.
% Compiled module: SDFGETPLAINMESH.
% Compiled module: SDFGETLAGRANMESH.
% Compiled module: SDFGETPOINTMESH.
% Compiled module: SDFGETPLAINVAR.
% Compiled module: SDFGETPOINTVAR.
% Compiled module: SDFGETCONSTANT.
% Compiled module: SDFCHECKNAME.
% Compiled module: INIT_SDFHELP.
% Compiled module: GETDATA.
% Compiled module: GETSTRUCT.
% Compiled module: EXPLORE_DATA.
% Compiled module: EXPLORE_STRUCT.
% Compiled module: LIST_VARIABLES.
% Compiled module: QUICK_VIEW.
% Compiled module: GET_WKDIR.
% Compiled module: SET_WKDIR.
% Compiled module: INIT_STARTPIC.
% Compiled module: INIT_WIDGET.
% Compiled module: GENERATE_FILENAME.
% Compiled module: COUNT_FILES.
% Compiled module: LOAD_RAW.
% Compiled module: GET_SDF_METATEXT.
% Compiled module: VIEWER_EVENT_HANDLER.
% Compiled module: EXPLORER_EVENT_HANDLER.
% Compiled module: XLOADCT_CALLBACK.
% Compiled module: LOAD_DATA.
% Compiled module: DRAW_IMAGE.
% Compiled module: LOAD_META_AND_POPULATE_SDF.
% Compiled module: CLEAR_DRAW_SURFACE.
% Compiled module: SDF_EXPLORER.
% Compiled module: EXPLORER_LOAD_NEW_FILE.
% Compiled module: CREATE_SDF_VISUALIZER.
% Compiled module: VIEWER_LOAD_NEW_FILE.
% LOADCT: Loading table RED TEMPERATURE
IDL&amp;amp;gt;
&lt;/code>&lt;/pre>
&lt;p>This starts up the IDL interpreter and loads in all of the libraries for
loading and inspecting SDF files.&lt;/p>
&lt;p>We begin by inspecting SDF file contents and finding out what variables
it contains. To do this we execute the &lt;strong>list variables&lt;/strong> procedure call
which is provided by the EPOCH IDL library.&lt;/p>
&lt;p>At each timestep for which EPOCH is instructed to dump a set of
variables a new data file is created. These files take the form
&lt;em>0000.sdf&lt;/em>. For each new dump the number is incremented. The procedure
call accepts up to two arguments. The first argument is mandatory and
specifies the number of the SDF file to be read in. This argument can be
any integer from 0 to 9999. It is padded with zeros and the suffix
&amp;lsquo;.sdf&amp;rsquo; appended to the end to give the name of the data file. eg. 99 ⇒
&amp;lsquo;0099.sdf&amp;rsquo;. The next arguments is optional. The keyword &lt;strong>wkdir&lt;/strong>
specifies the directory in which the data files are located. If this
argument is omitted then the currently defined global default is used.
Initially, this takes the value &lt;strong>Data&lt;/strong> but this can be changed using
the &lt;strong>set_wkdir&lt;/strong> procedure and queried using the &lt;strong>get_wkdir()&lt;/strong>
function.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; list_variables,0,&amp;amp;quot;Data&amp;amp;quot;
Available elements are
1) EX (ELECTRIC_FIELD) : 2D Plain variable
2) EY (ELECTRIC_FIELD) : 2D Plain variable
3) EZ (ELECTRIC_FIELD) : 2D Plain variable
4) BX (MAGNETIC_FIELD) : 2D Plain variable
5) BY (MAGNETIC_FIELD) : 2D Plain variable
6) BZ (MAGNETIC_FIELD) : 2D Plain variable
7) JX (CURRENT) : 2D Plain variable
8) JY (CURRENT) : 2D Plain variable
9) JZ (CURRENT) : 2D Plain variable
10) WEIGHT_ELECTRON (PARTICLES) : 1D Point variable
11) WEIGHT_PROTON (PARTICLES) : 1D Point variable
12) PX_ELECTRON (PARTICLES) : 1D Point variable
13) PX_PROTON (PARTICLES) : 1D Point variable
14) GRID_ELECTRON (GRID) : 2D Point mesh
15) GRID_PROTON (GRID) : 2D Point mesh
16) EKBAR (DERIVED) : 2D Plain variable
17) EKBAR_ELECTRON (DERIVED) : 2D Plain variable
18) EKBAR_PROTON (DERIVED) : 2D Plain variable
19) CHARGE_DENSITY (DERIVED) : 2D Plain variable
20) NUMBER_DENSITY (DERIVED) : 2D Plain variable
21) NUMBER_DENSITY_ELECTRON (DERIVED) : 2D Plain variable
22) NUMBER_DENSITY_PROTON (DERIVED) : 2D Plain variable
23) GRID (GRID) : 2D Plain mesh
24) GRID_EN_ELECTRON (GRID) : 1D Plain mesh
25) EN_ELECTRON (DIST_FN) : 3D Plain variable
26) GRID_X_EN_ELECTRON (GRID) : 2D Plain mesh
27) X_EN_ELECTRON (DIST_FN) : 3D Plain variable
28) GRID_X_PX_ELECTRON (GRID) : 2D Plain mesh
29) X_PX_ELECTRON (DIST_FN) : 3D Plain variable
IDL&amp;amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Each variable in the SDF self-describing file format is assigned a name
and a class as well as being defined by a given variable type. The
&amp;ldquo;list_variables&amp;rdquo; procedure prints out the variable name
followed by the variable&amp;rsquo;s class in parenthesis. Following the colon is
a description of the variable type.&lt;/p>
&lt;p>To retrieve the data, you must use the &lt;strong>getdata()&lt;/strong> function call. The
function must be passed a snapshot number, either as the first argument
or as a keyword parameter &amp;ldquo;snapshot&amp;rdquo;. It also accepts the wkdir as
either the second argument or the keyword parameter &amp;ldquo;wkdir&amp;rdquo;. If it is
omitted altogether, the current global default is used. Finally, it
accepts a list of variables or class of variables to load. Since it is a
function, the result must be assigned to a variable. The object returned
is an IDL data structure containing a list of named variables.&lt;/p>
&lt;p>To load either a specific variable or a class of variables, specify the
name prefixed by a forward slash. It should be noted here that the IDL
scripting language is not case sensitive so $P_x$ can be specified as
either &amp;ldquo;/Px&amp;rdquo; or &amp;ldquo;/px&amp;rdquo;.&lt;/p>
&lt;p>We will now load and inspect the &amp;ldquo;Grid&amp;rdquo; class, this time omitting the
optional &amp;ldquo;wkdir&amp;rdquo; parameter. This time we will load from the third dump
file generated by the EPOCH run, which is found in the file &lt;em>0002.sdf&lt;/em>
since the dump files are numbered starting from zero.&lt;/p>
&lt;h1 id="inspecting_data">Inspecting Data&lt;/h1>
&lt;pre>&lt;code>IDL&amp;amp;gt; gridclass = getdata(1,/grid)
IDL&amp;amp;gt; help,gridclass,/structures
** Structure &amp;amp;lt;22806408&amp;amp;gt;, 11 tags, length=536825024, data length=536825016, refs=1:
FILENAME STRING 'Data/0001.sdf'
TIMESTEP LONG 43
TIME DOUBLE 5.0705572e-15
GRID_ELECTRON STRUCT -&amp;amp;gt; &amp;amp;lt;Anonymous&amp;amp;gt; Array[1]
GRID_PROTON STRUCT -&amp;amp;gt; &amp;amp;lt;Anonymous&amp;amp;gt; Array[1]
GRID STRUCT -&amp;amp;gt; &amp;amp;lt;Anonymous&amp;amp;gt; Array[1]
X DOUBLE Array[1024]
Y DOUBLE Array[512]
GRID_EN_ELECTRON
STRUCT -&amp;amp;gt; &amp;amp;lt;Anonymous&amp;amp;gt; Array[1]
GRID_X_EN_ELECTRON
STRUCT -&amp;amp;gt; &amp;amp;lt;Anonymous&amp;amp;gt; Array[1]
GRID_X_PX_ELECTRON
STRUCT -&amp;amp;gt; &amp;amp;lt;Anonymous&amp;amp;gt; Array[1]
IDL&amp;amp;gt; help,gridclass.grid,/structures
** Structure &amp;amp;lt;1701168&amp;amp;gt;, 5 tags, length=12376, data length=12376, refs=2:
X DOUBLE Array[1025]
Y DOUBLE Array[513]
LABELS STRING Array[2]
UNITS STRING Array[2]
NPTS LONG Array[2]
&lt;/code>&lt;/pre>
&lt;p>Here we have used IDL&amp;rsquo;s built in &amp;ldquo;help&amp;rdquo; routine and passed the
&amp;ldquo;/structures&amp;rdquo; keyword which prints information about a structure&amp;rsquo;s
contents rather than just the structure itself.&lt;/p>
&lt;p>Since &amp;ldquo;Grid&amp;rdquo; is a class name, all variables of that class have been
loaded into the returned data structure. It is a nested type so many of
the variables returned are structures themselves and those variables may
contain structures of their own.&lt;/p>
&lt;p>The &amp;ldquo;Grid&amp;rdquo; variable itself contains x&amp;quot; and &amp;ldquo;y&amp;rdquo; arrays containing the $x$
and $y$ coordinates of the 2D cartesian grid. The other variables in
&amp;ldquo;Grid&amp;rdquo; the structure are metadata used to identify the type and
properties of the variable. In order to access the &amp;ldquo;Grid&amp;rdquo; variable
contained within the &amp;ldquo;gridclass&amp;rdquo; data structure we have used the &amp;ldquo;.&amp;rdquo;
operator. In a similar way, we would access the &amp;ldquo;x&amp;rdquo; array contained
within the &amp;ldquo;Grid&amp;rdquo; variable using the identifier &amp;ldquo;gridclass.grid.x&amp;rdquo;.&lt;/p>
&lt;h1 id="getting_help_in_idl">Getting Help in IDL&lt;/h1>
&lt;p>IDL is a fairly sophisticated scripting environment with a large library
of tools for manipulating data. Fortunately, it comes with a fairly
comprehensive array of documentation. This can be accessed by typing
&lt;strong>?&lt;/strong> at the IDL prompt.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; ?
% ONLINE_HELP: Starting the online help browser.
IDL&amp;amp;gt;
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="/tutorial/img/Idl_help.png" alt="The IDL help browser">&lt;/p>
&lt;p>The documentation is divided into books aimed at users or developers and
is fully searchable and cross indexed.&lt;/p>
&lt;h1 id="manipulating_and_plotting_data">Manipulating And Plotting Data&lt;/h1>
&lt;p>Once the data has been loaded from the SDF file we will want to extract
the specific data we wish to analyse, perhaps perform some mathematical
operations on it and then plot the results.&lt;/p>
&lt;p>To do this we must learn a few basic essentials about the IDL scripting
language. Since we are all familiar with the basic concepts shared by
all computer programming languages, I will just provide a brief overview
of the essentials and leave other details to the excellent on-line
documentation.&lt;/p>
&lt;p>IDL supports multidimensional arrays similar to those found in the
FORTRAN programming language. Whole array operations are supported such
as &amp;ldquo;5*array&amp;rdquo; to multiply every element of &amp;ldquo;array&amp;rdquo; by 5. Also matrix
operations such as addition and multiplication are supported.&lt;/p>
&lt;p>The preferred method for indexing arrays is to use brackets. It is
possible to use parenthesis instead but this usage is deprecated. Column
ordering is the same as that used by FORTRAN, so to access the
$(i,j,k)$th element of an array you would use &amp;ldquo;array[i,j,k]&amp;rdquo;. IDL
arrays also support ranges so &amp;ldquo;array[5:10,3,4]&amp;rdquo; will return a one
dimensional array with five elements. &amp;ldquo;array[5:*]&amp;rdquo; specifies elements
five to $n$ of an $n$ element array. &amp;ldquo;array[*,3]&amp;rdquo; picks out the third
row of an array.&lt;/p>
&lt;p>There are also a wide range of routines for querying and transforming
arrays of data. For example, finding minimum and maximum values,
performing FFTs, etc. These details can all be found by searching the
on-line documentation.&lt;/p>
&lt;p>Finally, IDL is a full programming language so you can write your own
functions and procedures for processing the data to suit your needs.&lt;/p>
&lt;h1 id="d_plotting_in_idl">1D Plotting in IDL&lt;/h1>
&lt;p>The most commonly performed plot and perhaps the most useful data
analysis tool is the 1D plot. In IDL, this is performed by issuing the
command &lt;strong>plot,x,y&lt;/strong> where &amp;ldquo;x&amp;rdquo; and &amp;ldquo;y&amp;rdquo; are one dimensional arrays of
equal length. For each element &amp;ldquo;x[i]&amp;rdquo; plotted on the $x$-axis the
corresponding value &amp;ldquo;y[i]&amp;rdquo; is plotted along the $y$-axis. As a simple
example:&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; plot,[1,2,3],[2,2,5]
&lt;/code>&lt;/pre>
&lt;p>Gives rise to the following plot:&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Idl_simple_plot.png" alt="A simple IDL plot">&lt;/p>
&lt;p>As a more concrete example, we will now take a one-dimensional slice
through the 2D array &amp;ldquo;Number Density&amp;rdquo; read in from our SDF data file. In
this example we will give the $x$ and $y$ axes labels by passing extra
parameters to the &amp;ldquo;plot&amp;rdquo; routine. A full list of parameters can be found
in the on-line documentation. In this example we also make use of the
&amp;ldquo;$&amp;rdquo; symbol which is IDL&amp;rsquo;s line continuation character.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; data = getdata(0)
IDL&amp;amp;gt; plot,data.x,data.number_density[*,256],xtitle='x', $
IDL&amp;amp;gt; ytitle='number density'
&lt;/code>&lt;/pre>
&lt;p>This command generates the following plot:&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Idl_plot.png" alt="A slice of a 2D array">&lt;/p>
&lt;h1 id="postscript_plots">Postscript Plots&lt;/h1>
&lt;p>The plots shown so far have just been screen-shots of the interactive
IDL plotting window. These are fairly low quality and could included as
figures in a paper.&lt;/p>
&lt;p>In order to generate publication quality plots, we must output to the
postscript device. IDL maintains a graphics context which is set using
&lt;strong>set plot&lt;/strong> the command. The two most commonly used output devices are
&amp;ldquo;x&amp;rdquo; which denotes the X-server and &amp;ldquo;ps&amp;rdquo; which is the postscript device.
Once the desired device has been selected, various attributes of its
behaviour can be altered using the &lt;strong>device&lt;/strong> procedure. For example, we
can set the output file to use for the postscript plot. By default, a
file with the name &amp;ldquo;idl.ps&amp;rdquo; is used.&lt;/p>
&lt;p>Note that this file is not fully written until the postscript device is
closed using the &lt;strong>device,/close&lt;/strong> command. When we have finished our
plot we can resume plotting to screen by setting the device back to &amp;ldquo;x&amp;rdquo;.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; set_plot,'ps'
IDL&amp;amp;gt; device,filename='out.ps'
IDL&amp;amp;gt; plot,data.x,data.number_density[*,256],xtitle='x', $
IDL&amp;amp;gt; ytitle='number density',charsize=1.5
IDL&amp;amp;gt; device,/close
IDL&amp;amp;gt; set_plot,'x'
&lt;/code>&lt;/pre>
&lt;p>This set of commands results in the following plot being written to a
file named &amp;ldquo;out.ps&amp;rdquo;.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Idl_ps_plot.png" alt="A simple PS plot">&lt;/p>
&lt;p>By default, IDL draws its own set of fonts called &amp;ldquo;Hershey vector
fonts&amp;rdquo;. Much better looking results can be obtained by using a
postscript font instead. These options are passed as parameters to the
&lt;strong>device&lt;/strong> procedure. More details can be found in the on-line
documentation under &amp;ldquo;Reference Guides $\Rightarrow$ IDL Reference Guide
$\Rightarrow$ Appendices $\Rightarrow$ Fonts&amp;rdquo;.&lt;/p>
&lt;h1 id="contour_plots_in_idl">Contour Plots in IDL&lt;/h1>
&lt;p>Whilst 1D plots are excellent tools for quantitive analysis of data, we
can often get a better qualitative overview of the data using 2D or 3D
plots.&lt;/p>
&lt;p>One commonly used plot for 2D is the contour plot. The aptly named
&lt;strong>contour,z,x,y&lt;/strong> procedure takes a 2D array of data values, &amp;ldquo;z&amp;rdquo;, and
plots them against $x$ and $y$ axes which are specified in the 1D &amp;ldquo;x&amp;rdquo;
and &amp;ldquo;y&amp;rdquo; arrays. The number of contour lines to plot is specified by the
&amp;ldquo;nlevels&amp;rdquo; parameter. If the &amp;ldquo;/fill&amp;rdquo; parameter is used then IDL will fill
each contour level with a solid colour rather than just drawing a line
at the contour value.&lt;/p>
&lt;p>The example given below plots a huge number of levels so that a smooth
looking plot is produced. &amp;ldquo;xstyle=1&amp;rdquo; requests that the $x$ axes drawn
exactly matches the data in the variable rather than just using a nearby
rounded value and similarly for &amp;ldquo;ystyle=1&amp;rdquo;.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; n=100
IDL&amp;amp;gt; levels=max(data.number_density)*findgen(n)/(n-1)
IDL&amp;amp;gt; colors=253.*findgen(n)/(n-1)+1
IDL&amp;amp;gt; contour,data.number_density,data.x,data.y,xstyle=1,ystyle=1, $
IDL&amp;amp;gt; levels=levels,/fill,c_colors=colors
&lt;/code>&lt;/pre>
&lt;p>Issuing these commands gives us the contour plot shown below. Note that
the colour table used is not the default one but has been constructed to
be similar to the one used by VisIt.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Idl_contour.png" alt="A simple contour plot">&lt;/p>
&lt;h1 id="shaded_surface_plots_in_idl">Shaded Surface Plots in IDL&lt;/h1>
&lt;p>Another method for visualising 2D datasets is to produce a 3D plot in
which the data is elevated in the $z$ direction by a height proportional
to its value. IDL has two versions of the surface plot. &lt;strong>surface&lt;/strong>
produces a wireframe plot and &lt;strong>shade surf&lt;/strong> produces a filled and
shaded one. As we can see from the following example, many of IDL&amp;rsquo;s
plotting routines accept the same parameters and keywords.&lt;/p>
&lt;p>The first command shown here, &lt;strong>loadct,3&lt;/strong>, asks IDL to load the third
colour table which is&amp;quot;RED_TEMPERATURE&amp;quot;.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; loadct,3
IDL&amp;amp;gt; shade_surf,data.number_density,data.x,data.y,xstyle=1, $
IDL&amp;amp;gt; ystyle=1,xtitle='x',ytitle='y',ztitle='number density',charsize=3
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="/tutorial/img/Idl_shade_surf.png" alt="A shaded surface plot">&lt;/p>
&lt;h1 id="interactive_plotting">Interactive Plotting&lt;/h1>
&lt;p>Finally, in recent versions of IDL (not GDL) it is now possible to
perform all of these plot types in an interactive graphical user
interface. The corresponding procedures are launched with the commands
&lt;strong>iplot&lt;/strong>, &lt;strong>icontour&lt;/strong> and &lt;strong>isurface&lt;/strong>.&lt;/p>
&lt;pre>&lt;code>IDL&amp;amp;gt; iplot,data.x,data.number_density[*,256]
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="/tutorial/img/Idl_iplot.png" alt="Interactive plotting">&lt;/p>
&lt;p>IDL is an extremely useful tool but it also comes with a fairly hefty
price tag. If you are not part of an organisation that will buy it for
you then you may wish to look into a free alternative. It is also a
proprietary tool and you may not wish to work within the restrictions
that this imposes.&lt;/p>
&lt;p>There are a number of free tools available which offer similar
functionality to that of IDL, occasionally producing superior results.&lt;/p>
&lt;p>For a simple drop-in replacement, the GDL project aims to be fully
compatible and works with the existing EPOCH IDL libraries after a
couple of small changes. Other tools worth investigating are
&lt;em>&lt;code>&amp;quot;yorick&amp;quot;&lt;/code>&lt;/em> and &lt;em>&lt;code>&amp;quot;python&amp;quot;&lt;/code>&lt;/em> with the
&lt;em>&lt;code>&amp;quot;SciPy&amp;quot;&lt;/code>&lt;/em> libraries. The python SDF reader documentation
will be added soon. At present there is no SDF reader for yorick but one
may be developed if there is sufficient demand.&lt;/p></description></item><item><title/><link>/tutorial/visualising_sdf_files_with_llnl_visit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/visualising_sdf_files_with_llnl_visit/</guid><description>&lt;h1 id="using_visit_to_visualise_data">Using VisIt to visualise data&lt;/h1>
&lt;h1 id="llnl_visit">LLNL VisIt&lt;/h1>
&lt;p>LLNL&amp;rsquo;s VisIt software is a parallel data visualisation package (
&lt;a href="https://wci.llnl.gov/simulation/computer-codes/visit" target="_blank" rel="noopener">LLNL
VisIt&lt;/a>). EPOCH
comes with source code for the plug-in needed to allow VisIt to load the
SDF output files which are generated by EPOCH. There are full manuals
for VisIt which can be downloaded from the above link so no further
details will be given here. To build the plug-in, first ensure that the
visit binary is in the $PATH environment variable. Then simply type
&amp;ldquo;make visit&amp;rdquo; in one of the &lt;strong>epoch{1,2,3}d&lt;/strong> directories. For more
experienced users of VisIt, the xml file which is used to generate the
plug-in is supplied in the VisIt subdirectory, called &lt;strong>SDF2.xml&lt;/strong>.&lt;/p>
&lt;p>Whilst IDL is an excellent tool for visualising 1D and 2D datasets, it
is extremely poor when it comes to dealing with 3D data. For this
purpose, we recommend the use of the &lt;em>&lt;code>&amp;quot;VisIt&amp;quot;&lt;/code>&lt;/em>
visualisation tool.&lt;/p>
&lt;p>The other great advantage that VisIt has over IDL is the ability to
render in parallel, enabling the visualisation of huge datasets which
IDL would be incapable of dealing with.&lt;/p>
&lt;ul>
&lt;li>Initially developed by the Department of Energy (DOE) Advanced
Simulation and Computing Initiative (ASCI)&lt;/li>
&lt;li>Now developed and maintained by the Lawrence Livermore National
Laboratory along with a group of external contributors&lt;/li>
&lt;li>Written in C++ and supports python and Java interfaces&lt;/li>
&lt;li>Available for UNIX (Irix, Tru64, AIX, Linux, Solaris), Mac OS X
(10.3 - Current), and Windows platforms&lt;/li>
&lt;li>Open source and freely available under the BSD license&lt;/li>
&lt;li>Plots, operators and database readers are implemented as plugins
allowing the VisIt to be dynamically extended at run-time&lt;/li>
&lt;li>Powerful set of tools for manipulating, analysing and visualising 3D
datasets&lt;/li>
&lt;li>Parallel and distributed architecture for visualising huge data sets&lt;/li>
&lt;/ul>
&lt;h1 id="obtaining_and_installing_visit">Obtaining And Installing VisIt&lt;/h1>
&lt;p>Both the source code and pre-compiled binaries are available for
download from the projects web page which is found at the URL
&lt;a href="https://wci.llnl.gov/simulation/computer-codes/visit">https://wci.llnl.gov/simulation/computer-codes/visit&lt;/a>&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Visit_web.png" alt="The LLNL VisIT website">&lt;/p>
&lt;p>There are full instructions for compiling the project from source code
along with build scripts written to help ease the process. However, this
is not recommended as it is an extremely large tool and the compilation
takes hours to complete. It is usually far easier to download a
pre-compiled binary which matches your system architecture.&lt;/p>
&lt;p>However, occasionally compilation may be a necessary step. Linux in
particular is a moving target and it is not always possible to find a
binary which matches the particular combination of libraries installed
on your system.&lt;/p>
&lt;p>The easiest way to install the VisIt tool is to ask the system
administrator to do it for you. However, this may not always be the best
option. The system in question may be run by someone who is not
concerned with your particular software needs or has insufficient skills
to deal with the task. In any case, VisIt has a fairly rapid release
schedule and you may find that some functionality you need is not
present in the version installed on the machine.&lt;/p>
&lt;p>Fortunately, for all these scenarios it is usually quite easy to install
a copy in your own home directory. Just find a binary on the web page
&lt;a href="https://wci.llnl.gov/codes/visit/executables.html">https://wci.llnl.gov/codes/visit/executables.html&lt;/a> which
closely matches your machine and download it. This can be unpacked into
your home directory with the command
&lt;code>tar xzf visit2_10_2.linux-x86_64-ubuntu14.tar.gz&lt;/code> . The actual name
of the file will vary depending on which version you downloaded. This
will unpack the VisIt binary into a subdirectory named &lt;code>visit/&lt;/code>. Now all
that is necessary is to add this to your search path. e.g.
&lt;code>export PATH=$HOME/visit/bin:$PATH&lt;/code>&lt;/p>
&lt;p>These instructions illustrate the steps required for installing your own
copy of VisIt when you have no other choice. VisIt is an extremely large
program, so if a version is already available then it is usually better
to use the installed version.&lt;/p>
&lt;p>The CSC machines at Warwick have a recent version of VisIt installed
which is available via the system. To make use of it you must first
issue the command &lt;code>module load visit&lt;/code>.&lt;/p>
&lt;h1 id="compiling_the_reader_plugin">Compiling The Reader Plugin&lt;/h1>
&lt;p>One piece of compilation which is almost always necessary is that of the
SDF reader plugin. This is shipped as source code in a subdirectory of
the repository. It is located in the &lt;code>SDF/VisIt&lt;/code> subdirectory of the
main &lt;code>epoch&lt;/code> directory. The reader will work for any SDF file generated
by any code which uses the SDF I/O routines. You do not need a separate
reader for each version of EPOCH.&lt;/p>
&lt;p>To compile, first navigate to one of the &lt;code>epoch*d&lt;/code> directories in your
repository. Just type &amp;ldquo;make visit&amp;rdquo; and the build scripts should take
care of the rest. The SDF reader plugin will be installed into the
&lt;code>$HOME/.visit/linux-intel/plugins/databases/&lt;/code> directory on your system.
Note that the &lt;code>linux-intel&lt;/code> component will vary depending on your
machine operating system and architecture.&lt;/p>
&lt;p>Each time you install a new version of VisIt you must recompile the
reader to match the new installation. It will also occasionally be
necessary to recompile when changes occur to the SDF data format or the
reader plugin itself. The developers will notify users if this is the
case, although it does no harm to regularly recompile the reader as a
matter of course.&lt;/p>
&lt;p>We will see later that it is possible to do remote data visualisation
with VisIt in which the GUI is launched and interacted with on one
machine and the data files are located on a separate machine entirely.
In this situation the reader must be installed on the remote machine and
must match the setup there. The setup on the local machine is
unimportant. In fact it is not even necessary to have the plugin
installed on the local machine. This is particularly useful when using a
Windows environment to analyse data located on a remote UNIX
workstation.&lt;/p>
&lt;h1 id="loading_data_into_visit">Loading Data Into VisIt&lt;/h1>
&lt;p>&lt;img src="/tutorial/img/Visit_db_list.png" alt="The VisIt load databasedialog">&lt;/p>
&lt;p>The most straightforward method for loading data into VisIt is to start
the application and then browse the filesystem for the dataset you are
interested in. This is done by selecting &amp;ldquo;File ⇒ Open file&amp;rdquo; from the
VisIt menu bar. A file selection dialogue will appear allowing you to
browse directories along with the options to filter the results
according to a given regular expression and grouping options. By
default, VisIt will attempt to group all files containing the same
suffix and some kind of numbering system into a sort of virtual
database.&lt;/p>
&lt;p>The right-hand pane of this window shows a list of selected files which
will appear in the main VisIt window when you are finished.&lt;/p>
&lt;p>An alternative method of specifying the data file to open is to pass a
command line option when the tool is launched. An example of this method
is &lt;code>visit -o Data/0000.sdf&lt;/code>. When the file is specified in this manner
the list of files shown in the VisIt window will also include the full
list of files in the dataset&amp;rsquo;s subdirectory and all the files in the
current working directory. The other SDF files will be grouped together
in a virtual database.&lt;/p>
&lt;p>Yet another method for selecting the dataset to use is by opening a
previously saved session file. We will discuss this further in a later
section.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Visit_select_var.png" alt="The Visit select plot type and variabledropdown">&lt;/p>
&lt;p>Once an SDF file has been successfully loaded the &amp;ldquo;Add&amp;rdquo; menu item will
become un-greyed and the cycle numbers for each file in the virtual
database will be displayed. If we navigate to one of the plot types we
are able to select the variable to plot from a drop-down list.&lt;/p>
&lt;h1 id="contour_plots_in_visit">Contour Plots in VisIt&lt;/h1>
&lt;p>We will now replicate each of the plots which we generated using IDL in
earlier sections. For reasons which will soon become clear we begin with
the contour plot and move on to the 1D plot in the next section.&lt;/p>
&lt;p>Having opened the same dataset we were using in the IDL discussion we
now select the &amp;ldquo;Add&amp;rdquo; menu item. Notice that many of the plot types
listed here are greyed out and cannot be selected. This is because many
of the plots are dependent on the type or dimensionality of the variable
to be plotted. If our dataset contains no variables which match the
required properties for a plot, the plot menu will be disabled.&lt;/p>
&lt;p>For the current dataset there is no &amp;ldquo;Boundary&amp;rdquo; plot available since this
requires multi-material data and none of our variables meet that
criteria.&lt;/p>
&lt;p>The list contains a menu item for a &amp;ldquo;Contour&amp;rdquo; plot. We are not going to
select this item since it only generates a contour plot with lines
indicating each contour level and not a filled version. Instead we
choose &amp;ldquo;Add ⇒ Pseudocolor ⇒ Derived ⇒ Number Density&amp;rdquo; and then hit the
&amp;ldquo;Draw&amp;rdquo; button.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Visit_contour.png" alt=" VisIT contour plotoutput">&lt;/p>
&lt;p>There are many settings which can alter the visual appearance of plots
generated by VisIt. The first point of call is usually to open up the
&amp;ldquo;Plot Attributes&amp;rdquo; or &amp;ldquo;Operator Attributes&amp;rdquo; dialogue corresponding to the
plot in question. A simpler method for accomplishing this task is to
double-click on the plot in the main VisIt menu pane which will launch
the corresponding &amp;ldquo;Plot Attributes&amp;rdquo; dialogue.&lt;/p>
&lt;p>If it is the operator attributes you wish to change, click on the white
arrow on the left hand side of the plot in the main VisIt menu pane.
This will drop down to reveal a list containing the plot and all
operators acting on it. Double-clicking on an operator will launch the
corresponding &amp;ldquo;Operator Attributes&amp;rdquo; dialogue.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Visit_attrib.png" alt="image">&lt;/p>
&lt;p>Another important tool for controlling the appearance of plots can be
found in &amp;ldquo;Controls ⇒ Annotation&amp;rdquo; from the VisIt menu bar. This allows
all of the plot annotations to be modified such as the legend, title,
axis labels, etc.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Visit_annot.png" alt="The VisIT annotationsdialog">&lt;/p>
&lt;h1 id="d_plotting_in_visit">1D Plotting in VisIt&lt;/h1>
&lt;p>A 1D plot in VisIt is called a &amp;ldquo;Curve&amp;rdquo; plot. We already mentioned that
this was greyed out because we have no one dimensional variables in our
data file.&lt;/p>
&lt;p>The solution to this dilemma is the lineout operator which extracts a
one dimensional array from a 2D or 3D variable. This operator is
selected by pressing the button with red and blue lines located at the
top of the plot window.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Visit_lineout.png" alt="image">&lt;/p>
&lt;p>Once the button has been pressed, we can click and drag anywhere in the
&amp;ldquo;Pseudocolor&amp;rdquo; plot window. When we release the mouse button a new plot
window pops up containing a &amp;ldquo;Curve&amp;rdquo; plot of the data just selected.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Visit_curve.png" alt="VisIt curve plot example">&lt;/p>
&lt;p>In order to change the attributes for this plot, we must first select
Active window&amp;quot; number 2 in the main VisIt pane.&lt;/p>
&lt;h1 id="shaded_surface_plots_in_visit">Shaded Surface Plots in VisIt&lt;/h1>
&lt;p>Again, we will confusingly refuse to pick the obvious plot type for this
task. There is &amp;ldquo;Surface&amp;rdquo; plot listed in the menu. However, most of the
time the &amp;ldquo;Elevator&amp;rdquo; operator does what we want and also gives us more
flexibility.&lt;/p>
&lt;p>The first step is to do a &amp;ldquo;Pseudocolor&amp;rdquo; plot of &amp;ldquo;Number Density&amp;rdquo; as we
did before. Next select the &amp;ldquo;Operator Attributes ⇒ Transforms ⇒ Elevate&amp;rdquo;
menu item. In the pop up dialogue click on the &amp;ldquo;Elevation height
relative to XY limits?&amp;rdquo; and then &amp;ldquo;Apply&amp;rdquo;. Click &amp;ldquo;Yes&amp;rdquo; when the warning
dialogue pops up.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Visit_shade_surf.png" alt="VisIt shaded surfaceplots">&lt;/p>
&lt;p>To make this plot look similar to the one generated by IDL, we have
changed the colour table using &amp;ldquo;Controls ⇒ Color table&amp;rdquo;. We also changed
the axis appearance with the annotations menu discussed earlier and
changed the height of the elevation using the min and max operator
attributes.&lt;/p>
&lt;h1 id="creating_user_defined_expressions">Creating User-Defined Expressions&lt;/h1>
&lt;p>VisIt comes with an extremely powerful method of manipulating data
before visualising the results. The basic idea is that an array is
transformed by applying a set of mathematical functions on all its
elements and then the result is defined as a new variable. Once defined,
this variable behaves in exactly the same way as any of the variables
read from the data file.&lt;/p>
&lt;p>As an example, we can combine the three components of electric field to
generate a single electric field vector.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Visit_expression_vector.png" alt=" VisIT expression dialog showing an example vectorexpression">&lt;/p>
&lt;p>Now when we return to the &amp;ldquo;Add&amp;rdquo; menu we see that the &amp;ldquo;Vector&amp;rdquo; and
&amp;ldquo;Streamline&amp;rdquo; and plot types now have an entry for our newly defined
vector.&lt;/p>
&lt;h1 id="creating_movies">Creating Movies&lt;/h1>
&lt;p>A compelling visualisation of numerically generated data is often made
by combining a series of images into a movie. This can be an invaluable
method for illustrating the basic behaviour of a system as it changes
over time. Alternatively rotating around a 3D scene can sometimes give a
much better idea of the structure in the model being presented. There
can also be much to gain by constructing visual fly-throughs of a scene,
dynamically slicing through sets of data or combinations of all these
techniques.&lt;/p>
&lt;p>VisIt provides several facilities for generating movies from your data.
The simplest of these is to select the &amp;ldquo;File ⇒ Save movie&amp;rdquo; menu item.
This pops up a movie wizard which will walk you through the process of
generating a simple linear movie based on the time-advancing snapshots
represented by your virtual database of files. Alternatively you can
select one of the pre-defined movie templates which manipulate the
currently selected plot and create a movie from that.&lt;/p>
&lt;p>Creating a simple time advancing movie is as simple as walking through
the wizard dialogue and selecting from the self-explanatory options
presented to you.&lt;/p>
&lt;p>For many uses, the wizard will give exactly the desired results. However
it is occasionally useful to have a little more control over how the
movie is created. In such cases it can be useful to specify an image
format such as &amp;ldquo;PNG&amp;rdquo; to save to rather than &amp;ldquo;MPEG&amp;rdquo;. VisIt will then
generate one image per frame and number them consecutively. At the end
of the process the images can be converted into a movie using whatever
tool best accomplishes the task.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Visit_movie.png" alt="VisIt create moviedialog">&lt;/p>
&lt;p>Another useful tip is to select the &amp;ldquo;Later, tell me the command to run&amp;rdquo;
radio button. This will output a long command which can run from a UNIX
terminal screen. The advantage is that no X session is required so the
command can be run in the background. It also becomes a simple task to
interrupt the job at any point and resume it from where it left off at a
later date. In a similar manner it is easy to resume a job which crashes
half way through for any reason.&lt;/p>
&lt;p>More complex movies can be created by using VisIt&amp;rsquo;s keyframing facility
which allows you to change animation attributes such as view or plot
attributes as the animation progresses. Further information about this
somewhat complex task can be found in the on-line help.&lt;/p>
&lt;p>Finally, you can use VisIt&amp;rsquo;s python scripting interface to
programmatically describe the details of each frame as the movie
progresses. This approach offers far more flexibility in what can be
achieved but is also much more involved and time consuming than the
previous two methods. Again, further information on this subject can be
found in the on-line help system.&lt;/p>
&lt;h1 id="remote_visualisation">Remote Visualisation&lt;/h1>
&lt;p>It was mentioned earlier that it is possible to perform remote
visualisation using VisIt. This is a process in which the data files
being interrogated reside on a different machine to the one on which the
VisIt GUI runs and where the results are plotted.&lt;/p>
&lt;p>This method of working can be extremely useful when the data is
generated on a powerful machine located in an external environment such
as a large cluster. Another common use is when EPOCH is executed on a
UNIX machine and the desktop used for visualisation is running Windows.&lt;/p>
&lt;p>It is sometimes possible to run a graphical tool on the remote machine
and tunnel the X-server session through to the local machine but this
can be quite slow and unstable. When connecting to a remote VisIt
instance the only data which needs to be sent between machines is the
pre-rendered image and a few simple plotting commands. Naturally, this
can be a &lt;em>&lt;code>much&lt;/code>&lt;/em> faster approach.&lt;/p>
&lt;p>Also, as mentioned before, it is possible to use a machine on which the
reader plugin is difficult or impossible to compile for and connect to a
machine on which the reader is already installed.&lt;/p>
&lt;p>In order to use the remote visualisation facility, you must first set up
a &amp;ldquo;Host profile&amp;rdquo; for the remote machine using the &amp;ldquo;Options ⇒ Host
profiles&amp;rdquo; menu item. The pre-compiled binaries are shipped with a long
list of pre-defined host profiles. These are unnecessary for anyone not
affiliated and can safely be removed by deleting the directory
&lt;code>$HOME/visit/current/.visit&lt;/code> (assuming you have unpacked the VisIt
tarball into your home directory).&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Visit_host_profile.png" alt="VisIT remote host configurationdialog">&lt;/p>
&lt;p>Create a new profile by clicking on the &amp;ldquo;New Host&amp;rdquo; button and filling
out some of the form fields. The important ones to change are &amp;ldquo;Host
nickname&amp;rdquo;, &amp;ldquo;Remote host name&amp;rdquo;, &amp;ldquo;Host name aliases&amp;rdquo; and &amp;ldquo;Username&amp;rdquo;. If
the visit binary is not in your default search path on the remote
machine then you must specify its location by filling in the &amp;ldquo;Path to
VisIt installation&amp;rdquo; field.&lt;/p>
&lt;p>Now click &amp;ldquo;Apply&amp;rdquo; and &amp;ldquo;Dismiss&amp;rdquo; followed by the &amp;ldquo;Options ⇒ Save
Settings&amp;rdquo; menu item to ensure that the profile is saved for future
sessions.&lt;/p>
&lt;p>Data on the remote machine can now be loaded by selecting and picking
the desired host profile from the drop down list of &amp;ldquo;Hosts&amp;rdquo;. VisIt will
wait for the remote process to launch and then continue with the file
selection procedure but now displaying files located on the remote
machine rather than the local one. From this point on everything should
work as before except you should see the name of the remote machine in
the &amp;ldquo;Selected files&amp;rdquo; dialogue.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Visit_host_files.png" alt=" VisIT load file dialog showing files on remotehost">&lt;/p>
&lt;h1 id="parallel_visualisation">Parallel Visualisation&lt;/h1>
&lt;p>Parallel visualisation is performed in almost exactly the same manner as
remote visualisation. Again, you must create a host profile for the
purpose except this time you need to set up a parallel launch profile in
the &amp;ldquo;Launch Profiles&amp;rdquo; tab pane. Click the &amp;ldquo;New Profile&amp;rdquo; button, give the
profile a name and then set the required options in the &amp;ldquo;Parallel&amp;rdquo; tab
on the bottom section of the page. Selecting the &amp;ldquo;Launch parallel
engine&amp;rdquo; radio button will allow you to set the various launch options
which relate to the cluster on which the job will run.&lt;/p>
&lt;p>The major difference now is due to the fact that VisIt must be launched
by an external job script which fits in with the queueing system used by
the parallel machine. Usually you will need to consult with the system
administrator of the cluster to confirm which launch method and
arguments to use.&lt;/p>
&lt;p>The details of job launch can be better understood by reading through
the &amp;ldquo;User documentation&amp;rdquo; section provided at
&lt;a href="http://www.visitusers.org" target="_blank" rel="noopener">1&lt;/a> . Of particular help here is the &amp;ldquo;Getting
VisIt to run in parallel&amp;rdquo; section and the &amp;ldquo;How VisIt Launching works&amp;rdquo;
entry in the &amp;ldquo;Developer documentation&amp;rdquo; section.&lt;/p></description></item><item><title/><link>/tutorial/sidebar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/sidebar/</guid><description>&lt;ul>
&lt;li>navigation
&lt;ul>
&lt;li>&lt;a href="https://cfsa-pmw.warwick.ac.uk/EPOCH/epoch">https://cfsa-pmw.warwick.ac.uk/EPOCH/epoch&lt;/a> | Back to GitLab!&lt;/li>
&lt;li>:Landing_Page| Back to Landing Page&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title/><link>/tutorial/structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/structure/</guid><description>&lt;p>When obtained, the EPOCH codes all have a similar structure. If the
tarred and gzipped archive (commonly referred to as a tarball) is
downloaded and unpacked into the user&amp;rsquo;s &lt;code>$HOME&lt;/code> directory, then the
extracted contents will consist of a directory named
&amp;ldquo;&lt;code>$HOME/epoch-4.12.0&lt;/code>&amp;rdquo; (with &amp;ldquo;4.12.0&amp;rdquo; substituted by the current version
number) and the subdirectories and files listed below.&lt;/p>
&lt;p>Alternatively, if the code is checked out from the GitLab git repository
with the command&lt;br>
&lt;code>git clone --recursive &lt;/code>
&lt;a href="https://cfsa-pmw.warwick.ac.uk/EPOCH/epoch.git" target="_blank" rel="noopener">&lt;code>https://cfsa-pmw.warwick.ac.uk/EPOCH/epoch.git&lt;/code>&lt;/a>&lt;br>
then the directory will be &amp;ldquo;&lt;code>$HOME/epoch&lt;/code>&amp;rdquo;.&lt;/p>
&lt;p>Once the code has been obtained, the top-level directory will contain
the following 4 directories and several files&lt;/p>
&lt;ul>
&lt;li>epoch1d - Source code and other files required for the 1D version of
EPOCH.&lt;/li>
&lt;li>epoch2d - Source code and other files required for the 2D version of
EPOCH.&lt;/li>
&lt;li>epoch3d - Source code and other files required for the 3D version of
EPOCH.&lt;/li>
&lt;li>SDF - Source code for the SDF file format which is used to generate
output for EPOCH runs. This directory also includes various tools
and readers for working with SDF files.&lt;/li>
&lt;li>CHANGELOG - A brief overview of the change history for each released
version of EPOCH.&lt;/li>
&lt;li>CODING_STYLE - This document contains the conventions which must be
used for any code being submitted for inclusion in the EPOCH
project.&lt;/li>
&lt;li>LICENSE - A copy of the GPLv3 license which is used by the EPOCH
project.&lt;/li>
&lt;li>README.md - A brief overview of obtaining and using the EPOCH code.&lt;/li>
&lt;li>make_tarball.sh - This is a shell script which is used for creating
the tarred and gzipped archives of EPOCH which are posted to the
Warwick GitLab server each time a new release is made.&lt;/li>
&lt;li>test_all.sh - A regression test script used when testing the code.&lt;/li>
&lt;/ul>
&lt;p>The three EPOCH subdirectories all have a similar structure. Inside each
of the epoch{1,2,3}d directories, there are 3 sub-directories:&lt;/p>
&lt;ul>
&lt;li>src - The EPOCH source code.&lt;/li>
&lt;li>example_decks - A sample data directory containing example input
deck files.&lt;/li>
&lt;li>Data - This is an empty directory to use for running simulations.&lt;/li>
&lt;/ul>
&lt;p>there are also 3 files:&lt;/p>
&lt;ul>
&lt;li>Makefile - A standard makefile.&lt;/li>
&lt;li>Start.pro - An IDL script which starts the IDL visualisation
routines. Execute it using &amp;ldquo;idl Start&amp;rdquo;.&lt;/li>
&lt;li>unpack_source_from_restart - Restart dumps can be written to
contain a copy of the input decks and source code used to generate
them. This script can be used to unpack that information from a
given restart dump. It is run from the command line and must be
passed the name of the restart dump file.&lt;/li>
&lt;/ul>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/libraries">Libraries and requirements&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/using_delta_f/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/using_delta_f/</guid><description>&lt;p>To help reduce the impact of numerical noise in certain simulations, the
delta-f method may be used in for specified particle species. The
delta-f method effectively subtracts a background distribution $f_0$
when calculating currents due to the motion of markers; when the
particle distribution function $f$ is close to $f_0$, this substantially
reduces the statistical noise in the currents. Only current deposition
is implemented differently, and the equations of motion of the markers
are not modified in this delta-f approach.&lt;/p>
&lt;p>The component of the currents associated with the background $f_0$ may
be in principle be calculated analytically, but the delta-f
implementation in EPOCH assumes (but does not check) that the total
background current is zero.&lt;/p>
&lt;p>In order to use the delta-f method EPOCH must be compiled with the
#DELTAF_METHOD precompiler flag enabled. Standard input simulations
are not affected by switching on this flag, but the user may then choose
to treat certain species in the plasma using the delta-f method. To
enable delta-f calculation for a species the background distribution
function $f_0$ must be defined in the input block. $f_0$ is specified
using variables similar to those used to specify $f$. The current
implementation of delta-f allows only a spatially uniform drifting
Maxwellian $f_0$, with temperatures $T_x$, $T_y$ and $T_z$ allowed to
differ from each other. In 3D, for the case where the temperature in
each direction is equal, we have
$f_0 = n_0 (2 \pi T)^{-3/2} \exp\left(\frac{m (\mathbf{v} - \mathbf{v_d})^2}{2 k_B T } \right).$&lt;/p>
&lt;p>The parameters number_density_back, temp(x,y,z)_back and
drift(x,y,z)_back in each species specification in the input deck set
$f_0$. number_density_back=0 is the default and is equivalent to not
using the delta-f method.&lt;/p>
&lt;p>For example, the electron species component of an input deck solved
using delta-f might be written:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = electron
charge = -1.0
mass = 1.0
frac = 0.3
temp = 1e8
temp_back = 1e8
number_density = 1e20
number_density_back = 1e20
end:species
&lt;/code>&lt;/pre>
&lt;p>Additional distribution function diagnostic options are supplied for the
Delta-f version. Standard diagnostics work as usual based on the total
distribution function $f$ but is is also possible to output the Delta-f
component of the distribution functions by adding output_deltaf = T in
dist_fn components of the input deck.&lt;/p>
&lt;p>An example input deck is supplied in the 1D version as
twostream_deltaf.deck. This uses the delta-f method to solve the
weak-beam two stream instability. The bulk plasma species is solved
using the delta-f method, since this evolve very little, and mostly
supports the Lagnmuir waves that the weak beam interacts with. The
relative change to the beam species is large, and the standard PIC
method, rather than delta-f is used to model this species. A comparison
of the electric field diagnostics between standard and delta-f
simulations shows a substantial decrease in noise.&lt;/p>
&lt;p>Further details of the method are provided
&lt;a href="Media:talk_deltaf.pdf" title="wikilink"> in this
pdf&lt;/a>.&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/basic_examples">Basic examples with EPOCH&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/using_epoch_in_practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/using_epoch_in_practice/</guid><description>&lt;h1 id="specifying_initial_conditions_for_particles_using_the_input_deck">Specifying initial conditions for particles using the input deck&lt;/h1>
&lt;p>If the initial conditions for the plasma you wish to model can be
described by a number density and temperature profile on the underlying
grid then EPOCH can create an appropriate particle distribution for you.
The set of routines which accomplish this task are known as the
autoloader. For many users, this functionality is sufficient to make use
of the code and there is no need to deal with the internal
representation of particles in EPOCH.&lt;/p>
&lt;p>The autoloader randomly loads particles in space to reproduce the number
density profile that was requested. It then sets the momentum components
of the particles to approximate a Maxwell-Boltzmann distribution
corresponding to the temperature profile. Sometimes this is not the
desired behaviour, for example you may wish to model a bump-on-tail
velocity distribution. It is currently not possible to specify these
initial conditions from the input deck and the particles must be setup
by modifying the source code.&lt;/p>
&lt;p>There are two stages to the particle setup in EPOCH&lt;/p>
&lt;ul>
&lt;li>auto_load - This routine is called after reading and parsing the
input deck. It takes care of allocating particles and setting up
their initial positions and momenta using the initial conditions
supplied in deck file. It is not necessary to recompile the code, or
even have access to the source to change the initial conditions
using this method.&lt;/li>
&lt;li>manual_load - Once particles have been allocated they can have
their properties altered in this routine. By default it is an empty
routine which does nothing.&lt;/li>
&lt;/ul>
&lt;h3 id="setting_autoloader_properties_from_the_input_deck">Setting autoloader properties from the input deck&lt;/h3>
&lt;p>To illustrate using the autoloader in practice, we present an example
for setting up an isolated plasma block in 2D. This would look like:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = s1
# First set number_density in the range 0 &amp;gt; 1
# Cut down number_density in x direction
number_density = if ((x gt -1) and (x lt 1), 1.0, 0.2)
# Cut down number_density in y direction
number_density = if ((y gt -1) and (y lt 1), number_density(s1), 0.2)
# Multiply number_density by real particle number_density
number_density = number_density(s1) * 100.0
# Set the temperature to be zero
temp_x = 0.0
temp_y = temp_x(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * 100.0
end:species
begin:species
# Just copy the number_density for species s1
number_density = number_density(s1)
# Just copy the temperature from species s1
temp_x = temp_x(s1)
temp_y = temp_y(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * 100.0
end:species
&lt;/code>&lt;/pre>
&lt;p>An important point to notice is that the two parts of the logical
expressions in the input deck are enclosed within their own brackets.
This helps to remove some ambiguities in the functioning of the input
deck parser. It is hoped that this will soon be fixed, but at present
ALWAYS enclose logical expressions in brackets.&lt;/p>
&lt;h1 id="manually_overriding_particle_parameters_set_by_the_autoloader">Manually overriding particle parameters set by the autoloader&lt;/h1>
&lt;p>Since not all problems in plasma physics can be described in terms of an
initial distribution of thermal plasma, it is also possible to manually
control properties of each individual pseudoparticle for an initial
condition. This takes place in the subroutine &lt;code>manual_load&lt;/code> in the file
user_interaction/ic_module.f90. Manual loading takes place after all
the autoloader phase, to allow manual tweaking of autoloader specified
initial conditions.&lt;/p>
&lt;h3 id="epoch_internal_representation_of_particles">EPOCH internal representation of particles&lt;/h3>
&lt;p>Before we can go about manipulating particle properties in
&lt;code>manual_load&lt;/code>, we first need an overview of how the particles are
defined in EPOCH. Inside the code, particles are represented by a
Fortran90 TYPE called &lt;strong>&lt;code>particle&lt;/code>&lt;/strong>. The current definition of this
type (in 1D) is:&lt;/p>
&lt;pre>&lt;code class="language-fortran"> TYPE particle
REAL(num), DIMENSION(3) :: part_p
REAL(num) :: part_pos
#if !defined(PER_SPECIES_WEIGHT) || defined(PHOTONS)
REAL(num) :: weight
#endif
#ifdef DELTAF_METHOD
REAL(num) :: pvol
#endif
#ifdef PER_PARTICLE_CHARGE_MASS
REAL(num) :: charge
REAL(num) :: mass
#endif
TYPE(particle), POINTER :: next, prev
#ifdef PARTICLE_DEBUG
INTEGER :: processor
INTEGER :: processor_at_t0
#endif
#ifdef PARTICLE_ID4
INTEGER :: id
#elif PARTICLE_ID
INTEGER(i8) :: id
#endif
#ifdef COLLISIONS_TEST
INTEGER :: coll_count
#endif
#ifdef WORK_DONE_INTEGRATED
REAL(num) :: work_x
REAL(num) :: work_y
REAL(num) :: work_z
REAL(num) :: work_x_total
REAL(num) :: work_y_total
REAL(num) :: work_z_total
#endif
#ifdef PHOTONS
REAL(num) :: optical_depth
REAL(num) :: particle_energy
#ifdef TRIDENT_PHOTONS
REAL(num) :: optical_depth_tri
#endif
#endif
END TYPE particle
&lt;/code>&lt;/pre>
&lt;p>Here, most of the preprocessing directives have been stripped out for
clarity. We have left &lt;code>#ifdef PARTICLE_DEBUG&lt;/code> as an example. Here, the
&amp;ldquo;processor&amp;rdquo; and &amp;ldquo;processor_at_t0&amp;rdquo; variables only exist if the
&lt;code>-DPARTICLE_DEBUG&lt;/code> define was put in the makefile. If you want to access
a property that does not seem to be present, check the
&lt;a href="/tutorial/compiler_flags">preprocessor
defines&lt;/a>.&lt;/p>
&lt;p>The &amp;ldquo;particle&amp;rdquo; properties can be explained as follows:&lt;/p>
&lt;ul>
&lt;li>part_p - The momentum in 3 dimensions for the particle. This is
always of size 3.&lt;/li>
&lt;li>part_pos - The position of the particle in space. This is of the
same size as the dimensionality of the code.&lt;/li>
&lt;li>weight - The weight of this particle. The number of real particles
represented by this pseudoparticle.&lt;/li>
&lt;li>charge - The particle charge. If the code was compiled without per
particle charge, then the code uses the charge property from
TYPE(particle_species).&lt;/li>
&lt;li>mass - The particle rest mass. If the code was compiled without per
particle mass, then the code uses the mass property from
TYPE(particle_species).&lt;/li>
&lt;li>next, prev - The next and previous particle in the linked list which
represents the particles in the current species. This will be
explained in more detail later.&lt;/li>
&lt;li>processor - The rank of the processor which currently holds the
particle.&lt;/li>
&lt;li>processor_at_t0 - The rank of the processor on which the particle
started.&lt;/li>
&lt;li>id - Unique particle ID.&lt;/li>
&lt;li>coll_count - Used for debugging the collision routines.&lt;/li>
&lt;li>optical_depth - Optical depth used in the QED routines.&lt;/li>
&lt;li>particle_energy - Particle energy used in the QED routines.&lt;/li>
&lt;li>optical_depth_tri - Optical depth for the trident process in the
QED routines.&lt;/li>
&lt;/ul>
&lt;p>Collections of particles are represented by another Fortran TYPE, called
&lt;strong>&lt;code>particle_list&lt;/code>&lt;/strong>. This type represents all the properties of a
collection of particles and is used behind the scenes to deal with
inter-processor communication of particles. The definition of the type
is:&lt;/p>
&lt;pre>&lt;code class="language-fortran"> TYPE particle_list
TYPE(particle), POINTER :: head
TYPE(particle), POINTER :: tail
INTEGER(i8) :: count
INTEGER :: id_update
! Pointer is safe if the particles in it are all unambiguously linked
LOGICAL :: safe
! Does this partlist hold copies of particles rather than originals
LOGICAL :: holds_copies
TYPE(particle_list), POINTER :: next, prev
END TYPE particle_list
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>head - The first particle in the linked list.&lt;/li>
&lt;li>tail - The last particle in the linked list.&lt;/li>
&lt;li>count - The number of particles in the list. Note that this is NOT
MPI aware, so reading count only gives you the number of particles
on the local processor.&lt;/li>
&lt;li>safe - Any particle_list which a user should come across will be a
safe particle_list. Don&amp;rsquo;t change this property.&lt;/li>
&lt;li>next, prev - For future expansion it is possible to attach
particle_lists together in another linked list. This is not
currently used anywhere in the code.&lt;/li>
&lt;/ul>
&lt;p>An entire species of particles is represented by another Fortran TYPE,
this time called &lt;strong>&lt;code>particle_species&lt;/code>&lt;/strong>. This represents all the
properties which are common to all particles in a species. The current
definition is:&lt;/p>
&lt;pre>&lt;code class="language-fortran"> TYPE particle_species
! Core properties
CHARACTER(string_length) :: name
TYPE(particle_species), POINTER :: next, prev
INTEGER :: id
INTEGER :: dumpmask
INTEGER :: count_update_step
REAL(num) :: charge
REAL(num) :: mass
REAL(num) :: weight
INTEGER(i8) :: count
TYPE(particle_list) :: attached_list
LOGICAL :: immobile
LOGICAL :: fill_ghosts
! Parameters for relativistic and arbitrary particle loader
INTEGER :: ic_df_type
REAL(num) :: fractional_tail_cutoff
TYPE(primitive_stack) :: dist_fn
TYPE(primitive_stack) :: dist_fn_range(3)
#ifndef NO_TRACER_PARTICLES
LOGICAL :: zero_current
#endif
! ID code which identifies if a species is of a special type
INTEGER :: species_type
! particle cell division
INTEGER(i8) :: global_count
LOGICAL :: split
INTEGER(i8) :: npart_max
! Secondary list
TYPE(particle_list), DIMENSION(:), POINTER :: secondary_list
! Injection of particles
REAL(num) :: npart_per_cell
TYPE(primitive_stack) :: density_function, temperature_function(3)
TYPE(primitive_stack) :: drift_function(3)
! Thermal boundaries
REAL(num), DIMENSION(:), POINTER :: ext_temp_x_min, ext_temp_x_max
! Species_ionisation
LOGICAL :: electron
LOGICAL :: ionise
INTEGER :: ionise_to_species
INTEGER :: release_species
INTEGER :: n
INTEGER :: l
REAL(num) :: ionisation_energy
! Attached probes for this species
#ifndef NO_PARTICLE_PROBES
TYPE(particle_probe), POINTER :: attached_probes
#endif
! Particle migration
TYPE(particle_species_migration) :: migrate
! Initial conditions
TYPE(initial_condition_block) :: initial_conditions
! Per-species boundary conditions
INTEGER, DIMENSION(2*c_ndims) :: bc_particle
END TYPE particle_species
&lt;/code>&lt;/pre>
&lt;p>This definition is for the 1D version of the code. The only difference
for the other two versions is the number of dimensions in the arrays
&amp;ldquo;secondary_list&amp;rdquo; and &amp;ldquo;ext_temp_*&amp;rdquo;. There are quite a lot of
fields here, so we will just document some of the most important ones.&lt;/p>
&lt;ul>
&lt;li>name - The name of the particle species, used in the output dumps
etc.&lt;/li>
&lt;li>next, prev - Particle species are also linked together in a linked
list. This is used internally by the output dump routines, but
should not be used by end users.&lt;/li>
&lt;li>id - The species number for this species. This is the same number as
is used in the input deck to designate the species.&lt;/li>
&lt;li>dumpmask - Determine when to include this species in output dumps.
Note that the flag is ignored for restart dumps.&lt;/li>
&lt;li>charge - The charge in Coulombs. Even if PER_PARTICLE_CHARGE_MASS
is specified, this is still populated from the input deck, and now
refers to the reference charge for the species.&lt;/li>
&lt;li>mass - The mass in kg.&lt;/li>
&lt;li>weight - The per-species particle weight.&lt;/li>
&lt;li>count - The global number of particles of this species (NOTE may not
be accurate). This will only ever be the number of particles on this
processor when running on a single processor. While this property
will be accurate when setting up initial conditions, it is only
guaranteed to be accurate for the rest of the code if the code is
compiled with the correct preprocessor options.&lt;/li>
&lt;li>attached_list - The list of particles which belong to this species.&lt;/li>
&lt;li>immobile - If set to &lt;code>.TRUE.&lt;/code> then the species is ignored during the
particle push.&lt;/li>
&lt;li>zero_current - If set to &lt;code>.TRUE.&lt;/code> then the current is not updated
for this particle species.&lt;/li>
&lt;/ul>
&lt;h3 id="setting_the_particle_properties">Setting the particle properties&lt;/h3>
&lt;p>The details of exactly what a linked list means in EPOCH requires a more
in-depth study of the source code. For now, all we really need to know
is that each species has a list of particles. A pointer to the first
particle in the list is contained in
&lt;code>species_list(ispecies)%attached_list%head&lt;/code>. Once you have a pointer to
a particle (eg. current), you advance to the next pointer in the list
with &lt;code>current =&amp;gt; current%next&lt;/code>. After all the descriptions of the types,
actually setting the properties of the particles is fairly simple. The
following is an example which positions the particles uniformly in 1D
space, but doesn&amp;rsquo;t set any momentum.&lt;/p>
&lt;pre>&lt;code class="language-fortran"> SUBROUTINE manual_load
TYPE(particle), POINTER :: current
INTEGER :: ispecies
REAL(num) :: rpos, dx
DO ispecies = 1, n_species
current =&amp;gt; species_list(ispecies)%attached_list%head
dx = length_x / species_list(ispecies)%attached_list%count
rpos = x_min
DO WHILE(ASSOCIATED(current))
current%part_pos = rpos
current%weight = 1.0_num
rpos = rpos + dx
current =&amp;gt; current%next
ENDDO
ENDDO
END SUBROUTINE manual_load
&lt;/code>&lt;/pre>
&lt;p>This will take the particles which have been placed at random positions
by the autoloader and repositions them in a uniform manner. In order to
adjust the particle positions, you need to know about the grid used in
EPOCH. In this example we only required the length of the domain,
&amp;ldquo;length_x&amp;rdquo; and the minimum value of x, &amp;ldquo;x_min&amp;rdquo;. A more exhaustive list
is given in the following section. Note that I completely ignored the
question of domain decomposition when setting up the particles. The code
automatically moves the particles onto the correct processor without
user interaction.&lt;/p>
&lt;p>In the above example, note that particle momentum was not specified and
particle weight was set to be a simple constant. Setting particle weight
can be very simple if you can get the pseudoparticle distribution to
match the real particle distribution, or quite tricky if this isn&amp;rsquo;t
possible. The weight of a pseudoparticle is calculated such that the
number of pseudoparticles in a cell multiplied by their weights equals
the number of physical particles in that cell. This can be quite tricky
to get right, so in more complicated cases it is probably better to use
the autoloader than to manually set up the number density distribution.&lt;/p>
&lt;h3 id="grid_coordinates_used_in_epoch" class="">Grid coordinates used in EPOCH.&lt;/h3>
&lt;p>When setting up initial conditions within the EPOCH source (rather than
using the input deck) there are several constants that you may need to
use. These constants are:&lt;/p>
&lt;ul>
&lt;li>nx - Number of gridpoints on the local processor in the x direction.&lt;/li>
&lt;li>ny - Number of gridpoints on the local processor in the y direction
(2D and 3D).&lt;/li>
&lt;li>nz - Number of gridpoints on the local processor in the z direction
(3D).&lt;/li>
&lt;li>length_{x,y,z} - Length of domain in the x, y, z directions.&lt;/li>
&lt;li>{x,y,z}_min - Minimum value of x, y, z for the whole domain.&lt;/li>
&lt;li>{x,y,z}_max - Maximum value of x, y, z for the whole domain.&lt;/li>
&lt;li>n_species - The number of species in the code.&lt;/li>
&lt;/ul>
&lt;p>There are also up to three arrays which are available for use.&lt;/p>
&lt;ul>
&lt;li>x(-2:nx+3) - Position of a given gridpoint in real units in the x
direction.&lt;/li>
&lt;li>y(-2:ny+3) - Position of a given gridpoint in real units in the y
direction (2D and 3D).&lt;/li>
&lt;li>z(-2:nz+3) - Position of a given gridpoint in read units in the z
direction (3D).&lt;/li>
&lt;/ul>
&lt;h3 id="loading_a_separable_non_thermal_particle_distribution" class="">Loading a separable non-thermal particle distribution.&lt;/h3>
&lt;p>While the autoloader is capable of dealing with most required initial
thermal distributions, you may want to set up non-thermal initial
conditions. The code includes a helper function to select a point from
an arbitrary distribution function which can be used to deal with most
non-thermal distributions. To use the helper function, you need to
define two 1D arrays which are the x and y axes for the distribution
function. This approach is only possible if the distribution function
can be represented as a set of 1D distribution functions in px, py and
pz separately. If this is possible then this method is preferred since
it is significantly faster than the arbitrary method detailed in the
next section. An example of using the helper function is given below.&lt;/p>
&lt;pre>&lt;code class="language-fortran"> SUBROUTINE manual_load
TYPE(particle), POINTER :: current
INTEGER, PARAMETER :: np_local = 1000
INTEGER :: ispecies, ip
REAL(num) :: temperature, stdev2, tail_width, tail_height, tail_drift
REAL(num) :: frac, tail_frac, min_p, max_p, dp_local, p2, tail_p2
REAL(num), DIMENSION(np_local) :: p_axis, distfn_axis
temperature = 1e4_num
tail_width = 0.05_num
tail_height = 0.2_num
tail_drift = 0.5_num
DO ispecies = 1, n_species
stdev2 = kb * temperature * species_list(ispecies)%mass
frac = 1.0_num / (2.0_num * stdev2)
tail_frac = 1.0_num / (2.0_num * stdev2 * tail_width)
max_p = 5.0_num * SQRT(stdev2)
min_p = -max_p
dp_local = (max_p - min_p) / REAL(np_local-1, num)
DO ip = 1, np_local
p_axis(ip) = min_p + (ip - 1) * dp_local
p2 = p_axis(ip)**2
tail_p2 = (p_axis(ip) - tail_drift * max_p)**2
distfn_axis(ip) = EXP(-p2 * frac) &amp;amp;amp;
+ tail_height * EXP(-tail_p2 * tail_frac)
ENDDO
current=&amp;gt;species_list(ispecies)%attached_list%head
DO WHILE(ASSOCIATED(current))
current%part_p(1) = sample_dist_function(p_axis, distfn_axis)
current=&amp;gt;current%next
ENDDO
ENDDO
END SUBROUTINE manual_load
&lt;/code>&lt;/pre>
&lt;p>This example will set the particles to have a bump-on-tail velocity
distribution, a setup which is not possible to do using only the input
deck. It is not necessary to normalise the distribution function, as
this is done automatically by the
&lt;em>&lt;code>*sample_dist_function*&lt;/code>&lt;/em> function.&lt;/p>
&lt;h3 id="loading_an_arbitrary_non_thermal_particle_distribution" class="">Loading an arbitrary non-thermal particle distribution.&lt;/h3>
&lt;p>An example of sampling an arbitrary distribution function is given
&lt;a href="/tutorial/non-thermal_initial_conditions">here&lt;/a>&lt;/p>
&lt;h1 id="lasers">Lasers&lt;/h1>
&lt;p>EPOCH has the ability to add EM wave sources such as lasers at
boundaries. To use lasers, set the boundary that you wish to have a
laser on to be of type &lt;code>simple_laser&lt;/code> and then specify one or more
lasers attached to that boundary. Lasers may be specified anywhere
initial conditions are specified.&lt;/p>
&lt;h1 id="laser_blocks_in_multiple_dimensions" class="">Laser blocks in multiple dimensions.&lt;/h1>
&lt;p>When running EPOCH in 2D or 3D, the laser can be modified spatially via
the &lt;code>profile&lt;/code> and &lt;code>phase&lt;/code> parameters. These are briefly outlined
&lt;a href="/tutorial/input_deck_laser">here&lt;/a> but in this section we will
describe them in a little more depth.\&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>profile&lt;/code> - The spatial profile for the laser. This is
essentially an array defined along the edge (or surface) that the laser
is attached to. It is clear that the spatial profile is only meaningful
perpendicular to the laser&amp;rsquo;s direction of travel and so it is just a
single constant in 1D. The laser profile is evaluated as an initial
condition and so cannot include any temporal information which must be
encoded in &lt;code>t_profile&lt;/code>. The spatial profile is evaluated at the boundary
where the laser is attached and so only spatial information in the plane
of the boundary is significant. This is most clearly explained through a
couple of examples. In these examples the spatial profile of the laser
is set to vary between a flat uniform profile (&lt;code>profile = 1&lt;/code>) and a
Gaussian profile in y (&lt;code>profile = gauss(y,0,2.5e-6)&lt;/code>). The difference
between these profiles is obvious but the important point is that a
laser travelling parallel to the x-direction has a profile in the y
direction. Similarly a laser propagating in the y-direction has a
profile in the x direction. In 3D this is extended so that a laser
propagating in a specified direction has a profile in both orthogonal
directions. So a laser travelling parallel to the x axis in 3D would
have a profile in y and z. Since 3D lasers are very similar to 2D
lasers, they will not be considered here in greater detail, but in 3D,
it is possible to freely specify the laser profile across the entire
face where a laser is attached.&lt;br>
&lt;img src="/tutorial/img/Profile_flat.png" alt="Uniform laser profile inEPOCH2D">
&lt;img src="/tutorial/img/Profile_gauss.png" alt="Gaussian laser profile inEPOCH2D">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>phase&lt;/code> - Phase shift for the laser in radians. This is a
spatial variable which is also defined across the whole of the
boundary on which the laser is attached. This allows a user to add a
laser travelling at an angle to a boundary as shown in
Figure [angle]. The setup for this is not entirely straightforward
and requires a little bit of explanation. Figure [wave]
illustrates a laser being driven at an angle on the x_min boundary.
Different wave fronts cross the $y$-axis at different places and
this forms a sinusoidal profile along $y$ that represents the phase.
The wavelength of this profile is given by
$\lambda_\phi = \lambda / \sin\theta$, where $\lambda$ is the
wavelength of the laser and $\theta$ is the angle of the propagation
direction with respect to the $x$-axis. The actual phase to use will
be $\phi(y) = -k_\phi y = -2\pi y / \lambda_\phi$. It is negative
because the phase of the wave is propagating in the positive $y$
direction. It is also necessary to alter the wavelength of the
driver since this is given in the direction perpendicular to the
boundary. The new wavelength to use will be $\lambda\cos\theta$.
Figure [angle] shows the resulting $E_y$ field for a laser driven
at an angle of $\pi / 8$. Note that since the boundary conditions in
the code are derived for propagation perpendicular to the boundary,
there will be artefacts on the scale of the grid for lasers driven
at an angle.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="/tutorial/img/Profile_angle.png" alt="Laser propagating at an angle inEPOCH2D">
&lt;img src="/tutorial/img/Wave_angle.png" alt="Schematic diagram of a laser propagating at an angle in2D">&lt;/p>
&lt;p>Using this technique it is also possible to focus a laser. This is done
by using the same technique as above but making the angle of
propagation, $\theta$, a function of $y$ such that the laser is focused
to a point along the $x$-axis. A simple example is given
&lt;a href="/tutorial/basic_examples/#focussing_a_gaussian_beam">here&lt;/a>.&lt;/p>
&lt;h1 id="restarting_epoch_from_previous_output_dumps">Restarting EPOCH from previous output dumps&lt;/h1>
&lt;p>Another possible way of setting up initial conditions in EPOCH is to
load in a previous output dump and use it to specify initial conditions
for the code. The effect of this is to restart the code from the state
that it was in when the dump was made. To do this, you just set the
field &amp;ldquo;restart_snapshot&amp;rdquo; in the
&lt;a href="/tutorial/input_deck_control"> control
block&lt;/a> to the number of the output
dump from which you want the code to restart. Because of the way in
which the code is written you cannot guarantee that the code will
successfully restart from any output dump. To restart properly, the
following &lt;em>&lt;code>must&lt;/code>&lt;/em> have been dumped&lt;/p>
&lt;ul>
&lt;li>Particle positions.&lt;/li>
&lt;li>Particle momenta.&lt;/li>
&lt;li>Particle species.&lt;/li>
&lt;li>Particle weights.&lt;/li>
&lt;li>Relevant parts of the electric field (If for example it is known
that ez == 0 then it is not needed).&lt;/li>
&lt;li>Relevant parts of the magnetic field.&lt;/li>
&lt;/ul>
&lt;p>It is possible to use the manual particle control part of the initial
conditions to make changes to a restarted initial condition after the
restart dump is loaded. The output files don&amp;rsquo;t include all of the
information needed to restart the code fully since some of this
information is contained in the input deck. However, a restart dump also
contains a full copy of the input deck used and this can be unpacked
before running the code.&lt;br>
If specific &amp;ldquo;restart&amp;rdquo; dumps are specified in the input deck, or the
&amp;ldquo;force_final_to_be_restartable&amp;rdquo; flag is set then in some cases the
output is forced to contain enough information to output all the data.
These restart dumps can be very large, and also override the &amp;ldquo;dumpmask&amp;rdquo;
parameter specified for a species and output the data for that species
anyway.&lt;/p>
&lt;h1 id="parameterising_input_decks">Parameterising input decks&lt;/h1>
&lt;p>The simplest way to allow someone to use EPOCH as a black box is to give
them the input.deck files that control the setup and initial conditions
of the code. The input deck is simple enough that a quick read through
of the relevant section of the manual should make it fairly easy for a
new user to control those features of the code, but the initial
conditions can be complex enough to be require significant work on the
part of an unfamiliar user to understand. In this case, it can be
helpful to use the ability to specify constants in an input deck to
parameterise the file. So, to go back to a slight variation on an
earlier example:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = s1
# First set number_density in the range 0-&amp;amp;gt;1
# Cut down number_density in x direction
number_density = if ((x gt -1) and (x lt 1), 1.0, 0.2)
# Cut down number_density in y direction
number_density = if ((y gt -1) and (y lt 1), number_density(s1), 0.2)
# Multiply number_density by real particle number density
number_density = number_density(s1) * 100.0
# Set the temperature to be zero
temp_x = 0.0
temp_y = temp_x(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * 100.0
end:species
begin:species
name = s2
# Just copy the number_density for species s1
number_density = number_density(s1)
# Just copy the temperature from species s1
temp_x = temp_x(s1)
temp_y = temp_y(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * 100.0
end:species
&lt;/code>&lt;/pre>
&lt;p>The particle number density (100.0) is hard coded into the deck file in
several places. It would be easier if this was given to a new user as:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
particle_number_density = 100.0 # Particle number density
end:constant
begin:species
name = s1
# First set number_density in the range 0-&amp;amp;gt;1
# Cut down number_density in x direction
number_density = if ((x gt -1) and (x lt 1), 1.0, 0.2)
# Cut down number_density in y direction
number_density = if ((y gt -1) and (y lt 1), number_density(s1), 0.2)
# Multiply number_density by real particle number density
number_density = number_density(s1) * particle_number_density
# Set the temperature to be zero
temp_x = 0.0
temp_y = temp_x(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * particle_number_density
end:species
begin:species
name = s2
# Just copy the number density for species s1
number_density = number_density(s1)
# Just copy the temperature from species s1
temp_x = temp_x(s1)
temp_y = temp_y(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * particle_number_density
end:species
&lt;/code>&lt;/pre>
&lt;p>It is also possible to parameterise other elements of initial conditions
in a similar fashion. This is generally a good idea, since it makes the
initial conditions easier to read an maintain.&lt;/p>
&lt;h1 id="using_spatially_varying_functions_to_further_parameterise_initial_conditions">Using spatially varying functions to further parameterise initial conditions&lt;/h1>
&lt;p>Again, this is just a readability change to the normal input.deck file,
but it also makes changing and understanding the initial conditions
rather simpler. In this case, entire parts of the initial conditions are
moved into a spatially varying constant in order to make changing them
at a later date easier. For example:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
particle_number_density = 100.0 # Particle number density
profile_x = if((x gt -1) and (x lt 1), 1.0, 0.2)
profile_y = if((y gt -1) and (y lt 1), 1.0, 0.2)
end:constant
begin:species
name = s1
# Multiply number_density by real particle number density
number_density = particle_number_density * profile_x * profile_y
# Set the temperature to be zero
temp_x = 0.0
temp_y = temp_x(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * particle_number_density
end:species
begin:species
name = s2
# Just copy the number_density for species s1
number_density = number_density(s1)
# Just copy the temperature from species s1
temp_x = temp_x(s1)
temp_y = temp_y(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * particle_number_density
end:species
&lt;/code>&lt;/pre>
&lt;p>This creates the same output as before. It is now trivial to modify the
profiles later. For example:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:constant
particle_number_density = 100.0 # Particle number density
profile_x = gauss(x, 0.0, 1.0)
profile_y = gauss(y, 0.0, 1.0)
end:constant
begin:species
name = s1
# Multiply number_density by real particle number density
number_density = particle_number_density * profile_x * profile_y
# Set the temperature to be zero
temp_x = 0.0
temp_y = temp_x(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * particle_number_density
end:species
begin:species
name = s2
# Just copy the number density for species s1
number_density = number_density(s1)
# Just copy the temperature from species s1
temp_x = temp_x(s1)
temp_y = temp_y(s1)
# Set the minimum number_density for this species
number_density_min = 0.3 * particle_number_density
end:species
&lt;/code>&lt;/pre>
&lt;p>This changes the code to run with a Gaussian density profile rather then
a step function. Again, this can be extended as far as required.&lt;/p>
&lt;h1 id="next_section">Next section&lt;/h1>
&lt;p>
&lt;a href="/tutorial/using_delta_f">EPOCH in delta-f form&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/workshop_examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/workshop_examples/</guid><description>&lt;h1 id="epoch_workshop_overview">EPOCH workshop overview&lt;/h1>
&lt;p>The aims of the Workshop are:&lt;br>
*After the workshop you should be able to setup and run EPOCH on a
problem of real importance to your research.&lt;/p>
&lt;ul>
&lt;li>You should also be in a position to use and understand the manual.&lt;/li>
&lt;li>You should learn about PIC codes in general.&lt;/li>
&lt;li>You should understand more about the pitfalls of trying to do LPI
studies with PIC.&lt;/li>
&lt;li>Advice on how to run EPOCH and setup software on your home
computers.&lt;/li>
&lt;li>Give advice to the EPOCH team on new features for the code.&lt;/li>
&lt;/ul>
&lt;p>&lt;br>
Warwick EPOCH Personnel:&lt;br>
*Tony Arber &amp;ndash; PI on EPOCH project at Warwick.&lt;/p>
&lt;ul>
&lt;li>Keith Bennett &amp;ndash; PDRA and senior EPOCH developer.&lt;/li>
&lt;li>Chris Brady &amp;ndash; Original EPOCH developer and head of RSE at Warwick&lt;/li>
&lt;li>Heather Ratcliffe - EPOCH user and developer&lt;/li>
&lt;li>Tom Goffrey &amp;ndash; PDRA and developer on other non-EPOCH codes&lt;/li>
&lt;li>Alexander Seaton - Final year PhD student with extensive experience
of using EPOCH&lt;/li>
&lt;/ul>
&lt;p>&lt;br>
Resources:&lt;br>
*All machines, and exercises, are linux based.&lt;/p>
&lt;ul>
&lt;li>EPOCH is a Fortran90 program which uses MPI for parallelization.&lt;/li>
&lt;li>You will always need both F90 and MPI to compile and run the code
even on one processor.&lt;/li>
&lt;li>MPI on a Windows computer is not easy. Use linux or a Mac.&lt;/li>
&lt;/ul>
&lt;h1 id="workstation_usage">Workstation usage&lt;/h1>
&lt;p>You can use the workstations for simple 1D tests and looking at the
code.\&lt;/p>
&lt;h3 id="ultra_simple_getting_epoch_guide">Ultra-simple getting EPOCH guide!&lt;/h3>
&lt;p>These instructions should work in your host institute if you have git.&lt;/p>
&lt;ol>
&lt;li>First, ensure that you have registered for an EPOCH account on
Warwick&amp;rsquo;s Gitlab server (see
&lt;a href="#registering_on_gitlab">below&lt;/a>)&lt;/li>
&lt;li>Login to workstation using guest account.&lt;/li>
&lt;li>Open a terminal.&lt;/li>
&lt;li>Type the following command at the prompt:&lt;br>
&lt;code>git clone --recursive &lt;/code>
&lt;a href="https://cfsa-pmw.warwick.ac.uk/EPOCH/epoch.git" target="_blank" rel="noopener">&lt;code>https://cfsa-pmw.warwick.ac.uk/EPOCH/epoch.git&lt;/code>&lt;/a>&lt;/li>
&lt;li>When prompted, type in your GitLab username and password.&lt;/li>
&lt;/ol>
&lt;p>You will now have a directory called &amp;lsquo;epoch&amp;rsquo;. Inside this directory will
be three EPOCH sub-directories epoch1d, epoch2d and epoch3d, an SDF
directory and a few other files. Change directory into the epoch1d
directory and start working through the
&lt;a href="#getting_started_with_epoch">&amp;lsquo;Getting Started with
EPOCH&amp;rsquo;&lt;/a> guide.&lt;/p>
&lt;h3 id="registering_on_gitlab">Registering on GitLab&lt;/h3>
&lt;p>The EPOCH git repository is hosted on Warwick&amp;rsquo;s GitLab server. This is a
site which hosts git repositories and facilitates collaborative
development in a similar way to GitHub. In addition to the repository
there is an issue tracker where bugs, feature requests and support
queries can be posted.&lt;/p>
&lt;p>To obtain an account, navigate to
&lt;a href="https://cfsa-pmw.warwick.ac.uk" target="_blank" rel="noopener">&lt;a href="https://cfsa-pmw.warwick.ac.uk">https://cfsa-pmw.warwick.ac.uk&lt;/a>&lt;/a> and
fill in the online form. You will now be sent a confirmation email with
a link for confirming the account. When you log in to the site, you will
see a section with the title &amp;ldquo;Join the EPOCH project&amp;rdquo; and a button
labeled &amp;ldquo;EPOCH group&amp;rdquo;. If you click this, you will be taken to the EPOCH
group page where there is a &amp;ldquo;Request Access&amp;rdquo; button. This sends the
maintainers a request to join the EPOCH group where you can access the
code and participate in the user forums. Note that this approval stage
is done manually, so please be patient but approval usually occurs
within a day or two.&lt;/p>
&lt;h3 id="running_the_codes">Running the codes&lt;/h3>
&lt;p>Single core job: &lt;code>&amp;gt; echo Data | mpiexec -n 1 bin/epoch1d&lt;/code> Four core
parallel job: &lt;code>&amp;gt; echo Data | mpiexec -n 4 bin/epoch2d&lt;/code>&lt;/p>
&lt;p>&lt;strong>Note:&lt;/strong> If you don&amp;rsquo;t have git on your home computer you can always
download a tar file of epoch when you return to your lab. This you get
from the &amp;lsquo;Wiki&amp;rsquo; section on the EPOCH GitLab webpage. However I recommend
you get, and learn, git and join the 21st century.&lt;/p>
&lt;h1 id="getting_started_with_epoch">Getting Started with EPOCH&lt;/h1>
&lt;h3 id="compiling_the_code">Compiling the code&lt;/h3>
&lt;p>The first thing you must do is to compile the code. This is done using
the UNIX &amp;ldquo;make&amp;rdquo; command. This command reads a file called &lt;em>Makefile&lt;/em> and
uses the instructions in this file to generate all the steps required
for compiling the code. Most of this is done automatically and the only
part which typically needs changing are the instructions for which
compiler to use and what compiler flags it accepts. The Makefiles
supplied as part of the EPOCH source code contain sections for most
commonly used compilers so it is usually unnecessary to actually edit
these files. Usually you can compile just by passing the name of the
compiler on the command line.&lt;/p>
&lt;p>To compile the 1D version of the code, first change to the correct
directory by typing &lt;code>cd epoch/epoch1d&lt;/code>. The compiler used on most
desktop machines is &lt;code>gfortran&lt;/code>, so you can compile the code by typing
&lt;code>make COMPILER=gfortran&lt;/code>. Alternatively, if you type
&lt;code>make COMPILER=gfortran -j4&lt;/code> then the code will be compiled in parallel
using 4 processors. If you wish, you can save yourself a bit of typing
by editing your ~/.bashrc file and adding the line
&lt;code>export COMPILER=gfortran&lt;/code> at the top of the file. Then the command
would just be &lt;code>make -j4&lt;/code>.&lt;/p>
&lt;p>The most commonly used compiler on clusters these days is the Intel
FORTRAN compiler. You can compile by typing &lt;code>make COMPILER=intel&lt;/code> or
edit your ~/.bashrc file to add the line &lt;code>export COMPILER=intel&lt;/code> at the
top.&lt;/p>
&lt;p>You should rarely need to edit the Makefile more than this.
Occasionally, you may need to change fundamental behavior of the code by
changing the list of flags in the &amp;ldquo;DEFINES&amp;rdquo; entry. This is documented in
the User manual.&lt;/p>
&lt;h3 id="running_the_code">Running the code&lt;/h3>
&lt;p>Once you have built the version of EPOCH that you want (1D, 2D or 3D)
you simply run it by typing &lt;code>./bin/epoch1d&lt;/code>, &lt;code>./bin/epoch2d&lt;/code>, or
&lt;code>./bin/epoch3d&lt;/code>. That will then show you the EPOCH splash page, which
prints the logo, lists any compile time options that you specified and
then asks you to specify the output directory. It will look in this
directory for a file with the name &amp;ldquo;input.deck&amp;rdquo; containing the problem
setup. Any output performed by the code will also be written into this
directory. To work through the examples, you must download an input deck
from the section below to the directory you want EPOCH to use and rename
the file &amp;ldquo;input.deck&amp;rdquo;. Throughout this guide we will assume that you use
the directory named &amp;ldquo;Data&amp;rdquo;.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/EPOCH_Splash.png" alt="The EPOCH1D splash page">&lt;/p>
&lt;h3 id="getting_the_example_decks_for_this_workshop">Getting the example decks for this workshop&lt;/h3>
&lt;p>The example input decks used in this workshop can be downloaded using
the following links. Create a directory &amp;ldquo;~/EXAMPLES&amp;rdquo; to put them in:&lt;/p>
&lt;pre>&lt;code>cd .
mkdir EXAMPLES
&lt;/code>&lt;/pre>
&lt;p>then download the .zip to this folder (either click the link and then
copy the file, or right-click and select the save-as option).&lt;br>
&lt;a href="media:Workshop_EXAMPLES.zip" title="wikilink">All decks as a .zip&lt;/a>&lt;/p>
&lt;p>
&lt;a href="media:01-1d_laser.deck" title="wikilink">01-1d_laser.deck - A simple laser&lt;/a>&lt;br>
&lt;a href="media:02-2d_laser_amended.deck" title="wikilink">02-2d_laser.deck - A simple 2d
laser&lt;/a>&lt;br>
&lt;a href="media:03-1d_two_stream.deck" title="wikilink">03-1d_two_stream.deck - A simple two-stream
instability&lt;/a>&lt;br>
&lt;a href="media:04-1d_two_stream_io.deck" title="wikilink">04-1d_two_stream_io.deck - The same two-stream instability with
extended output &lt;/a>&lt;br>
&lt;a href="media:05-2d_moving_window.deck" title="wikilink">05-2d_moving_window.deck - Simple moving-window problem with density
jump and laser &lt;/a>&lt;br>
&lt;a href="media:06-2d_ramp.deck" title="wikilink">06-2d_ramp.deck - Gaussian laser into a density ramp
&lt;/a>&lt;br>
&lt;a href="media:07-1d_heating.deck" title="wikilink">07-1d_heating.deck - Demonstration of numerical heating
&lt;/a>&lt;/p>
&lt;h1 id="a_basic_em_field_simulation">A Basic EM-Field Simulation&lt;/h1>
&lt;p>Our first example problem will be a simple 1D domain with a laser. This
should give you a simple introduction to the input deck and
visualization of 1D datasets.&lt;/p>
&lt;p>Begin by copying the &amp;ldquo;01-1d_laser.deck&amp;rdquo; file from the EXAMPLES
directory into the &amp;ldquo;Data&amp;rdquo; directory using the command: cp
~/EXAMPLES/01-1d_laser.deck Data/input.deck&lt;/p>
&lt;div class="mw-collapsible mw-collapsed" style="border-style: solid; border-width: 2px; border-color:#0059A1">
&lt;p>Or click &amp;ldquo;Expand&amp;rdquo; and copy this text into a file &amp;ldquo;input.deck&amp;rdquo; in
your Data directory:&lt;/p>
&lt;div class="mw-collapsible-content">
&lt;pre>&lt;code class="language-perl">begin:control
nx = 200
# Size of domain
x_min = -4 * micron
x_max = -x_min
# Final time of simulation
t_end = 50 * femto
#stdout_frequency = 10
end:control
begin:boundaries
bc_x_min = open
#bc_x_min = simple_laser
bc_x_max = open
end:boundaries
#begin:laser
# boundary = x_min
# intensity_w_cm2 = 1.0e15
# lambda = 1 * micron
# phase = pi / 2
# t_profile = gauss(time, 2*micron/c, 1*micron/c)
# t_end = 4 * micron / c
#end:laser
#
#
#begin:output
# dt_snapshot = 1 * micron / c
#
# # Properties on grid
# grid = always
# ey = always
#end:output
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;p>Open the input deck with an editor to view its contents. Eg. &amp;ldquo;gedit
Data/input.deck&amp;rdquo;&lt;/p>
&lt;p>This is the simplest possible input deck. The file is divided into
blocks which are surrounded by &amp;ldquo;begin:blocktype&amp;rdquo; and &amp;ldquo;end:blocktype&amp;rdquo;
lines. There are currently ten different blocktypes. The most basic
input deck requires only two.&lt;/p>
&lt;p>The first block is the &amp;ldquo;control&amp;rdquo; block. This is used for specifying the
domain size and resolution and the length of time to run the simulation.
There are also some global simulation parameters that can be specified
in this block which will be introduced later. Within the block, each
parameter is specified as a &amp;ldquo;name = value&amp;rdquo; pair.&lt;/p>
&lt;p>The parameters are as follows. &amp;ldquo;nx&amp;rdquo; specifies the number of grid points
in the x-direction (since this is a 1D code, the grid is only defined in
the x-direction). &amp;ldquo;x_min&amp;rdquo; and &amp;ldquo;x_max&amp;rdquo; give the minimum and maximum
grid locations measured in meters. Since most plasma simulations are
measured in microns, there is a &amp;ldquo;micron&amp;rdquo; multiplication factor for
convenience. There are also multiplication factors for &amp;ldquo;milli&amp;rdquo; through
to &amp;ldquo;atto&amp;rdquo;. Finally, the simulation time is specified using &amp;ldquo;t_end&amp;rdquo;
measured in seconds.&lt;/p>
&lt;p>There are also commented lines in the deck. Any text following the &amp;ldquo;#&amp;rdquo;
character is ignored. The character may appear anywhere on a line, so in
the following example: t_end = 50 #* femto The value of &amp;ldquo;t_end&amp;rdquo; will
be set to 50 seconds, since &amp;ldquo;#* femto&amp;rdquo; is ignored.&lt;/p>
&lt;p>The other required block is the &amp;ldquo;boundaries&amp;rdquo; block. This contains one
entry for each boundary, specifying what boundary condition to apply.
For the 1D code there are two boundaries: &amp;ldquo;bc_x_min&amp;rdquo; and &amp;ldquo;bc_x_max&amp;rdquo;.
The deck currently has both of these set to use open boundary
conditions.&lt;/p>
&lt;p>To run the code type: &lt;code>echo Data | mpiexec -n 4 ./bin/epoch1d&lt;/code>&lt;/p>
&lt;p>This will run epoch1d in parallel using 4 processors. It will use the
directory named &amp;ldquo;Data&amp;rdquo; for all its output and will read the file
&amp;ldquo;Data/input.deck&amp;rdquo; to obtain the simulation setup.&lt;/p>
&lt;p>This simulation is rather dull. It is just a grid with zero
electromagnetic field and it generates no data files. After running the
program, two files are generated in the &amp;ldquo;Data&amp;rdquo; directory. The
&amp;ldquo;deck.status&amp;rdquo; file contains the results from the deck parsing routines
and is only useful for debugging. The &amp;ldquo;epoch1d.dat&amp;rdquo; file contains a
terse one line header with the code name, version information and time
the job started followed by a list of output dumps generated during the
run.&lt;/p>
&lt;p>Status information about the running job can be requested by
uncommenting the &amp;ldquo;stdout_frequency&amp;rdquo; line in the &amp;ldquo;control&amp;rdquo; block. This
is achieved by using a text editor to remove the &amp;ldquo;#&amp;rdquo; character and
saving the file.&lt;/p>
&lt;h1 id="adding_a_laser">Adding a laser&lt;/h1>
&lt;p>We will now edit this input deck to add a laser source to the left hand
boundary and dump some output files.&lt;/p>
&lt;ol>
&lt;li>Open the &amp;ldquo;Data/input.deck&amp;rdquo; file with an editor.&lt;/li>
&lt;li>Add a &amp;ldquo;#&amp;rdquo; comment character to the beginning of the first
&amp;ldquo;bc_x_min&amp;rdquo; line in the &amp;ldquo;boundaries&amp;rdquo; block.&lt;/li>
&lt;li>Uncomment the line &amp;ldquo;bc_x_min = simple_laser&amp;rdquo;&lt;/li>
&lt;li>Uncomment the remaining lines in the file.&lt;/li>
&lt;/ol>
&lt;p>The change to the &amp;ldquo;boundaries&amp;rdquo; block instructs the code to add a laser
source to the left-hand boundary.&lt;/p>
&lt;h3 id="the_laser_block">The Laser Block&lt;/h3>
&lt;p>We then require a new block, named &amp;ldquo;laser&amp;rdquo;, to set up the laser source.
The parameters in this block do the following:&lt;/p>
&lt;ul>
&lt;li>boundary &amp;ndash; Specifies the boundary on which to attach this laser
source&lt;/li>
&lt;li>intensity_w_cm2 &amp;ndash; Specifies the intensity of the laser in Watts /
cm^2&lt;/li>
&lt;li>lambda &amp;ndash; Gives the wavelength of the laser in meters. We have used
the multiplication factor &amp;ldquo;micron&amp;rdquo; for readability&lt;/li>
&lt;li>phase &amp;ndash; Specifies the phase shift of the laser.&lt;/li>
&lt;li>t_profile &amp;ndash; This parameter is used to modify the amplitude of the
laser over time. It is usually used to ramp a laser up or down
gradually. The left-hand side will be a function of time, usually
ranging between zero and one.&lt;/li>
&lt;li>t_end &amp;ndash; The time at which to switch off the laser.&lt;/li>
&lt;/ul>
&lt;p>These parameters are mostly self-explanatory. The &amp;ldquo;t_profile&amp;rdquo; parameter
is best explained using an example. The figure above shows the result of
using a gaussian time profile. The red line shows the value of
&amp;ldquo;t_profile&amp;rdquo; over time. This starts at a value close to zero, ramps up
to one and then ramps back down to zero. The green line shows the
amplitude of the laser when &amp;ldquo;t_profile&amp;rdquo; has not been specified. Note
that the function would normally be a sine wave, but this has been
shifted by pi/2 because the &amp;ldquo;phase&amp;rdquo; parameter was used. The blue line
shows the laser amplitude generated when the &amp;ldquo;t_profile&amp;rdquo; gaussian
profile is applied.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/WorkshopLaser.png" alt="The laser profile">&lt;/p>
&lt;h3 id="the_output_block">The Output Block&lt;/h3>
&lt;p>The final addition is the &amp;ldquo;output&amp;rdquo; block. We will cover this in more
detail later. For now, it is sufficient to know that this is the block
which controls the generation of data output. The parameters used in
this case are:&lt;/p>
&lt;ul>
&lt;li>dt_snapshot &amp;ndash; This specifies the simulation time between each
output dump&lt;/li>
&lt;li>grid &amp;ndash; This controls when to dump the simulation grid. The value of
&amp;ldquo;always&amp;rdquo; means that the grid will be output whenever there is a new
output dump generated.&lt;/li>
&lt;li>ey &amp;ndash; The controls when to dump the y-component of the electric
field.&lt;/li>
&lt;/ul>
&lt;h1 id="visualising_the_data">Visualising the data&lt;/h1>
&lt;p>Now that we have generated some data we need to plot it. The data is
written to a self-describing file format called SDF. This has been
developed for use by several codes maintained at the University of
Warwick. There are routines for reading the data from within IDL, VisIt,
MatLab and Python.&lt;/p>
&lt;p>More complete documentation on visualisation routines is available
&lt;a href="/tutorial/sdf_landing_page">here&lt;/a>&lt;/p>
&lt;h3 id="loading_the_data_into_idlgdl">Loading the data into IDL/GDL&lt;/h3>
&lt;p>First, we will load the data into IDL/GDL. The desktop machines have GDL
installed &amp;ndash; the GNU Data Language, which is a free implementation of
IDL. It doesn&amp;rsquo;t have all the feature of IDL but the core routines and
syntax are identical. Type &lt;code>gdl Start.pro&lt;/code> and GDL will start up and
load the SDF reading library. To view the data contained in a file, type
&lt;code>list_variables,7,'Data'&lt;/code> Here, &amp;ldquo;7&amp;rdquo; is the snapshot number. It can be
any number between 0 and 9999. The second parameter specifies the
directory which holds the data files. If it is omitted then the
directory named &amp;ldquo;Data&amp;rdquo; is used by default.&lt;/p>
&lt;p>To load the data and assign the result to a structure named &amp;ldquo;data&amp;rdquo;, just
issue the following command: &lt;code>data = getstruct(7,/varname)&lt;/code> Here,
&amp;ldquo;/varname&amp;rdquo; is any of the variables listed by the previous command. This
will just read the &amp;ldquo;varname&amp;rdquo; variable into the data structure. However,
it is usually easiest just to omit the &amp;ldquo;/varname&amp;rdquo; flag. If it is omitted
then the entire contents of the file is read.&lt;/p>
&lt;p>The &amp;ldquo;getstruct&amp;rdquo; command returns a hierarchical data structure. The
contents of this structure can be viewed with the following command:
&lt;code>help,data,/struct&lt;/code>   For the current example the result of this command
is the following:&lt;/p>
&lt;pre>&lt;code> GDL&amp;gt; help,data,/struct
** Structure &amp;lt;Anonymous&amp;gt;, 8 tags, data length=5552:
FILENAME STRING 'Data/0007.sdf'
TIMESTEP LONG 185
TIME DOUBLE 2.3449556e-14
HEADER STRUCT -&amp;gt; &amp;lt;Anonymous&amp;gt; Array[1]
ELAPSED_TIME STRUCT -&amp;gt; &amp;lt;Anonymous&amp;gt; Array[1]
EY STRUCT -&amp;gt; &amp;lt;Anonymous&amp;gt; Array[1]
GRID STRUCT -&amp;gt; &amp;lt;Anonymous&amp;gt; Array[1]
X DOUBLE Array[200]
&lt;/code>&lt;/pre>
&lt;p>The first few entries are fairly self-explanatory. The seventh item is a
1D array containing the cell-centred grid positions. The fiftth item is
a structure containing a 1D array of Ey at these positions. This
structure can be queried in the same way as &amp;ldquo;data&amp;rdquo; :&lt;/p>
&lt;pre>&lt;code> GDL&amp;gt; help,data.ey,/struct
** Structure &amp;lt;Anonymous&amp;gt;, 2 tags, data length=1728:
METADATA STRUCT -&amp;gt; &amp;lt;Anonymous&amp;gt; Array[1]
DATA DOUBLE Array[200]
&lt;/code>&lt;/pre>
&lt;p>The raw data is contained in the &amp;ldquo;data&amp;rdquo; entry. The sixth entry, &amp;ldquo;GRID&amp;rdquo;
is a structure which contains :&lt;/p>
&lt;pre>&lt;code>GDL&amp;gt; help,data.grid,/struct
** Structure &amp;lt;Anonymous&amp;gt;, 5 tags, data length=1824:
METADATA STRUCT -&amp;gt; &amp;lt;Anonymous&amp;gt; Array[1]
X DOUBLE Array[201]
LABELS STRING Array[1]
UNITS STRING Array[1]
NPTS LONG Array[1]
&lt;/code>&lt;/pre>
&lt;p>This is the node-centred grid along with its metadata. The cell-centred
array shown previously is derived from this. Finally, the HEADER entry
contains metadata about the code and runtime information.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/WorkshopLaserGDL.png" alt="An example GDLplot">&lt;/p>
&lt;p>The above plot can be generated by issuing the following command:
&lt;code>plot,data.x,data.ey.data&lt;/code> There are more examples on using idl/gdl in
the
&lt;a href="/tutorial/landing_page">manual&lt;/a>.&lt;/p>
&lt;h3 id="loading_the_data_into_python">Loading the data into Python&lt;/h3>
&lt;p>EPOCH also ships with a module for reading SDF data into python. To
build this module, change directory to epoch/epoch1d (or 2d,3d) and type
&amp;ldquo;make sdfutils&amp;rdquo;. This will build the python reader and install it
locally. It also installs a helper module which adds a few user-friendly
routines. To simplify discussion, we will just focus on using this
helper routine.&lt;/p>
&lt;p>Open a python interpreter by typing &amp;ldquo;python&amp;rdquo;, or preferably &amp;ldquo;ipython&amp;rdquo; if
you have it installed.&lt;/p>
&lt;p>On the desktops, the sdf and sdf_helper modules will be imported for
you, as sdf and sdf_helper respectively. On other machines, to load the
SDF module, type the command:&lt;/p>
&lt;pre>&lt;code class="language-python">import sdf_helper as sh
&lt;/code>&lt;/pre>
&lt;p>You can now load a data file by typing:&lt;/p>
&lt;pre>&lt;code class="language-python">data = sh.getdata(7)
&lt;/code>&lt;/pre>
&lt;p>or&lt;/p>
&lt;pre>&lt;code class="language-python">data = sdf_helper.getdata(7)
&lt;/code>&lt;/pre>
&lt;p>This returns a data structure which can be inspected using&lt;/p>
&lt;pre>&lt;code class="language-python"> data.__dict__
&lt;/code>&lt;/pre>
&lt;p>. It also imports the contents of data arrays and prints a summary of
what has been imported.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;pre>&lt;code class="language-python">from sdf_helper import *
data = getdata(7)
#&amp;gt;&amp;gt;Reading file Data/0007.sdf
t() = time
ey(200,) = ey
x(201,) = grid
xc(200,) = grid_mid
&lt;/code>&lt;/pre>
&lt;p>If you have matplotlib installed then you can load the module using&lt;/p>
&lt;pre>&lt;code class="language-python"> from matplotlib.pyplot import *
&lt;/code>&lt;/pre>
&lt;p>. Turn on interactive plotting with&lt;/p>
&lt;pre>&lt;code class="language-python">ion()
&lt;/code>&lt;/pre>
&lt;p>. You can now plot the data with the command:&lt;/p>
&lt;pre>&lt;code class="language-python">plot(xc,ey)
&lt;/code>&lt;/pre>
&lt;p>The helper module has a &amp;ldquo;plot_auto&amp;rdquo; command which automatically adds
axis labels. To use this type:&lt;/p>
&lt;pre>&lt;code class="language-python">plot_auto(data.Electric_Field_Ey)
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="/tutorial/img/WorkshopLaserPython.png" alt="An example Pythonplot">&lt;/p>
&lt;h3 id="loading_the_data_into_visit">Loading the data into VisIt&lt;/h3>
&lt;p>EPOCH comes with an SDF reader plugin for the VisIt parallel
visualization tool. In order to use it, you must first compile the
reader to match the version of VisIt installed on your system. To do
this, first ensure that the &amp;ldquo;visit&amp;rdquo; command is in your path. This is the
case if typing &amp;ldquo;visit&amp;rdquo; on the command line launches the VisIt
application. Once you have this setup, you should be able to type &amp;ldquo;make
visit&amp;rdquo; from one of the epoch{1,2,3}d directories. You will need to re-do
this each time a new version of VisIt is installed on your system.&lt;/p>
&lt;p>Launch the VisIt application by typing &amp;ldquo;visit&amp;rdquo; on the command line. A
useful shortcut is to type &lt;code>visit -o Data/0000.sdf&lt;/code>. This will launch
VisIt and open the specified data file on startup. Alternatively, you
can browse for the file to open using the &amp;ldquo;Open&amp;rdquo; button. All the SDF
files in a directory will be grouped together with a green &amp;ldquo;DB&amp;rdquo; icon and
the name &amp;ldquo;*.sdf database&amp;rdquo;.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/WorkshopLaserVisit.png" alt="An example VisItplot">&lt;/p>
&lt;p>You can then plot a quantity by pressing the &amp;ldquo;Add&amp;rdquo; button, selecting the
type of plot and the variable to use for the plot. When the plot has
been selected, press the &amp;ldquo;Draw&amp;rdquo; button to render it to screen. The plot
above was generated by selecting &amp;ldquo;Add-&amp;gt;Curve-&amp;gt;Electric Field-&amp;gt;Ey&amp;rdquo;.
Some of the plot properties were adjusted to make it look nicer.&lt;/p>
&lt;p>More details on using VisIt are
&lt;a href="/tutorial/visualising_sdf_files_with_llnl_visit">
here&lt;/a>. We
recommend that you learn VisIt &amp;ndash; it&amp;rsquo;s free and powerful.&lt;/p>
&lt;h3 id="loading_data_into_matlab">Loading data into MatLab&lt;/h3>
&lt;p>The EPOCH distribution also comes with a set of reader routines for the
MatLab plotting utility. The routines themselves are contained in the
&amp;ldquo;Epoch/Matlab&amp;rdquo; directory. It is first necessary to add this directory to
your search path. One simple way of doing this is to use the menu item
&amp;ldquo;File-&amp;gt;Set Path&amp;rdquo; and then &amp;ldquo;Add Folder&amp;rdquo; to select the location of the
&amp;ldquo;Matlab&amp;rdquo; folder. To make this change permanent you have to use the
&amp;ldquo;Save&amp;rdquo; button. Unfortunately, on many systems this will not work as it
tries to change global settings which will not be permitted on a
multi-user setup. On Unix systems (including OS X), the change can be
made permanent by using the &amp;ldquo;$MATLABPATH&amp;rdquo; environment variable. For
example in bash this would be &amp;lsquo;export MATLABPATH=&amp;ldquo;Epoch/Matlab&amp;rdquo; ' which
you can add to your .bashrc file.&lt;/p>
&lt;p>To load the data from an SDF file, type the following at the MatLab
prompt:&lt;/p>
&lt;pre>&lt;code class="language-matlab">data=GetDataSDF('Data/0007.sdf');
&lt;/code>&lt;/pre>
&lt;p>The &amp;ldquo;data&amp;rdquo; variable will now contain a data structure similar to that
obtained with the IDL reader. You can explore the contents of the
structure using MatLab&amp;rsquo;s built-in variable editor. To plot Ey, you can
browse to &amp;ldquo;data.Electric_Field.Ey&amp;rdquo;. The structure member
&amp;ldquo;data.Electric_Field.Ey.data&amp;rdquo; contains the 1D array with Ey values.
Right-clicking on it gives a range of options, including &amp;ldquo;plot&amp;rdquo;.  
Alternatively, from the command prompt you can type&lt;/p>
&lt;pre>&lt;code class="language-matlab"> x=data.Electric_Field.Ey.grid.x;
xc=(x(1:end-1) + x(2:end))/2;
plot(xc,data.Electric_Field.Ey.data);
&lt;/code>&lt;/pre>
&lt;p>The first two lines set up a cell-centred grid using the node-centred
grid data. In the future, this work will be automatically done by the
reader.&lt;/p>
&lt;h1 id="a_2d_laser">A 2D laser&lt;/h1>
&lt;p>Next, we will take a look at the 2-dimensional version of the code.&lt;/p>
&lt;ul>
&lt;li>Change to the epoch2d directory: &lt;code>cd ~/Epoch/epoch2d&lt;/code>&lt;/li>
&lt;li>Type &lt;code>make -j4&lt;/code> to compile the code.&lt;/li>
&lt;li>Copy the next example input deck into the Data directory:
&lt;code>cp ~/EXAMPLES/02-2d_laser.deck Data/input.deck&lt;/code> or save the text
below into Data/input.deck&lt;/li>
&lt;li>Run with &lt;code>echo Data | mpirun -np 4 ./bin/epoch2d&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="mw-collapsible mw-collapsed" style="border-style: solid; border-width: 2px; border-color:#0059A1">
&lt;p>Click &amp;ldquo;Expand&amp;rdquo; to view or copy the deck code:&lt;/p>
&lt;div class="mw-collapsible-content">
&lt;pre>&lt;code class="language-perl">begin:control
nx = 500
ny = nx
# Size of domain
x_min = -10 * micron
x_max = -x_min
y_min = x_min
y_max = x_max
# Final time of simulation
t_end = 50 * femto
stdout_frequency = 10
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = open
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:constant
lambda0 = 1 * micron
theta = pi / 8.0
end:constant
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e15
lambda = lambda0 * cos(theta)
profile = gauss(y, 0, 4*micron)
#phase = -2.0 * pi * y * tan(theta) / lambda0
#t_profile = gauss(time, 2*micron/c, 1*micron/c)
end:laser
begin:output
dt_snapshot = 1 * micron / c
# Properties on grid
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
end:output
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;p>This deck is very similar to the 1D version that we have just looked at.
It contains the necessary modifications for adding a new dimension and
some additions to the laser block for driving a laser at an angle.&lt;/p>
&lt;p>The &amp;ldquo;control&amp;rdquo; block now contains &amp;ldquo;ny&amp;rdquo; which specifies the number of grid
points in the y-direction. Notice that we are using the value &amp;ldquo;nx&amp;rdquo; to
set &amp;ldquo;ny&amp;rdquo;. As soon as &amp;ldquo;nx&amp;rdquo; has been assigned it becomes available as a
constant for use as part of a value. We must also provide the minimum
and maximum grid positions in the y-direction using &amp;ldquo;y_min&amp;rdquo;, &amp;ldquo;y_max&amp;rdquo;.
Like &amp;ldquo;nx&amp;rdquo;, the values &amp;ldquo;x_min&amp;rdquo; and &amp;ldquo;x_max&amp;rdquo; are available for use once
they have been assigned.&lt;/p>
&lt;p>In the &amp;ldquo;boundaries&amp;rdquo; block we must include boundary conditions for the
lower and upper boundaries in the y-direction, &amp;ldquo;bc_y_min&amp;rdquo;,
&amp;ldquo;bc_y_max&amp;rdquo;. These have both been set to &amp;ldquo;periodic&amp;rdquo; so that the field
at the top of the domain wraps around to the bottom of the domain.&lt;/p>
&lt;p>&lt;img src="/tutorial/img/Workshop2DLaserVisIt.png" alt="2D laser plot withVisIt">&lt;/p>
&lt;p>Next, we introduce a new block type, &amp;ldquo;constant&amp;rdquo;. This block defines
named variables which can be arbitrary mathematical expressions. Once
defined, these can be used on the left-hand side of name-value pairs in
the same way we used &amp;ldquo;nx&amp;rdquo;, &amp;ldquo;x_min&amp;rdquo;, etc. in the &amp;ldquo;control&amp;rdquo; block. This
facility can greatly aid the construction and maintenance of complex
input decks.&lt;/p>
&lt;p>The &amp;ldquo;laser&amp;rdquo; block is similar to that given in the 1D version except that
there is now a &amp;ldquo;profile&amp;rdquo; parameter. In a similar manner to &amp;ldquo;t_profile&amp;rdquo;
this is a function ranging between 0 and 1 which is multiplied by the
wave amplitude to give a modified laser profile. The only difference is
that this is a function of space rather than time. When applied to a
laser attached to &amp;ldquo;x_min&amp;rdquo; or &amp;ldquo;x_max&amp;rdquo; it is a function of Y, defined at
all points along the boundary. When the laser is attached to &amp;ldquo;y_min&amp;rdquo; or
&amp;ldquo;y_max&amp;rdquo;, it is a function of X.&lt;/p>
&lt;p>Finally, the output block has been modified so that it outputs all
electromagnetic field components.&lt;/p>
&lt;p>The result of plotting &amp;ldquo;Add-&amp;gt;Pseudocolor-&amp;gt;Electric Field-&amp;gt;Ey&amp;rdquo; in
VisIt is shown above. &lt;img src="/tutorial/img/Workshop2DLaserMatplot.png" alt="2D laser plot withMatplotlib">&lt;/p>
&lt;p>The laser block also contains a commented-out &amp;ldquo;phase&amp;rdquo; entry. Unlike in
the 1D version seen previously, this is a function of Y, like the
&amp;ldquo;profile&amp;rdquo; parameter. Uncommenting this line and re-running the deck will
generate a laser driven at an angle to the boundary. The mathematical
details explaining why this works are explained in more detail in the
User Manual. By making the value of &amp;ldquo;theta&amp;rdquo; a function of Y, it is also
possible to produce a focused laser. This is left as an exercise for the
reader!&lt;/p>
&lt;p>The above plot can also be generated using matplotlib using the command
&lt;code>plot2d(data.Electric_Field_Ey)&lt;/code>&lt;/p>
&lt;h1 id="specifying_particle_species">Specifying particle species&lt;/h1>
&lt;p>In this example we will finally introduce some particles into the PIC
code! The deck is for the 1D version of the code, so change back to the
epoch1d directory and copy ~/EXAMPLES/03-1d_two_stream.deck to
Data/input.deck (or copy the deck below) and run the code.&lt;/p>
&lt;div class="mw-collapsible mw-collapsed" style="border-style: solid; border-width: 2px; border-color:#0059A1">
&lt;p>Click &amp;ldquo;Expand&amp;rdquo; to view or copy the deck code:&lt;/p>
&lt;div class="mw-collapsible-content">
&lt;pre>&lt;code class="language-perl">begin:control
nx = 400
# Size of domain
x_min = 0
x_max = 5.0e5
# Final time of simulation
t_end = 1.5e-1
stdout_frequency = 400
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
end:boundaries
begin:constant
drift_p = 2.5e-24
temp = 273
dens = 10
end:constant
begin:species
# Rightwards travelling electrons
name = Right
charge = -1
mass = 1.0
temp = temp
drift_x = drift_p
number_density = dens
npart = 4 * nx
end:species
begin:species
# Leftwards travelling electrons
name = Left
charge = -1
mass = 1.0
temp = temp
drift_x = -drift_p
number_density = dens
npart = 4 * nx
end:species
begin:output
# Number of timesteps between output dumps
dt_snapshot = 1.5e-3
# Properties at particle positions
particles = always
px = always
# Properties on grid
grid = always
ey = always
end:output
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;p>The control block has one new parameter. &amp;ldquo;npart&amp;rdquo; gives the total number
of PIC particles to use in the simulation.&lt;/p>
&lt;p>The input deck contains a new block type, &amp;ldquo;species&amp;rdquo;, which is used for
populating the domain with particles. Every species block must contain a
&amp;ldquo;name&amp;rdquo; parameter. This is used to identify the particle species in other
sections of the input deck and is also used for naming variables in the
output dumps. The next parameter is &amp;ldquo;charge&amp;rdquo; which gives the charge on
each particle in terms of elementary charge units. &amp;ldquo;mass&amp;rdquo; is specified
in units of electron mass. &amp;ldquo;frac&amp;rdquo; is the fraction of the total number of
PIC particles (npart) to assign to this species. Both of the blocks in
this deck use &amp;ldquo;frac = 0.5&amp;rdquo;, so there will be 1600 particles of each
species. The next parameter, &amp;ldquo;temp&amp;rdquo;, sets the average temperature of the
particle species in Kelvin. Alternatively, you can use &amp;ldquo;temp_ev&amp;rdquo; to
specify the temperature in electronvolts. Particles are assigned an
initial momentum corresponding to a Maxwell-Boltzmann distribution for
this temperature. It is defined across the entire problem domain, so in
1D it is a function of X, in 2D a function of X and Y, and in 3D a
function of X, Y and Z. &amp;ldquo;number_density&amp;rdquo; sets the number density across
the problem domain. The code is set to use per-particle weights in the
default Makefile. With this option, the pseudoparticles are distributed
evenly across the domain. Then the weight of each pseudoparticle is
adjusted so that it matches the number density specified in the
&amp;ldquo;number_density&amp;rdquo; parameter. The alternative option is to disable
per-particle weighting. In this case, the weight of each pseudoparticle
is the same and the particles are placed on the grid so that they match
the number density at the start of the simulation. Finally, we have a
&amp;ldquo;drift_x&amp;rdquo; parameter. This is also defined across the entire problem
domain and is used to give the particles an average momentum drift in
the x-direction. There are similar &amp;ldquo;drift_y&amp;rdquo; and &amp;ldquo;drift_z&amp;rdquo; parameters.&lt;/p>
&lt;p>This deck has been designed to simulate a two-stream instability, so it
has two groups of particles which are identical in every respect except
that one set is drifting in the opposite direction to the other. &lt;img src="/tutorial/img/WorkshopTwoStreamPython.png" alt="Thetwo-stream instability inMatplotlib">
&lt;img src="/tutorial/img//tutorial/img/WorkshopTwoStreamGDL.png" alt="The two-stream instability in GDL">&lt;/p>
&lt;p>In the output block we have added a couple of parameters for outputting
particle data. The first parameter, &amp;ldquo;particles&amp;rdquo;, outputs the grid on
which the particles are defined. There are two different types of
variable in EPOCH: particle variables and grid-based variables. The
grid-based variables are like the electromagnetic field components we
have seen previously. The domain is divided into a regular Cartesian
mesh and the grid-based variables are defined at either a node or
cell-centre of each point in this mesh. Particle variables, on the other
hand, are associated with each of the pseudoparticles. These PIC
particles move independently of the Cartesian mesh and can be located
anywhere in the problem domain. The &amp;ldquo;particles&amp;rdquo; parameter requests that
the coordinates of each particle are written to file. This information
is required in order to plot any of the particle variables. The next
parameter is &amp;ldquo;px&amp;rdquo; which writes the momentum of each particle.&lt;/p>
&lt;p>To plot this using python and matplotlib, type the following:&lt;/p>
&lt;pre>&lt;code class="language-python">data = getdata(30)
plot1d(data.Particles_Px_Left,'r.',ms=2,yscale=1)
oplot1d(data.Particles_Px_Right,'b.',ms=2,yscale=1)
ylim([-6e-24,6e-24])
&lt;/code>&lt;/pre>
&lt;p>To plot with GDL, type the following:&lt;/p>
&lt;pre>&lt;code>gdl Start.pro
data=getstruct(30)
plot,data.grid_right.x,data.px_right.data,psym=3,$
yrange=[-6e-24,6e-24],ystyle=1
oplot,data.grid_left.x,data.px_left.data,psym=3,color=150
&lt;/code>&lt;/pre>
&lt;p>Above we have plotted the x-component of particle momentum as a function
of x-position at a time when the instability is just starting to form.
The &amp;ldquo;psym=3&amp;rdquo; option to the plot routine tells GDL to plot each data
point as a dot and not to join the dots up.&lt;/p>
&lt;h1 id="the_output_block_1">The Output Block&lt;/h1>
&lt;p>The contents of the output block can be much more complicated than the
examples shown so far. Here, we will cover the options in a little more
depth.&lt;/p>
&lt;p>EPOCH currently has three different types of output dump. So far, we
have only been using the &amp;ldquo;normal&amp;rdquo; dump type. The next type of dump is
the &amp;ldquo;full&amp;rdquo; dump. To request this type of dump, you add the parameter
&amp;ldquo;full_dump_every&amp;rdquo; which is set to an integer. If this was set equal to
&amp;ldquo;10&amp;rdquo; then after every 9 dump files written, the 10th dump would be a
&amp;ldquo;full&amp;rdquo; dump. This hierarchy exists so that some variables can be written
at frequent intervals whilst large variables such as particle data are
written only occasionally. The third dump type is the &amp;ldquo;restart&amp;rdquo; dump.
This contains all the variables required in order to restart a
simulation, which includes all the field variables along with particle
positions, weights and momentum components. In a similar manner to full
dumps, the output frequency is specified using the
&amp;ldquo;restart_dump_every&amp;rdquo; parameter.&lt;/p>
&lt;p>So far, we have given all the variable parameters a value of &amp;ldquo;always&amp;rdquo; so
that they will always be dumped to file. There are three other values
which can be used to specify when a dump will occur. &amp;ldquo;never&amp;rdquo; indicates
that a variable should never be dumped to file. This is the default used
for all output variables which are not specified in the output block.
The value of &amp;ldquo;full&amp;rdquo; indicates that a variable should be written at full
dumps. &amp;ldquo;restart&amp;rdquo; means it is written into restart dumps.&lt;/p>
&lt;p>There are a few output variables which are grid-based quantities derived
by summing over properties for all the particles contained within each
cell on the mesh. These are &amp;ldquo;ekbar&amp;rdquo;, &amp;ldquo;mass_density&amp;rdquo;, &amp;ldquo;charge_density&amp;rdquo;,
&amp;ldquo;number_density&amp;rdquo; and &amp;ldquo;temperature&amp;rdquo;. To find more details about these
variables, consult the
&lt;a href="/tutorial/input_deck_output_block">output
block&lt;/a> section of the
&lt;a href="/tutorial/landing_page">user
manual&lt;/a>.&lt;/p>
&lt;h1 id="other_laser_plasma_example_decks">Other Laser-Plasma example decks&lt;/h1>
&lt;p>
&lt;a href="/tutorial/workshop_examples_continued">Continue the examples&lt;/a>&lt;/p>
&lt;!-- ######################## Cross references ######################## --></description></item><item><title/><link>/tutorial/workshop_examples_continued/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/tutorial/workshop_examples_continued/</guid><description>&lt;h1 id="other_laser_plasma_example_decks">Other Laser-Plasma example decks&lt;/h1>
&lt;p>Now that you have a basic understanding of how the input decks work, you
should be able to work through the remaining example decks by referring
to the
&lt;a href="/tutorial/landing_page">User manual&lt;/a> for a description of
any new parameters used. Several experienced users of the code will be
available throughout the duration of the workshop, so if you want help
with anything please don&amp;rsquo;t hesitate to ask. The decks are:&lt;/p>
&lt;ul>
&lt;li>01-1d_laser.deck Described in notes above
&lt;a href="/tutorial/workshop_examples/#a_basic_em-field_simulation">(here)&lt;/a>&lt;/li>
&lt;li>02-2d_laser.deck Described in notes above
&lt;a href="/tutorial/workshop_examples/#a_2d_laser">(here)&lt;/a>&lt;/li>
&lt;li>03-1d_two_stream.deck Described in notes above
&lt;a href="/tutorial/workshop_examples/#specifying_particle_species">(here)&lt;/a>&lt;/li>
&lt;li>04-1d_two_stream_io.deck This is the same as the previous deck
but with the addition of more sophisticated output diagnostics&lt;/li>
&lt;li>05-2d_moving_window.deck This deck contains an example of firing a
laser into a plasma and then using the moving window facility to
track the wave front as it moves beyond the edge of the original
domain.&lt;/li>
&lt;li>06-2d_ramp.deck This deck contains an example of firing a laser at
a plasma with a ramped density profile.&lt;/li>
&lt;li>07-1d_heating.deck This deck contains a setup for investigating the
anomalous heating of a plasma that occurs for purely resolved
systems.&lt;/li>
&lt;/ul>
&lt;h3 id="other_things_to_try">Other things to try&lt;/h3>
&lt;ol>
&lt;li>Landau damping predicts collisionless damping of electrostatic
waves. Setup a 1D problem with an electrostatic wave and check for a
range of wavelengths. Points to note:
&lt;ol>
&lt;li>Does the answer depend on whether the initial condition is a
travelling wave or standing wave? How are these setup?&lt;/li>
&lt;li>Look for trapping in the Langmuir wave&lt;/li>
&lt;li>Check the damping rate against published formulae. Try for a
range of $k\lambda_D$ as the most commonly reported formulae
assume $kλ_D≪1$&lt;/li>
&lt;li>The answer is more accurate, assuming you have enough
grid-points and particles to get a good answer, if you ignore
the first maxima or two &amp;ndash; why?&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>A more realistic instability than the two cold beams tested above is
the bump-on-tail instability. Setup a 1D bump-on-tail distribution
and check that the simple formula for the growth-rates is correctly
reproduced. The main problem with the initial conditions is how to
setup a suitable initial distribution.&lt;/li>
&lt;li>Try setting up the initial conditions for a problem of direct
relevance to your research. This may be too computationally
demanding to run on the workshop computers but it is a good exercise
as you can get some help on trickier input decks and diagnostic
planning than the simple exercises so far.&lt;/li>
&lt;li>Check that EPOCH works as expected on your host institution
computer. If not we may be able to help before you leave.&lt;/li>
&lt;/ol>
&lt;h1 id="copies_of_the_decks">Copies of the decks&lt;/h1>
&lt;p>The decks can be downloaded
&lt;a href="/tutorial/workshop_examples/#getting_the_example_decks_for_this_workshop">
here&lt;/a>
and viewed or copied from here:&lt;br>
&lt;strong>04-1d_two_stream_io.deck&lt;/strong>&lt;/p>
&lt;div class="mw-collapsible mw-collapsed" style="border-style: solid; border-width: 2px; border-color:#0059A1">
&lt;p>Click &amp;ldquo;Expand&amp;rdquo; to view or copy the deck code:&lt;/p>
&lt;div class="mw-collapsible-content">
&lt;pre>&lt;code class="language-perl">begin:control
nx = 400
# Size of domain
x_min = 0
x_max = 5.0e5
# Final time of simulation
t_end = 1.5e-1
stdout_frequency = 400
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
end:boundaries
begin:constant
drift_p = 2.5e-24
temp = 273
dens = 10
end:constant
begin:species
# Rightwards travelling electrons
name = Right
charge = -1
mass = 1.0
temp = temp
drift_x = drift_p
number_density = dens
npart = 4 * nx
end:species
begin:species
# Leftwards travelling electrons
name = Left
charge = -1
mass = 1.0
temp = temp
drift_x = -drift_p
number_density = dens
npart = 4 * nx
end:species
begin:output
name = normal
# Number of timesteps between output dumps
dt_snapshot = 1.5e-3
# Properties at particle positions
particles = always
px = always
# Properties on grid
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
jx = always
ekbar = always
mass_density = never + species
charge_density = always
number_density = always + species
temperature = always + species
distribution_functions = always
end:output
begin:output
name = restart
# Number of timesteps between output dumps
dt_snapshot = 0.15
restartable = T
end:output
begin:dist_fn
name = x_px
ndims = 2
direction1 = dir_x
direction2 = dir_px
# Range is ignored for spatial coordinates
range1 = (1, 1)
range2 = (-5e-24, 5e-24)
# Resolution is ignored for spatial coordinates
resolution1 = 1
resolution2 = 200
include_species:Left
include_species:Right
end:dist_fn
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>05-2d_moving_window.deck&lt;/strong>&lt;/p>
&lt;div class="mw-collapsible mw-collapsed" style="border-style: solid; border-width: 2px; border-color:#0059A1">
&lt;p>Click &amp;ldquo;Expand&amp;rdquo; to view or copy the deck code:&lt;/p>
&lt;div class="mw-collapsible-content">
&lt;pre>&lt;code class="language-perl">begin:constant
x0 = 20 * micron
lambda = 10 * micron
t_laser = 120 * femto
sigma_t = t_laser / 2 / sqrt(loge(2))
w0_laser = 30 * micron
sigma_w0 = w0_laser / 2 / sqrt(loge(2))
den_peak = 5.0e19 * 1.0e6
win_start = 340 * femto
end:constant
begin:control
nx = 1550 / 8
ny = 600 / 8
npart = (60e6) / 8
# Size of domain
x_min = 0
x_max = 155 * micron
y_min = -30 * micron
y_max = -y_min
# Final time of simulation
t_end = 1600 * femto
stdout_frequency = 1
print_eta_string = T
end:control
begin:boundaries
bc_x_min = simple_laser
bc_x_max = simple_outflow
bc_y_min = simple_outflow
bc_y_max = simple_outflow
end:boundaries
begin:species
name = electron
charge = -1.0
mass = 1.0
number_density = if((x lt x0), 0.0, den_peak)
frac = 0.5
end:species
begin:species
name = proton
charge = 1.0
mass = 1836.2
number_density = number_density(electron)
frac = 0.5
end:species
begin:output
name = normal
dt_snapshot = 50 * femto
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
jx = always
jy = always
ekbar = always
mass_density = never + species
charge_density = always
number_density = always + species
temperature = always + species
end:output
begin:output
name = large
dt_snapshot = 500 * femto
particles = always
particle_weight = always
end:output
begin:laser
boundary = x_min
intensity_w_cm2 = 1.9e18
lambda = lambda
t_profile = gauss(time, 2*sigma_t, sigma_t)
profile = gauss(y, 0, sigma_w0)
end:laser
begin:window
move_window = T
window_v_x = c * 0.87
window_start_time = win_start
bc_x_min_after_move = simple_outflow
bc_x_max_after_move = simple_outflow
end:window
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>06-2d_ramp.deck&lt;/strong>&lt;/p>
&lt;div class="mw-collapsible mw-collapsed" style="border-style: solid; border-width: 2px; border-color:#0059A1">
&lt;p>Click &amp;ldquo;Expand&amp;rdquo; to view or copy the deck code:&lt;/p>
&lt;div class="mw-collapsible-content">
&lt;pre>&lt;code class="language-perl">begin:constant
# Particles per cell
part = 32
las_lambda = 1 * micron
las_omega = 2.0 * pi * c / las_lambda
las_time = 2.0 * pi / las_omega
n_crit = critical(las_omega)
max_dens = 0.8 * n_crit
scale_x = 20 * micron
las_scale_y = 8 * micron
xmin = -4 * micron
# Gaussian Beam stuff
w0 = las_scale_y
rayleigh_range = pi * w0^2 / las_lambda
wz = w0 * sqrt(1 + (x_start / rayleigh_range)^2)
radius_of_curvature = x_start * (1.0 + (rayleigh_range / x_start)^2)
end:constant
begin:control
nx = 1024 / 4
ny = 512 / 4
# Final time of simulation
t_end = 0.4 * pico
# Size of domain
x_min = xmin
x_end = scale_x + 20 * micron
y_min = -20 * micron
y_max = -y_min
stdout_frequency = 10
end:control
begin:laser
boundary = x_min
intensity_w_cm2 = 1.0e16
omega = las_omega
t_profile = if (time lt 2*las_time, gauss(time, 2*las_time, 2*las_time), 1)
profile = (1.0 + 0.05 * sin(32.0*pi*y/lengthy)) * gauss(y, 0, las_scale_y)
end:laser
begin:boundaries
bc_x_min = simple_laser
bc_x_max = simple_outflow
bc_y_min = periodic
bc_y_max = periodic
end:boundaries
begin:species
# Electron
name = electron
charge = -1.0
mass = 1.0
npart = nx * ny * part
number_density = max_dens * (exp(x/scale_x) - 1) / (exp(1) - 1)
number_density = if(x lt 0, 0.0, number_density(electron))
number_density = if(number_density(electron) gt max_dens, max_dens, \
number_density(electron))
number_density = if(x gt 75*micron, 0.0, number_density(electron))
#number_density = number_density(electron) \
* (0.8 + 0.2 * gauss(y, 0, 0.5*las_scale_y))
number_density_min = 0.0001 * n_crit
number_density_max = n_crit
temp_ev = 10^3
end:species
begin:species
# Protons
name = proton
charge = 1.0
mass = 1836.2
npart = nx * ny * part
number_density = number_density(electron)
number_density_min = 0.0001 * n_crit
number_density_max = 1.2 * n_crit
temp_ev = 40
end:species
begin:output
name = normal
# Number of timesteps between output dumps
dt_snapshot = 5 * femto
# Properties at particle positions
particles = always
px = always
particle_weight = always
# Properties on grid
grid = always
ex = always
ey = always
ez = always
bx = always
by = always
bz = always
jx = always
jy = always
jz = always
ekbar = always + species
mass_density = never + species
charge_density = always # + average + snapshot
number_density = always + species
temperature = never + species
# Extended io
distribution_functions = always
end:output
begin:dist_fn
name = en
ndims = 1
direction1 = dir_en
range1 = (0, 15*kev)
resolution1 = 5000
include_species:electron
end:dist_fn
begin:dist_fn
name = x_en
ndims = 2
direction1 = dir_x
direction2 = dir_en
# Range is ignored for spatial coordinates
#range1 = (1, 1)
range2 = (0, 15*kev)
# Resolution is ignored for spatial coordinates
#resolution1 = 1
resolution2 = 1500
include_species:electron
end:dist_fn
begin:dist_fn
name = x_px
ndims = 2
direction1 = dir_x
direction2 = dir_px
# Range is ignored for spatial coordinates
#range1 = (1, 1)
range2 = (-5e-23, 5e-23)
# Resolution is ignored for spatial coordinates
#resolution1 = 1
resolution2 = 1500
include_species:electron
end:dist_fn
begin:probe
name = electron_probe
point = (0.5 * (x_max + x_min), y_min)
normal = (1, 0)
include_species:electron
include_species:proton
end:probe
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;p>&lt;strong>07-1d_heating.deck&lt;/strong>&lt;/p>
&lt;div class="mw-collapsible mw-collapsed" style="border-style: solid; border-width: 2px; border-color:#0059A1">
&lt;p>Click &amp;ldquo;Expand&amp;rdquo; to view or copy the deck code:&lt;/p>
&lt;div class="mw-collapsible-content">
&lt;pre>&lt;code class="language-perl">begin:constant
dl = 74.33942 * micron
end:constant
begin:control
nx = 10
# Size of domain
x_min = 0
x_max = 14000 * dl
# Final time of simulation
t_end = 1.5e-2
stdout_frequency = 10000
print_eta_string = T
end:control
begin:boundaries
bc_x_min = periodic
bc_x_max = periodic
end:boundaries
begin:species
name = electron
charge = -1
mass = 1.0
temp_x_ev = 1
number_density = 1e16
npart = nx * 5
end:species
begin:output
name = normal
# Number of timesteps between output dumps
dt_snapshot = 1.5e-3
# Properties on grid
grid = always
ekbar = always
temperature = always
end:output
begin:output
name = large
# Number of timesteps between output dumps
dt_snapshot = 75e-3
# Properties at particle positions
particles = always
px = always
py = always
pz = always
end:output
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;h1 id="remote_visualisation_with_visit">Remote Visualisation with VisIt&lt;/h1>
&lt;p>If the local workstation you are using isn&amp;rsquo;t big enough for your test
problems you may also use a your host institutes HPC cluster.&lt;/p>
&lt;h3 id="remote_visualisation_with_visit_1">Remote Visualisation with VisIt&lt;/h3>
&lt;p>Most large simulations are carried out on a remotely located machine.
Often this machine is located many miles away, perhaps even in a
different country. Viewing data on remote systems can be awkward and
poor network speeds can often make it nearly impossible. The VisIt
visualisation tool solves this problem by using a client-server model.
The program which reads, processes and renders the data is completely
separated from the program which displays the results on the screen. It
is therefore possible to run VisIt on your local machine and look at
data located on a different machine. The method of setting this up
varies depending on the configuration of the remote machine so we will
not go into details here. However, the desktop machines have been setup
to be able to view data located on remote clusters so you can try it
out.&lt;/p>
&lt;p>In the VisIt control window, click the &amp;ldquo;Open&amp;rdquo; button which launches a
file browser window. The first entry is called &amp;ldquo;Host&amp;rdquo; and contains a
drop-down list of all configure remote machines.&lt;/p>
&lt;p>If you want to know more about how to set up remote visualisation in
VisIt, you can ask one of the Warwick staff members.&lt;/p>
&lt;p>When viewing data across a slow network connection, there is one more
useful thing to know. VisIt has two methods of drawing plots generated
on a remote machine. The first method is to construct the polygons used
in drawing the plot on the remote machine and send them across the
network. The local machine then turns these into a plot image. This
makes manipulating the figure very fast (zooming, rotating, etc), since
all the polygons that generate the image are on the local machine.
However, if there are a lot of polygons then they can be slow to
transfer across the network. They can also use up a lot of memory. For
these cases, the alternative is to render the image on the remote
machine and just transfer the image across the network. The downside of
this approach is that whenever you manipulate the plot, it must be
re-drawn on the remote machine and then transferred across the network
again. The options controlling this behaviour are to be found under
&amp;ldquo;Options-&amp;gt;Rendering&amp;rdquo; in the &amp;ldquo;Advanced&amp;rdquo; tab. The feature is called
&amp;ldquo;scalable rendering&amp;rdquo;.&lt;/p>
&lt;h1 id="collisions_in_epoch">Collisions in EPOCH&lt;/h1>
&lt;p>EPOCH now contains a collision routine based on the technique outlined
in Sentoku &amp;amp; Kemp&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Collisions are enabled using the output block named
&lt;a href="/tutorial/input_deck_collisions">collisions&lt;/a> which accepts the
following three parameters.&lt;/p>
&lt;ul>
&lt;li>use_collisions &amp;ndash; This is a logical flag which determines whether
or not to call the collision routine. If omitted, the default is
&amp;ldquo;true&amp;rdquo; if any of the frequency factors are non-zero (see below)
and &amp;ldquo;false&amp;rdquo; otherwise.&lt;/li>
&lt;/ul>
&lt;!-- -->
&lt;ul>
&lt;li>coulomb_log &amp;ndash; This may either be set to a real value, specifying
the Coulomb logarithm to use when scattering the particles or to the
special value &amp;ldquo;auto&amp;rdquo;. If &amp;ldquo;auto&amp;rdquo; is used then the routine will
calculate a value based on the properties of the two species being
scattered. If omitted, the default value is &amp;ldquo;auto&amp;rdquo;.&lt;/li>
&lt;/ul>
&lt;!-- -->
&lt;ul>
&lt;li>collide &amp;ndash; This sets up a symmetric square matrix of size
nspecies*nspecies containing the collision frequency factors to use
between particle species. The element (s1,s2) gives the frequency
factor used when colliding species s1 with species s2. If the factor
is less than zero, no collisions are performed. If it is equal to
one, collisions are performed normally. For any value between zero
and one, the collisions are performed using a frequency multiplied
by the given factor. If &amp;ldquo;collide&amp;rdquo; has a value of &amp;ldquo;all&amp;rdquo; then all
elements of the matrix are set to one. If it has a value of &amp;ldquo;none&amp;rdquo;
then all elements are set to minus one. If the syntax &amp;ldquo;species1
species2 &lt;value>&amp;rdquo; is used, then the (species1,species2) element of
the matrix is set to the factor &amp;ldquo;&lt;value>&amp;rdquo;. This may either be a
real number, or the special value &amp;ldquo;on&amp;rdquo; or &amp;ldquo;off&amp;rdquo;. The &amp;ldquo;collide&amp;rdquo;
parameter may be used multiple times. The default value is &amp;ldquo;all&amp;rdquo;
(ie. all elements of the matrix are set to one).&lt;/li>
&lt;/ul>
&lt;p>For example:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:collisions
use_collisions = T
coulomb_log = auto
collide = all
collide = spec1 spec2 off
collide = spec2 spec3 0.1
end:collisions
&lt;/code>&lt;/pre>
&lt;p>With this block, collisions are turned on and the Coulomb logarithm is
automatically calculated. All values of the frequency array are set to
one except (spec1,spec2) is set to minus one (and also (spec2,spec1))
and (spec2,spec3) is set to 0.1&lt;/p>
&lt;h1 id="ionisation_in_epoch">Ionisation in EPOCH&lt;/h1>
&lt;p>EPOCH includes field ionization which can be activated by defining
&amp;ldquo;field_ionisation = T&amp;rdquo; in the
&lt;a href="/tutorial/input_deck_control">control&lt;/a> block along with
ionisation energies and an electron for the ionising species in one of
the
&lt;a href="/tutorial/input_deck_species">species&lt;/a> blocks. This is done
via the species block in the &amp;ldquo;ionisation_energies&amp;rdquo; and
&amp;ldquo;electron_species&amp;rdquo; parameter respectively. &amp;ldquo;ionisation_energies&amp;rdquo;
should be given as a list in joules, and &amp;ldquo;electron_species&amp;rdquo; should be
the name of the species to be used as the electron species. For example,
ionising carbon species might appear in the input deck as:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
charge = 0.0
mass = 1837.2
name = carbon
ionisation_energies = \
(11.26*ev, 24.38*ev, 47.89*ev, 64.49*ev, 392.1*ev, 490.0*ev)
electron_species = electron
number_density = den_gas
end:species
begin:species
charge = -1.0
mass = 1.0
name = electron
number_density = 0.0
end:species
&lt;/code>&lt;/pre>
&lt;p>It is possible to define different electron species for each ionisation
level, which is particularly useful in monitoring specific ionisation
levels. If we wished to monitor the fourth ionisation level of carbon in
the above example, the above example might appear:&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
charge = 0.0
mass = 1837.2
name = carbon
ionisation_energies = \
(11.26*ev, 24.38*ev, 47.89*ev, 64.49*ev, 392.1*ev, 490.0*ev)
electron_species = (electron, electron, electron, fourth, electron, electron)
number_density = den_gas
end:species
begin:species
charge = -1.0
mass = 1.0
name = electron
number_density = 0.0
end:species
begin:species
charge = -1.0
mass = 1.0
name = fourth
number_density = 0.0
end:species
&lt;/code>&lt;/pre>
&lt;p>Field ionisation consists of three distinct regimes; multiphoton in
which ionisation is best described as absorption of multiple photons,
tunneling in which deformation of the atomic coulomb potential is the
dominant factor, and barrier suppression ionisation in which the
electric field is strong enough for an electron to escape classically.
It is possible to turn off multiphoton or barrier suppression ionisation
through the input deck by adding &amp;ldquo;use_multiphoton=F&amp;rdquo; and/or
&amp;ldquo;use_bsi=F&amp;rdquo; to the control block.&lt;/p>
&lt;h1 id="qed_effects_in_epoch">QED Effects in EPOCH&lt;/h1>
&lt;p>EPOCH has recently been extended to include some quantum electrodynamic
effects that are important for high intensity (&amp;gt;) lasers. The two
processes that are included are&lt;/p>
&lt;ul>
&lt;li>Gamma ray production by QED corrected synchrotron emission (Also
called magnetic bremsstrahlung or nonlinear Compton scattering).&lt;/li>
&lt;li>Electron positron pair production by the Breit-Wheeler process from
these gamma ray photons.&lt;/li>
&lt;/ul>
&lt;p>For more information on the theory see Duclous et al. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Simulating the QED effects increases EPOCH&amp;rsquo;s memory requirements and so
the code has to be compiled with the correct compilation options to turn
the module on. To turn the module on, open &amp;ldquo;Makefile&amp;rdquo; in an editor and
find the commented out line &lt;code>#DEFINES += $(D)PHOTONS&lt;/code>. Uncomment this
line, then type &amp;ldquo;make clean&amp;rdquo; and then &amp;ldquo;make&amp;rdquo; (remember to include the
&lt;code>COMPILER=&lt;/code> if you haven&amp;rsquo;t specified the environment variable) to
rebuild the code with QED support.&lt;/p>
&lt;p>Once the code is built with QED support, actually turning on QED for a
specific simulation requires the addition of a new block into the input
deck. This block is simply called
&lt;a href="/tutorial/input_deck_qed">qed&lt;/a>
and starts with the usual &amp;ldquo;begin:qed&amp;rdquo; and &amp;ldquo;end:qed&amp;rdquo; markers of the other
blocks. The parameters which can go into the block are:&lt;/p>
&lt;ul>
&lt;li>use_qed - Turns QED on or off. If you don&amp;rsquo;t want QED effects at all
then compile the code without the &amp;ldquo;-DPHOTONS&amp;rdquo; lines in the makefile.&lt;/li>
&lt;li>qed_start_time - Specifies the time after which QED effects should
be turned on. For example you can turn off the routines until a
laser has crossed the vacuum region in front of the target.&lt;/li>
&lt;li>produce_photons - Specifies whether you&amp;rsquo;re interested in the
photons generated by synchrotron emission. If this is F then the
radiation reaction force is calculated but the properties of the
emitted photons are not tracked.&lt;/li>
&lt;li>photon_energy_min - Minimum energy of produced photons. Radiation
reaction is calculated for photons of all energies, but photons with
energy below this cutoff are not tracked.&lt;/li>
&lt;li>photon_dynamics - If F then photons are generated, but their motion
through the domain is not simulated and they stay where they were
generated. Photon motion is often less interesting than photon
generation unless you want to simulate pair production. In these
cases set this to F.&lt;/li>
&lt;li>produce_pairs - Whether or not to simulate the process of pair
generation from gamma ray photons. Both produce_photons and
photon_dynamics must be T for this to work.&lt;/li>
&lt;li>qed_table_location - EPOCH&amp;rsquo;s QED routines use lookup tables to
calculate gamma ray emission and pair production. If you want to use
tables in a different location from the default put the location in
this parameter.&lt;/li>
&lt;/ul>
&lt;p>QED also requires that the code now know which species are electrons,
positrons and photons. Rather than try to do this automatically the user
has to specify the type of a species. This is done by using a single
&amp;ldquo;identify&amp;rdquo; tag in a species block. To specify an electron the block in
the deck would look like&lt;/p>
&lt;pre>&lt;code class="language-perl">begin:species
name = electron
frac = 0.5
number_density = 7.7e29
identify:electron
end:species
&lt;/code>&lt;/pre>
&lt;p>Once the identity of a species is set then the code automatically
assigns mass and charge states for the species. At present, the user
cannot override these. Possible identities are&lt;/p>
&lt;ul>
&lt;li>electron : A normal electron species. All species of electrons in
the simulation must be identified in this way or they will not
generate photons.&lt;/li>
&lt;li>positron : A normal positron species. All species of positron in the
simulation must be identified in this way or they will not generate
photons.&lt;/li>
&lt;li>photon : A normal photon species. One species of this type is needed
for photon production to work. If multiple species are present then
generated photons will appear in the first species of this type.&lt;/li>
&lt;li>bw_electron : The electron species for pair production. If a
species of this type exists then electrons from the pair production
module will be created in this species. If no species of this type
is specified then pair electrons will be generated in the first
electron species.&lt;/li>
&lt;li>bw_positron : The positron species for pair production. If a
species of this type exists then positrons from the pair production
module will be created in this species. If no species of this type
is specified then pair positrons will be generated in the first
positron species.&lt;/li>
&lt;/ul>
&lt;p>A species should be identified only once, so a &amp;ldquo;bw_electron&amp;rdquo; species
does not need to also be identified as an &amp;ldquo;electron&amp;rdquo; species. If the
code is running with &amp;ldquo;produce_photons=T&amp;rdquo; then a photon species must be
created by user and identified. If the code is running with
&amp;ldquo;produce_pairs=T&amp;rdquo; then the code must specify at least one electron (or
bw_electron) species and one positron (or bw_positron) species. The
code will fail to run if the needed species are not specified.&lt;/p>
&lt;h1 id="other_useful_info">Other Useful Info&lt;/h1>
&lt;h3 id="bug_reports_feature_requests_and_questions">Bug reports, feature requests and questions&lt;/h3>
&lt;p>All questions and requests after the workshop should be posted on the
GitLab EPOCH project
&lt;a href="https://cfsa-pmw.warwick.ac.uk/" target="_blank" rel="noopener">web page&lt;/a>.&lt;/p>
&lt;h3 id="the_visit_programme">The VisIt programme&lt;/h3>
&lt;p>The VisIt programme is free. It can be downloaded from
&lt;a href="https://wci.llnl.gov/simulation/computer-codes/visit/">https://wci.llnl.gov/simulation/computer-codes/visit/&lt;/a> There are many
pre-compiled binaries so this ought to be easy. If you have any problems
post a question on the GitLab EPOCH project.&lt;/p>
&lt;h3 id="gdl_not_idl">GDL not IDL&lt;/h3>
&lt;p>If you don&amp;rsquo;t have IDL, or don&amp;rsquo;t want to pay for it!, then the free GDL
is available from &lt;a href="http://gnudatalanguage.sourceforge.net/">http://gnudatalanguage.sourceforge.net/&lt;/a>&lt;/p>
&lt;h3 id="updating_epoch">Updating EPOCH&lt;/h3>
&lt;p>To update to the latest version of EPOCH simple cd into your Epoch
directory and enter &amp;lsquo;git pull&amp;rsquo;. This will work fine provided you haven&amp;rsquo;t
edited any of the Fortran source code. If you have edited the source
code then you need to learn git.&lt;/p>
&lt;h3 id="getting_old_copies_of_epoch">Getting Old Copies of EPOCH&lt;/h3>
&lt;p>You can also checkout an old version of EPOCH, you may want to get the
version used 18 months ago to reproduce some previous simulations
exactly for example. In this case it is best to checkout a new branch in
the EPOCH repository. If you wanted the version from 10 February 2010
for example you would first enter&lt;br>
&lt;code>git log --before=2010-02-11&lt;/code>&lt;br>
This will give you the log of commits in reverse order, starting on the
11th of February. Identify the commit you want and copy the commit hash
(the long string of numbers and letters following the word &amp;ldquo;commit&amp;rdquo;). To
checkout a copy of this version of the code, type&lt;br>
&lt;code>git checkout -b old-code &lt;/code>&lt;hash>&lt;br>
After this your repository will reflect the state of the code at that
point in time. To get back to the current version, just type&lt;br>
&lt;code>git checkout master&lt;/code>\&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;p>&lt;references />&lt;/p>
&lt;!-- ######################## Cross references ######################## -->
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Y. Sentoku and A. J. Kemp, &amp;ldquo;Numerical methods for particle
simulations at extreme densities and temperatures: Weighted
particles, relativistic collisions and reduced currents,&amp;rdquo; J. Comput.
Phys., 2008.
&lt;a href="http://www.sciencedirect.com/science/article/pii/S0021999108001988" target="_blank" rel="noopener">link&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>R. Duclous, J. G. Kirk, and A. R. Bell, &amp;ldquo;Monte carlo calculations
of pair production in high-intensity laser plasma interactions,&amp;rdquo;
Plasma Phys. Contr. F., vol. 53, no. 1, p. 015009,
2011
&lt;a href="http://iopscience.iop.org/article/10.1088/0741-3335/53/1/015009" target="_blank" rel="noopener">1&lt;/a>.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item></channel></rss>